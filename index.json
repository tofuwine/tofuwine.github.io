[{"content":" 温馨提示 2024-05-17\n本站基于 Hugo-PaperMod 扩展实现的个性化功能 \u0026amp; 样式修改教程将会逐步开放。\n简介 PaperMod-PE (Forked from Hugo-PaperMod)， 是本站基于 PaperMod 主题修改后的开源版本。\nPaperMod-PE 兼容 Hugo-PaperMod (2024-05-15 前) 的功能，参考 Hugo-PaperMod Wiki。\ntofuwine/PaperMod-PE 快速开始 安装 Hugo。参考文档：Hugo Docs\u0026rsquo;s - Quick Start (需要 Hugo 版本 \u0026gt;= v0.125.3)\n创建 Hugo Site\npowershell 1 2 # 将下面 MySite 替换为你的网站名 hugo new site MySite --format yml 更多命令参考：Hugo Docs\u0026rsquo;s - hugo new site command\n启用 Git powershell 1 2 3 cd MySite git init . git add . 安装 PaperMod-PE 主题 powershell 1 git submodule add --depth=1 https://github.com/tofuwine/PaperMod-PE.git themes/PaperMod-PE 修改 Hugo 配置文件： yaml 1 theme: PaperMod-PE 示例工程 PaperMod-PE-Demo：https://github.com/tofuwine/PaperMod-PE-Demo\n示例工程站点：https://tofuwine.github.io/PaperMod-PE-Demo/\n代码块 官方文档：Syntax highlighting\nPaperMod-PE 代码块扩展实现了折叠代码块，自定义标题，自定义显示语言等功能。\n同时重写了代码块样式，PaperMod 的相关参数将会失效。例如，现在复制按钮是内置的，你不能通过参数 ShowCodeCopyButtons 决定显示/隐藏复制按钮。\n标准样式 java 1 2 3 4 5 6 public class HelloHugo { public static void main(String[] args) { System.out.println(\u0026#34;Hello Hugo!\u0026#34;); } } 代码：\nmarkdown 1 2 3 4 5 6 7 8 ```java public class HelloHugo { public static void main(String[] args) { System.out.println(\u0026#34;Hello Hugo!\u0026#34;); } } ``` 自定义标题 java io.github.tofuwine.main.HelloHugo.java 1 2 3 4 5 6 public class HelloHugo { public static void main(String[] args) { System.out.println(\u0026#34;Hello Hugo!\u0026#34;); } } 代码：\nmarkdown 1 2 3 4 5 6 7 8 ```java { title=\u0026#34;io.github.tofuwine.main.HelloHugo.java\u0026#34; } public class HelloHugo { public static void main(String[] args) { System.out.println(\u0026#34;Hello Hugo!\u0026#34;); } } ``` 自定义起始行数 \u0026amp; 高亮指定行 如果希望在代码块中高亮显示某一行或几行 或 修改代码块显示的起始行数，你可以按如下方式：\nmarkdown 1 2 3 4 5 6 7 8 9 10 11 12 ```go { hl_lines=\u0026#34;4 6 8\u0026#34;, lineNoStart=100 } func GetTitleFunc(style string) func(s string) string { switch strings.ToLower(style) { case \u0026#34;go\u0026#34;: return strings.Title case \u0026#34;chicago\u0026#34;: return transform.NewTitleConverter(transform.ChicagoStyle) default: return transform.NewTitleConverter(transform.APStyle) } } ``` 效果：\ngo 100 101 102 103 104 105 106 107 108 109 func GetTitleFunc(style string) func(s string) string { switch strings.ToLower(style) { case \u0026#34;go\u0026#34;: return strings.Title case \u0026#34;chicago\u0026#34;: return transform.NewTitleConverter(transform.ChicagoStyle) default: return transform.NewTitleConverter(transform.APStyle) } } 其中：\nhl_lines: 表示需要高亮的行数，你可以指定多行，用空格分隔。\n如果连续多行，可以使用 -。例如 hl_lines=\u0026quot;4-6 8\u0026quot;，即高亮 4、5、6、8 行。 lineNoStart：表示代码块显示的起始行数 这些都是 Hugo 中定义好的属性，你可以查看官方文档获取更多内容。\n折叠代码块 通过 fold 属性，你可以定义代码块是否折叠。\n对于过长或不是必须展示的代码，你可设置 fold=true，那么它将默认折叠起来。\njava HelloHugo.java 1 2 3 4 5 6 public class HelloHugo { public static void main(String[] args) { System.out.println(\u0026#34;Hello Hugo!\u0026#34;); } } 代码：\nmarkdown 1 2 3 4 5 6 7 8 ```java {title=HelloHugo.java fold=true} public class HelloHugo { public static void main(String[] args) { System.out.println(\u0026#34;Hello Hugo!\u0026#34;); } } ``` 自定义显示语言 此方式是为了避免渲染冲突（如 mermaid，你可能需要此方式才能正确展示语言为 mermaid）。\n如果希望在代码块中展示 mermaid 的代码，如果按正常 markdown 写法：\nmarkdown 1 2 3 4 5 6 7 ```mermaid flowchart LR A[Hard] --\u0026gt;|Text| B(Round) B --\u0026gt; C{Decision} C --\u0026gt;|One| D[Result 1] C --\u0026gt;|Two| E[Result 2] ``` 会被渲染如下：\nflowchart LR A[Hard] --\u003e|Text| B(Round) B --\u003e C{Decision} C --\u003e|One| D[Result 1] C --\u003e|Two| E[Result 2] 你可以通过 lang 属性，修改代码如下：\nmarkdown 1 2 3 4 5 6 7 ```markdown {lang=mermaid} flowchart LR A[Hard] --\u0026gt;|Text| B(Round) B --\u0026gt; C{Decision} C --\u0026gt;|One| D[Result 1] C --\u0026gt;|Two| E[Result 2] ``` 来达到以下效果：\nmermaid 1 2 3 4 5 flowchart LR A[Hard] --\u0026gt;|Text| B(Round) B --\u0026gt; C{Decision} C --\u0026gt;|One| D[Result 1] C --\u0026gt;|Two| E[Result 2] 上述方式代码高亮语法仍是 markdown。如希望高亮显示为自定义语言，需要额外添加属性 force=true，如下：\nmarkdown 1 2 3 4 5 6 7 ```markdown {lang=mermaid force=true} flowchart LR A[Hard] --\u0026gt;|Text| B(Round) B --\u0026gt; C{Decision} C --\u0026gt;|One| D[Result 1] C --\u0026gt;|Two| E[Result 2] ``` 赞赏 功能描述 在章末显示 \u0026lt;赞赏\u0026gt; 按钮，点击按钮后显示微信/支付宝收款码。\n样式预览 可前往本文章末预览。\n配置 yaml 1 2 3 4 5 6 7 8 9 10 11 param: # 启用赞赏功能 enableReward: true # 赞赏按钮显示字符 (可在文章 `frontmatter` 中设置)，默认为赞赏图标 # rewardButton: 赞赏 # 赞赏描述 (可在文章 `frontmatter` 中设置) rewardDescription: 如果本文对你有所帮助，可以点击上方按钮请作者喝杯咖啡！ # 设置微信收款码图片 WechatPay: images/wechat_pay.jpg # 设置支付宝收款码图片 Alipay: images/alipay.jpg 评论 📢 攻略已发布: PaperMod 集成 Giscus 评论\n功能描述 为文章添加评论区功能。PaperMod-PE 默认集成 giscus 评论功能。\n配置 评论区标题 \u0026amp; 副标题 设置方式如下：\nyaml 1 2 3 4 5 6 7 params: # 启用评论 comments: true # 评论区标题 (可在文章 `frontmatter` 中设置) discussionTitle: 欢迎来到评论区 # 评论区子标题 (可在文章 `frontmatter` 中设置) discussionSubtitle: 感谢您的耐心阅读！来选个表情，或者留个评论吧！ Giscus 前往 giscus.app，获取相关配置。\nyaml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 params: # giscus 评论参数 giscus: repo: \u0026#34;\u0026lt;your repository\u0026gt;\u0026#34; repoId: \u0026#34;\u0026lt;your repo id\u0026gt;\u0026#34; category: \u0026#34;Announcements\u0026#34; categoryId: \u0026#34;\u0026lt;your category id\u0026gt;\u0026#34; mapping: \u0026#34;pathname\u0026#34; strict: \u0026#34;0\u0026#34; reactionsEnabled: \u0026#34;1\u0026#34; emitMetadata: \u0026#34;0\u0026#34; inputPosition: \u0026#34;top\u0026#34; lightTheme: \u0026#34;light\u0026#34; darkTheme: \u0026#34;dark\u0026#34; lang: \u0026#34;zh-CN\u0026#34; 样式预览 前往本文底部预览评论区。\nFancybox 功能描述 启用图片灯箱预览。\n配置 按如下配置启用 Fancybox 灯箱。\nyaml 1 2 3 param: # 启用 Fancybox 灯箱 enableFancybox: true 数学公式 功能描述 渲染数学公式，同时支持内联显示和块显示。PaperMod-PE 支持 KaTex 和 MathJax 两种渲染方式。\n样式预览 内联显示 两数和的平方，等于它们的平方和加上它们的积的2倍。 即：\\$(a+b)^2=a^2+2ab+b^2\\$\n代码：\nmarkdown 1 两数和的平方，等于它们的平方和加上它们的积的2倍。 即：\\$(a+b)^2=a^2+2ab+b^2\\$ 块显示 $$ \\begin{aligned} KL(\\hat{y} || y) \u0026= \\sum_{c=1}^{M}\\hat{y}_c \\log{\\frac{\\hat{y}_c}{y_c}} \\\\ JS(\\hat{y} || y) \u0026= \\frac{1}{2}(KL(y||\\frac{y+\\hat{y}}{2}) + KL(\\hat{y}||\\frac{y+\\hat{y}}{2})) \\end{aligned} $$ 代码：\nmarkdown 1 2 3 4 5 6 $$ \\begin{aligned} KL(\\hat{y} || y) \u0026amp;= \\sum_{c=1}^{M}\\hat{y}_c \\log{\\frac{\\hat{y}_c}{y_c}} \\\\ JS(\\hat{y} || y) \u0026amp;= \\frac{1}{2}(KL(y||\\frac{y+\\hat{y}}{2}) + KL(\\hat{y}||\\frac{y+\\hat{y}}{2})) \\end{aligned} $$ 更多预览，请参考：Markdown 数学公式\n配置 按如下方式启用数学公式渲染：\nyaml 1 2 3 4 5 params: # 启用数学公式渲染 enableMath: true # 数学公式渲染方式: `katex` or `mathjax` mathematicsRenderer: mathjax 悬浮按钮 PaperMod-PE 支持三种悬浮按钮：回到顶部 (Go to Top)、前往评论区 (Go to Comment)、切换主题 (Theme toggle)。 你可以在屏幕右下角体验这些悬浮按钮。\n前往评论区 (Go to comment) 功能描述 快速跳转到评论区。\n配置 yaml 1 2 3 params: # 悬浮按钮 —— Go to Comment enableScrollToComment: true 切换主题 (Theme toggle) 功能描述 切换页面主题 (light / dark)。\n配置 yaml 1 2 3 params: # 悬浮按钮 —— Theme Toggle enableThemeToggleFloat: true 回到顶部 (Go to top) 功能描述 快速跳转到页面顶部。\n配置 yaml 1 2 3 params: # 悬浮按钮 —— Go to Top enableScrollToTop: true 文章版权声明 📢 攻略已发布: PaperMod 添加文章版权声明\n在章末显示原创内容版权信息 or 转载内容的原文信息。\n原创内容 可为原创内容显示版权信息，同时显示文章标题(含作者名) \u0026amp; 文章链接。\n配置 可通过 config.yml 配置默认 license 信息：\nyaml 1 2 3 4 5 6 7 params: # 文章作者 (PaperMod 主题参数) author: tofuwine # 版本链接 licenseLink: \u0026#34;https://creativecommons.org/licenses/by-nc/4.0/\u0026#34; # 版本显示名 licenseName: \u0026#34;CC BY-NC 4.0\u0026#34; 也可在文章 frontmatter 中指定 license 信息：\nmarkdown 1 2 3 4 5 --- author: tofuwine licenseLink: \u0026#34;https://creativecommons.org/licenses/by-nc/4.0/\u0026#34; licenseName: \u0026#34;CC BY-NC 4.0\u0026#34; --- 样式预览 你可以在本文章末预览样式。\n转载内容 为转载内容显示原文标题、作者、链接以及侵权联系方式。\n配置 在 frontmatter 中添加如下配置：\nmarkdown 1 2 3 4 5 6 7 --- reposted: true repostedTitle: \u0026#34;PaperMod-PE Documents\u0026#34; repostedAuthor: \u0026#34;tofuwine\u0026#34; repostedLink: \u0026#34;https://www.tofuwine.cn/articles/site/hugo/041e0ff6-f9a1-4212-a1de-5af6c2c7568a/\u0026#34; contactEmail: tofuwine@outlook.com --- 其中联系方式也可在 config.yml 进行全局配置：\nyaml 1 2 params: contactEmail: tofuwine@outlook.com 样式预览 前往转载文章 Linux 文件系统的组成 的章末预览样式。\nTypeIt 主页副标题使用 TypeIt 动态效果。hugo 配置文件增加如下配置：\nyaml 1 2 params: enableTypeIt: true 说明：当前仅支持主页副标题，其他页面无效果。\nCloudflare Web Analytics 通过以下配置开启 Cloudflare Web Analytics 的支持：\nyaml 1 2 3 4 params: analytics: cloudflare: WebAnalyticsToken: \u0026#34;your_token\u0026#34; Token 获取方式：\n前往 Cloudflare Dashboard 找到 分析和日志 \u0026gt; Web Analytics，添加你的站点会获得一个 JS 片段，拿到其中的 token 值。 如果使用 Cloudflare Pages 部署，可在你的 Pages 管理界面 管理 \u0026gt; Web Analytics 启用 Cloudflare Web Analytics，而无需进行上述配置。\nBaidu Site Verification (Preview) 预览功能。\n作者按百度官方相关文档未能成功验证，可能跟站点部署在 Cloudflare Pages 有关？\n通过以下配置添加百度网站验证：\nyaml 1 2 3 4 params: analytics: baidu: SiteVerificationTag: \u0026#34;your_tag\u0026#34; 自定义页面 友链 添加 \u0026lt;友链\u0026gt; 页面\n创建 friend.md 文件，内容参考如下：\nmarkdown content/friend.md 1 2 3 4 5 6 7 8 9 10 title: \u0026#34;🤝 友链\u0026#34; layout: \u0026#34;friend\u0026#34; hideMeta: true showBreadCrumbs: false ShowToc: false discussionTitle: 👇 申请友链 👇 discussionSubtitle: 在下方评论区留下你的链接吧! hideRewardSubtitle: true rewardButton: 赞 searchHidden: true 友链页面链接：/friend/\n添加友链信息 通过 Shortcode friend 进行友链的添加，在 friend.md 中添加如下内容，即可添加一条友链信息。\nmarkdown 1 {{\u0026lt; friend name=\u0026#34;Tofuwine\u0026#39;s Blog\u0026#34; url=\u0026#34;https://www.tofuwine.cn\u0026#34; logo=\u0026#34;https://www.tofuwine.cn/images/profile.png\u0026#34; description=\u0026#34;记录、 分享，仅此。\u0026#34; \u0026gt;}} 关于 创建 about.md 文件，内容参考如下：\nmarkdown content/about.md 1 2 3 4 5 6 7 8 9 10 11 12 13 --- title: \u0026#34;🧑‍💻 关于\u0026#34; layout: \u0026#34;about\u0026#34; hideMeta: true showBreadCrumbs: false ShowToc: false comments: true discussionTitle: 👇 畅所欲言 👇 discussionSubtitle: hideRewardSubtitle: true rewardButton: 赞 searchHidden: true --- 关于页面链接：/about/\n瞬间 📢 攻略已发布: Hugo 添加瞬间页\n创建 moments/_index.md 文件，内容参考如下：\nmarkdown content/moments/_index.md 1 2 3 4 5 6 7 8 9 10 11 12 --- title: \u0026#34;🌟 瞬间\u0026#34; layout: \u0026#34;moments\u0026#34; DateFormat: 2006-01-02 03:04 build: render: always cascade: - build: list: local publishResources: false render: never --- 瞬间页面链接：/moments/。\nShortcode admonition note 样式：\nnote admonition - note 代码：\nmarkdown 1 2 3 {{\u0026lt; admonition type=note title=note open=true \u0026gt;}} admonition - note {{\u0026lt; /admonition \u0026gt;}} abstract 样式：\nabstract admonition - abstract 代码：\nmarkdown 1 2 3 {{\u0026lt; admonition type=abstract title=abstract open=true \u0026gt;}} admonition - abstract {{\u0026lt; /admonition \u0026gt;}} info 样式：\ninfo admonition - info 代码：\nmarkdown 1 2 3 {{\u0026lt; admonition type=info title=info open=true \u0026gt;}} admonition - info {{\u0026lt; /admonition \u0026gt;}} tip 样式：\ntip admonition - tip 代码：\nmarkdown 1 2 3 {{\u0026lt; admonition type=tip title=tip open=true \u0026gt;}} admonition - tip {{\u0026lt; /admonition \u0026gt;}} success 样式：\nsuccess admonition - success 代码：\nmarkdown 1 2 3 {{\u0026lt; admonition type=success title=success open=true \u0026gt;}} admonition - success {{\u0026lt; /admonition \u0026gt;}} question 样式：\nquestion admonition - question 代码：\nmarkdown 1 2 3 {{\u0026lt; admonition type=question title=question open=true \u0026gt;}} admonition - question {{\u0026lt; /admonition \u0026gt;}} warning 样式：\nwarning admonition - warning 代码：\nmarkdown 1 2 3 {{\u0026lt; admonition type=warning title=warning open=true \u0026gt;}} admonition - warning {{\u0026lt; /admonition \u0026gt;}} failure 样式：\nfailure admonition - failure 代码：\nmarkdown 1 2 3 {{\u0026lt; admonition type=failure title=failure open=true \u0026gt;}} admonition - failure {{\u0026lt; /admonition \u0026gt;}} danger 样式：\ndanger admonition - danger 代码：\nmarkdown 1 2 3 {{\u0026lt; admonition type=danger title=danger open=true \u0026gt;}} admonition - danger {{\u0026lt; /admonition \u0026gt;}} bug 样式：\nbug admonition - bug 代码：\nmarkdown 1 2 3 {{\u0026lt; admonition type=bug title=bug open=true \u0026gt;}} admonition - bug {{\u0026lt; /admonition \u0026gt;}} example 样式：\nexample admonition - example 代码：\nmarkdown 1 2 3 {{\u0026lt; admonition type=example title=example open=true \u0026gt;}} admonition - example {{\u0026lt; /admonition \u0026gt;}} quote 样式：\nquote admonition - quote 代码：\nmarkdown 1 2 3 {{\u0026lt; admonition type=quote title=quote open=true \u0026gt;}} admonition - quote {{\u0026lt; /admonition \u0026gt;}} hl (Deprecated) Deprecated：未来将会删除。\nhugo 0.126.0 起支持 inserted text, mark text, subscript, and superscript。\n查看官网介绍：extras-extension\n文本高亮。\n样式：\nThis is a highlight text. 代码：\nmarkdown 1 2 3 {{\u0026lt; hl \u0026gt;}} This is a highlight text. {{\u0026lt; /hl \u0026gt;}} git (Preview) 显示 git 代码仓库。\n语法：(以 Gitee 平台的 dromara/hutool 仓库为例)\nmarkdown 1 {{\u0026lt; git platform=\u0026#34;gitee\u0026#34; repo=\u0026#34;dromara/hutool\u0026#34; \u0026gt;}} 更方便写法：\nmarkdown 1 {{\u0026lt; git \u0026#34;https://gitee.com/dromara/hutool\u0026#34; \u0026gt;}} 目前支持的平台：\ngithub gitee GitHub Shortcode：\nmarkdown 1 {{\u0026lt; git platform=\u0026#34;github\u0026#34; repo=\u0026#34;dromara/hutool\u0026#34; \u0026gt;}} 渲染结果：\ndromara/hutool Gitee Shortcode：\nmarkdown 1 {{\u0026lt; git platform=\u0026#34;gitee\u0026#34; repo=\u0026#34;dromara/hutool\u0026#34; \u0026gt;}} 渲染结果：\ndromara/hutool 特别说明 这是作者参考 halo 插件 Vditor 编辑器 实现的。目前为预览功能，仍可能存在问题。。 为缓存避免频繁请求 API 接口，初次请求结果会缓存在 localStorage 中，有效期 1 小时（过期并不会删除）。 未完善异常处理。因网络等原因导致请求失败后，可能会导致样式问题。 (2024.05.20 起 支持异常样式)。 tip (Preview) 用于替代 admonition 的简码。目前支持以下类型：\ndefault markdown 1 2 3 {{\u0026lt; tip \u0026gt;}} tip content {{\u0026lt; /tip \u0026gt;}} 效果如下：\ntip content warning markdown 1 2 3 {{\u0026lt; tip warning \u0026gt;}} warning content {{\u0026lt; /tip \u0026gt;}} 效果如下：\nwarning content FAQ 如何更新主题 使用如下命令更新主题：\npowershell 1 git submodule update --init --recursive ","permalink":"https://tofuwine.github.io/posts/041e0ff6/","summary":"Documentation for PaperMod-PE","title":"PaperMod-PE Documents"},{"content":"使用 Google 搜索时，有许多技巧可以帮助我们更有效地找到所需的信息。\n以下是一些常见和高级的 Google 搜索技巧：\n基本技巧 使用引号进行精准匹配 搜索一个确切的短语：\u0026quot;exact phrase\u0026quot;\n快速预览：Google 搜索\n使用减号排除词 排除包含特定词的结果：keyword -excludedword\n快速预览：Google 搜索\n使用星号作为通配符 用星号表示未知或任何词：\u0026quot;a * saved is a * earned\u0026quot;\n快速预览：Google 搜索\n使用OR进行多个选项搜索 搜索多个可能的词：keyword1 OR keyword2\n快速预览：Google 搜索\n使用 site: 进行站内搜索 限定在特定网站内搜索：site:example.com keyword\n快速预览：Google 搜索\n使用 filetype: 搜索特定文件类型 搜索特定类型的文件：filetype:pdf keyword\n快速预览：Google 搜索\n高级技巧 使用 inurl: 搜索URL中的特定词 搜索URL包含特定词的页面：inurl:keyword\n快速预览：Google 搜索\n使用 intitle: 搜索标题中的特定词 搜索标题中包含特定词的页面：intitle:keyword\n快速预览：Google 搜索\n使用 define: 查询定义 查询词语的定义：define:keyword\n快速预览：Google 搜索\n使用 related: 查找相关网站 查找与特定网站类似的网站：related:example.com\n快速预览：Google 搜索\n使用 cache: 查看网页的缓存版本 查看Google的缓存页面：cache:example.com\n预览：Google 搜索输入：cache:wikipedia.org\n使用 AROUND(N) 进行近似匹配 查找两词之间间隔不超过N个词的结果：keyword1 AROUND(N) keyword2\n快速预览：Google 搜索\n使用 allintext: 搜索正文中的所有词 查找正文中包含所有指定词的页面：allintext:keyword1 keyword2\n快速预览：Google 搜索\n使用 allintitle: 搜索标题中的所有词 查找标题中包含所有指定词的页面：allintitle:keyword1 keyword2\n快速预览：Google 搜索\n特定信息查询 天气 查询某地天气：weather location\n快速预览：Google 搜索\n时间 查询某地时间：time location\n快速预览：Google 搜索\n股票 查询股票行情：stock symbol\n快速预览：Google 搜索\n计算 进行数学计算：直接输入公式\n快速预览：Google 搜索\n也可以通过输入 calculator 或 calc 打开计算器。\n单位转换 进行单位转换：quantity unit to unit\n快速预览：Google 搜索\n定义词语 查找词语定义：define:word\n快速预览：Google 搜索\n定时器/秒表 输入 timer 或 stopwatch 即可打开定时器/秒表。\n综合示例 假设你需要查找与AI相关的最新论文，但不希望看到广告或与招聘相关的内容，并且只想查找PDF文件。你可以使用以下组合搜索：\ntext 1 \u0026#34;artificial intelligence\u0026#34; -advertisement -jobs filetype:pdf 快速预览：Google 搜索\n使用这些技巧，可以显著提高在 Google 上的搜索效率，快速找到更精准的信息。\n","permalink":"https://tofuwine.github.io/posts/70df73fb/","summary":"Google 搜索的高级技巧","title":"Google 搜索技巧"},{"content":"概要 新建 GitHub 仓库存储我们的图片 配置 Typora + PicGo 实现图片的自动上传 使用 jsDelivr CDN 加速图片访问 GitHub 图床仓库 登录 GitHub 账户，前往 new，新建一个 GitHub 仓库，如：MyImgRepo。（需 Public 权限）。\n分支说明 默认情况下，GitHub 仓库主分支名为 main。你可以前往设置修改。 token 前往 tokens 页，按下图方式创建 Personal access token:\n按下图方式填写信息，\n最后点击 Generate token 按钮生成 token，你的 token 在如下位置显示：\n随便找个文件保存你的 token，后续需要使用。\nPicGo 前往 GitHub 下载 PicGo。\n打开 PicGo 界面，如果启动后没显示界面，可在右下角隐藏图标中寻找，右键 打开主窗口。\nPicGo 设置 以下为可选项，按需修改：\n设置代理和镜像地址。如果总是上传文件失败，建议配置此项，添加上传代理。（例如，使用 Clash for Windows，那么默认的地址就是 http://127.0.0.1:7890） 时间戳重命名，避免图片重名被覆盖。 请选择显示的图床：勾选 ✅ GitHub。（如果已经勾选，请跳过此步骤） 图床设置 在 图床设置 \u0026gt; GitHub: 你可以选择新增一个或者修改 Default 的。\n参数说明：\n图床配置名：保持默认即可或任意填写（不重要） 设定仓库名：在 GitHub 章节 新建的仓库，格式为 用户名/仓库名 设定分支名：设置你仓库分支名，如果你未修改 GitHub 配置，那么默认为 main 设定 Token：使用在 GitHub 章节 保存的 Token 设定存储路径：图片上传到仓库的指定路径 设定自定义域名：可留空或参考 jsDelivr CDN 章节。 Typora 注意：该软件为付费软件。官网：https://typoraio.cn/\n在 Typora 设置中，按如下配置：\n此时在 Typora 书写 Markdown 时，复制一张图片到 typora，则会自动上传到 GitHub，并修改文件路径为 GitHub 的地址。\n如果你不能使用 Typora，可以通过 PicGo 手动上传，然后复制最终链接到 Markdown。\njsDelivr CDN 上述步骤操作后，得到的图片地址是以 https://raw.githubusercontent.com 开头的，这个站点在国内访问效果很不理想。因此我们通常使用 CDN 加速图片的访问，这里我们通过免费的 jsDelivr 实现。\n修改 PicGo 图床配置，设定自定义域名为：（将链接中的 tofuwine/MyImgRepo@main 换成你的配置，tofuwine/MyImgRepo 对应仓库名，main 对应分支名）\ntext 1 https://cdn.jsdelivr.net/gh/tofuwine/MyImgRepo@main ","permalink":"https://tofuwine.github.io/posts/6b53001d/","summary":"使用 Github 存储图片作为免费图床并通过 Typora + PicGo 自动上传","title":"Github 免费图床攻略"},{"content":"前言 之前使用 Halo 时，可以通过插件实现瞬间页面，类似发朋友圈一样。对我来说，一些简单的内容又不想单独作为一篇文章，瞬间页可以很好的满足需求。 但是转用 hugo 后，搜索了很多教程和优秀的博主站点都没有该功能。抄不了那没办法只能硬着头皮自己码代码了。\n如果你不想了解实现过程，可直接跳转到 完整代码，直接复制完整代码。 如果你使用的是本站开源主题 PaperMod-PE 可直接跳转 使用教程。\n效果展示 你可以前往 🌟 瞬间 预览本站最新的实现效果。\n基本思路 目标：使用一个文件夹例如 moments 来作为瞬间页内容的来源，每条瞬间一个 md 文件。 页面模板 为了展示瞬间的内容，第一步新建一个瞬间页面模板，来容纳每一条瞬间。\n基于我们的目标，需要将多个 md 文件内容容纳到一个页面，并且考虑到未来内容很多时的还需要分页展示，所以这里采用 Section page templates。\n根据文档 Section pages 可知，我们可以使用多种形式来创建这个界面模板。我们这里以 layouts/section/list.html 形式为例。 创建 list.html，路径为 layouts/moments/list.html，瞬间界面结构在此定义。\n本站瞬间界面结构参考微信朋友圈实现。\nBuild options 基于我们的目标，将多个 md 文件整合到一个界面后，那么就不应该在单独渲染每一条瞬间原本的界面，否则会污染整个站点的结构（如 site.Pages 包含很多瞬间的内容，这不是我们希望看到的）。 通过查阅官方文档，了解到 Hugo Build options。这也是我们实现这个功能的一个核心。\n根据文档内容，我们可以创建 _index.md:\nmarkdown content/moments/_index.md 1 2 3 4 5 6 7 8 9 10 --- title: \u0026#34;🌟 瞬间\u0026#34; build: render: always cascade: - build: list: local publishResources: false render: never --- 这样我们重启 hugo，就可以访问 http://localhost:1313/moments/ 界面了，并且 content/moments 目录下所有 md 都不会被渲染成页面。\n评论 本文采用 Giscus。如果你也希望集成 Giscus，可参考本站教程：PaperMod 集成 Giscus 评论 根据 Giscus 官方文档 可知，我们可以通过修改参数 data-mapping=\u0026quot;specific\u0026quot; 并指定 data-term， 来自定义页面 ↔️ discussion 映射关系。 这使得我们能为每个瞬间实现评论功能。\n由于 giscus 实现方式，没办法同时显示所有瞬间评论内容，因此采用更简单粗暴的方式，用户主动点击右下角评论按钮再展示评论区。 通过在页面模板中，将每个瞬间的 slug 赋值到评论按钮的属性 (data-slug) 上，然后通过这个值在 JS 中动态生成每个瞬间的 data-term。\n如果你的站点使用的不是 Giscus，你可以参考你的评论系统的官方文档来修改评论按钮的点击方法 function showComment(element)。\n使用教程 PaperMod-PE 请先更新到最新版本。\n创建 _index.md: (内容参考如下)\nmarkdown content/moments/_index.md 1 2 3 4 5 6 7 8 9 10 11 --- title: \u0026#34;🌟 瞬间\u0026#34; DateFormat: 2006-01-02 15:04 build: render: always cascade: - build: list: local publishResources: false render: never --- DateFormat：修改瞬间显示的时间格式。你可以参考 官方文档 自定义你的时间格式。 如果未配置此项，则默认使用站点的 DateFormat。即：（以下为示例）\nyaml hugo.yml 1 2 params: DateFormat: 2006-01-02 这样你就可以访问瞬间界面 /moments。\n如何新增一条瞬间 在 moments 目录下创建一个 md 文档，frontmatter 参考如下：\nmarkdown 1 2 3 4 5 6 7 8 --- date: 2024-03-13T09:05:00+08:00 slug: \u0026#34;change to your moment slug\u0026#34; tags: - Apple draft: false --- enter your moment content. 参数说明：\ndate 是可选的。在瞬间左下角显示的时间。（建议显示指定该值，如果你未配置此项，也可能显示时间，因为赋值方式为 .Param \u0026quot;date\u0026quot;） slug 是必须的。它涉及到与评论绑定，建议使用 UUID 或随机数来保证不重复。 tags 是可选的。标记这条瞬间的标签，可以为多个。（注意，此标签与文章标签无关） hideComment 是可选的。如果为 true 则不会在这个瞬间的右下角显示评论按钮。 完整代码 最新源码请参考 PaperMod-PE moments.html html layouts/moments/list.html 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 {{- define \u0026#34;main\u0026#34; }} {{- $paginator := .Paginate .Pages }} {{ $dateformat := .Params.DateFormat }} \u0026lt;article class=\u0026#34;post-single\u0026#34;\u0026gt; \u0026lt;header class=\u0026#34;page-header\u0026#34;\u0026gt; \u0026lt;h1\u0026gt; {{- (printf \u0026#34;%s\u0026amp;nbsp;\u0026#34; .Title ) | htmlUnescape -}} \u0026lt;/h1\u0026gt; {{- if .Description }} \u0026lt;div class=\u0026#34;post-description\u0026#34;\u0026gt; {{ .Description }} \u0026lt;/div\u0026gt; {{- end }} \u0026lt;/header\u0026gt; \u0026lt;div class=\u0026#34;post-content\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;pe-moments\u0026#34;\u0026gt; \u0026lt;ul\u0026gt; {{- range $moment := $paginator.Pages }} {{- if .Content }} \u0026lt;li class=\u0026#34;pe-moment\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;{{ site.Params.label.icon }}\u0026#34; alt=\u0026#34;{{ site.Params.author }}\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;pe-moment-body\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;pe-moment-content\u0026#34;\u0026gt; {{ .Content }} \u0026lt;/div\u0026gt; {{ if .Params.tags }} \u0026lt;div class=\u0026#34;pe-moment-tags\u0026#34;\u0026gt; {{- range $index, $tag := (.Params.tags) }} \u0026lt;span class=\u0026#34;pe-moment-tag\u0026#34;\u0026gt;{{ $tag }}\u0026lt;/span\u0026gt; {{- end }} \u0026lt;/div\u0026gt; {{ end }} \u0026lt;div class=\u0026#34;pe-moment-bottom\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;pe-moment-time\u0026#34;\u0026gt; \u0026lt;span\u0026gt;{{ $moment.Param \u0026#34;date\u0026#34; | time.Format (default site.Params.DateFormat $dateformat) }}\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; {{ if not .Params.hideComment }} \u0026lt;button class=\u0026#34;pe-moment-comment-btn\u0026#34; onclick=\u0026#34;showComment(this)\u0026#34; data-slug=\u0026#34;{{ $moment.Param \u0026#34;slug\u0026#34; }}\u0026#34;\u0026gt; \u0026lt;svg viewBox=\u0026#34;0 0 1024 1024\u0026#34; version=\u0026#34;1.1\u0026#34; xmlns=\u0026#34;http://www.w3.org/2000/svg\u0026#34;\u0026gt;\u0026lt;path d=\u0026#34;M281.535354 387.361616c-31.806061 0-57.664646 26.763636-57.664647 59.733333 0 32.969697 25.858586 59.733333 57.664647 59.733334s57.664646-26.763636 57.664646-59.733334c0-33.09899-25.858586-59.733333-57.664646-59.733333z m230.529292 0c-31.806061 0-57.664646 26.763636-57.664646 59.733333 0 32.969697 25.729293 59.733333 57.664646 59.733334 31.806061 0 57.535354-26.763636 57.535354-59.733334 0-33.09899-25.858586-59.733333-57.535354-59.733333z m230.4 0c-31.806061 0-57.664646 26.763636-57.664646 59.733333 0 32.969697 25.858586 59.733333 57.664646 59.733334s57.664646-26.763636 57.664647-59.733334c-0.129293-33.09899-25.858586-59.733333-57.664647-59.733333z m115.2-270.222222H166.335354c-63.612121 0-115.2 53.527273-115.2 119.59596v390.981818c0 65.939394 52.751515 126.836364 117.785858 126.836363h175.579798c30.513131 32.581818 157.220202 149.979798 157.220202 149.979798 5.559596 5.818182 14.739394 5.818182 20.29899 0 0 0 92.832323-91.410101 153.212121-149.979798h179.717172c65.034343 0 117.785859-60.89697 117.785859-126.836363V236.606061c0.129293-65.939394-51.458586-119.466667-115.070708-119.466667z m57.535354 510.577778c0 32.969697-27.668687 67.620202-60.250505 67.620202H678.335354c-21.462626 0-40.727273 21.979798-40.727273 21.979798l-124.121212 114.941414-124.121212-114.941414s-23.660606-21.979798-43.830303-21.979798H168.921212c-32.581818 0-60.250505-34.650505-60.250505-67.620202V236.606061c0-32.969697 25.729293-59.733333 57.664647-59.733334h691.329292c31.806061 0 57.535354 26.763636 57.535354 59.733334v391.111111z m0 0\u0026#34;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt; \u0026lt;/button\u0026gt; {{ end }} \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/li\u0026gt; {{ end }} {{ end }} \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/article\u0026gt; {{- if gt $paginator.TotalPages 1 }} \u0026lt;footer class=\u0026#34;page-footer\u0026#34;\u0026gt; \u0026lt;nav class=\u0026#34;pagination\u0026#34;\u0026gt; {{- if $paginator.HasPrev }} \u0026lt;a class=\u0026#34;prev\u0026#34; href=\u0026#34;{{ $paginator.Prev.URL | absURL }}\u0026#34;\u0026gt; {{ i18n \u0026#34;prev_page\u0026#34; }} {{- if (.Param \u0026#34;ShowPageNums\u0026#34;) }} {{- sub $paginator.PageNumber 1 }}/{{ $paginator.TotalPages }} {{- end }} \u0026lt;/a\u0026gt; {{- end }} {{- if $paginator.HasNext }} \u0026lt;a class=\u0026#34;next\u0026#34; href=\u0026#34;{{ $paginator.Next.URL | absURL }}\u0026#34;\u0026gt; {{- i18n \u0026#34;next_page\u0026#34; }} {{- if (.Param \u0026#34;ShowPageNums\u0026#34;) }} {{- add 1 $paginator.PageNumber }}/{{ $paginator.TotalPages }} {{- end }} \u0026lt;/a\u0026gt; {{- end }} \u0026lt;/nav\u0026gt; \u0026lt;/footer\u0026gt; {{- end }} \u0026lt;script\u0026gt; function showComment(element) { const slug = element.getAttribute(\u0026#39;data-slug\u0026#39;); const commentElement = document.getElementById(slug); if (commentElement) { commentElement.remove(); return; } const comments = document.getElementsByClassName(\u0026#34;pe-moment-comment\u0026#34;); if (comments) { for (let comment of comments) { comment.remove(); } } const momentBody = element.closest(\u0026#39;.pe-moment-body\u0026#39;); let giscusAttributes = { \u0026#34;src\u0026#34;: \u0026#34;https://giscus.app/client.js\u0026#34;, \u0026#34;data-repo\u0026#34;: \u0026#34;{{ .Site.Params.giscus.repo }}\u0026#34;, \u0026#34;data-repo-id\u0026#34;: \u0026#34;{{ .Site.Params.giscus.repoId }}\u0026#34;, \u0026#34;data-category\u0026#34;: \u0026#34;{{ .Site.Params.giscus.category }}\u0026#34;, \u0026#34;data-category-id\u0026#34;: \u0026#34;{{ .Site.Params.giscus.categoryId }}\u0026#34;, \u0026#34;data-mapping\u0026#34;: \u0026#34;{{ .Site.Params.giscus.mapping | default \u0026#34;pathname\u0026#34; }}\u0026#34;, \u0026#34;data-term\u0026#34;: \u0026#34;moments/\u0026#34; + slug, \u0026#34;data-strict\u0026#34;: \u0026#34;{{ .Site.Params.giscus.strict | default \u0026#34;0\u0026#34; }}\u0026#34;, \u0026#34;data-reactions-enabled\u0026#34;: \u0026#34;{{ .Site.Params.giscus.reactionsEnabled | default \u0026#34;1\u0026#34; }}\u0026#34;, \u0026#34;data-emit-metadata\u0026#34;: \u0026#34;{{ .Site.Params.giscus.emitMetadata | default \u0026#34;0\u0026#34; }}\u0026#34;, \u0026#34;data-input-position\u0026#34;: \u0026#34;{{ .Site.Params.giscus.inputPosition | default \u0026#34;bottom\u0026#34; }}\u0026#34;, \u0026#34;data-theme\u0026#34;: getStoredTheme(), \u0026#34;data-lang\u0026#34;: \u0026#34;{{ .Site.Params.giscus.lang | default \u0026#34;en\u0026#34; }}\u0026#34;, \u0026#34;crossorigin\u0026#34;: \u0026#34;anonymous\u0026#34;, \u0026#34;async\u0026#34;: \u0026#34;\u0026#34;, }; const commentDiv = document.createElement(\u0026#39;div\u0026#39;); commentDiv.id = slug; commentDiv.className = \u0026#34;pe-moment-comment\u0026#34;; // 动态创建 giscus script let giscusScript = document.createElement(\u0026#34;script\u0026#34;); Object.entries(giscusAttributes).forEach( ([key, value]) =\u0026gt; giscusScript.setAttribute(key, value)); commentDiv.appendChild(giscusScript); momentBody.appendChild(commentDiv); } const getStoredTheme = () =\u0026gt; localStorage.getItem(\u0026#34;pref-theme\u0026#34;) === \u0026#34;dark\u0026#34; ? \u0026#34;{{ .Site.Params.giscus.darkTheme }}\u0026#34; : \u0026#34;{{ .Site.Params.giscus.lightTheme }}\u0026#34;; const setGiscusTheme = () =\u0026gt; { const sendMessage = (message) =\u0026gt; { const iframe = document.querySelector(\u0026#39;iframe.giscus-frame\u0026#39;); if (iframe) { iframe.contentWindow.postMessage({giscus: message}, \u0026#39;https://giscus.app\u0026#39;); } } sendMessage({setConfig: {theme: getStoredTheme()}}) } document.addEventListener(\u0026#34;DOMContentLoaded\u0026#34;, () =\u0026gt; { // 页面主题变更后，变更 giscus 主题 const themeSwitcher = document.querySelector(\u0026#34;#theme-toggle\u0026#34;); if (themeSwitcher) { themeSwitcher.addEventListener(\u0026#34;click\u0026#34;, setGiscusTheme); } // 本站悬浮按钮，如果你没有则删除以下内容 const themeFloatSwitcher = document.querySelector(\u0026#34;#theme-toggle-float\u0026#34;); if (themeFloatSwitcher) { themeFloatSwitcher.addEventListener(\u0026#34;click\u0026#34;, setGiscusTheme); } }); \u0026lt;/script\u0026gt; {{- end }}{{/* end main */}} moments.css css assets/css/extended/moments.css 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 .list { background: #ffffff; } .page-header { margin: 0 auto 1rem; display: flex; align-items: center; justify-content: center; } .pe-moment { padding: 2rem 0; gap: .8rem; align-items: flex-start; display: flex; border-bottom: 1px; } .pe-moments li { border-bottom: 1px solid #d6d6d6; } .pe-moments img { width: 4.8rem; height: 4.8rem; border-radius: 50%; margin: 0; } .pe-moments ul { list-style: none; margin: 0; padding: 0; } .pe-moment-body { margin-left: 2.4rem; width: 100%; overflow: hidden; } .pe-moment-content { margin-bottom: 1.6rem; } .pe-moment-tag { display: inline-block; padding: 0.25em 0.6em; font-size: 0.875em; line-height: 1; color: #999999; /* 暗色字体 */ background-color: #f0f0f0; /* 浅色背景 */ border-radius: 0.5rem; } .dark .pe-moment-tag { background-color: #333; /* 暗色背景 */ } .pe-moment-bottom { margin-top: 1.2rem; display: flex; align-items: center; } .pe-moment-time { display: inline-block; color: #999999; } .pe-moment-comment-btn svg { width: 2rem; height: 2rem; display: inline-block; vertical-align: 0.15em; fill: #fff; } .pe-moment-comment-btn { margin-left: auto; display: flex; align-items: center; background: rgb(214, 214, 214); border-radius: .5rem; padding: .2rem 1rem; } .dark .pe-moment-comment-btn { background: rgb(65, 66, 68); } .pe-moment-comment-btn:hover { background-color: #e26c56; border-radius: .5rem; } .pe-moment-comment { margin-top: .2rem; } .page-footer { margin-top: 2rem; } ","permalink":"https://tofuwine.github.io/posts/d44c2e7d/","summary":"Hugo 添加瞬间页面","title":"Hugo 添加瞬间页"},{"content":"概要 在文章章末添加对文章的版权声明，如果为转载文章，则在章末显示转载原文信息。\ncopyright 界面 创建 copyright.html 文件：\nhtml layouts/partials/copyright.html 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;div class=\u0026#34;pe-copyright\u0026#34;\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;blockquote\u0026gt; {{ if .Param \u0026#34;reposted\u0026#34; }} \u0026lt;p\u0026gt;本文为转载内容，原文信息如下：\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;原文标题：{{- .Param \u0026#34;repostedTitle\u0026#34; -}}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;原文作者：{{- .Param \u0026#34;repostedAuthor\u0026#34; -}}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;原文链接：\u0026lt;a href=\u0026#34;{{- .Param \u0026#34;repostedLink\u0026#34; -}}\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt;{{- .Param \u0026#34;repostedLink\u0026#34; -}}\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;如有侵权，请\u0026lt;a href=\u0026#34;mailto://{{ .Param \u0026#34;contactEmail\u0026#34; }}\u0026#34;\u0026gt;联系作者\u0026lt;/a\u0026gt;删除。\u0026lt;/p\u0026gt; {{ else }} \u0026lt;p\u0026gt;本文为原创内容，版权归作者所有。如需转载，请在文章中声明本文标题及链接。\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;文章标题：{{ .Title }} —— {{ .Param \u0026#34;author\u0026#34; }}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;文章链接：\u0026lt;a href=\u0026#34;{{ .Permalink }}\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt;{{ .Permalink }}\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;许可协议：\u0026lt;a href=\u0026#34;{{- .Param \u0026#34;licenseLink\u0026#34; -}}\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt;{{- .Param \u0026#34;licenseName\u0026#34; -}}\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt; {{ end }} \u0026lt;/blockquote\u0026gt; \u0026lt;/div\u0026gt; 样式 添加版权信息区域样式。创建 copyright.css 文件：\ncss assets/css/extended/copyright.css 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 .pe-copyright { margin-top: 20px; font-size: 14px; } .pe-copyright hr { border-style: dashed; color: #e26c56; } .pe-copyright blockquote { margin: 10px 0; padding: 0 10px; border-inline-start: 3px solid #e26c56; } .pe-copyright a { box-shadow: 0 1px; box-decoration-break: clone; -webkit-box-decoration-break: clone; } 将版权元素添加到文章章末 在 footer 节点上添加如下内容：\nhtml layouts/_default/single.html 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;article class=\u0026#34;post-single\u0026#34;\u0026gt; {{- if .Content }} \u0026lt;div class=\u0026#34;post-content\u0026#34;\u0026gt; ... \u0026lt;/div\u0026gt; {{- end }} {{ if .Param \u0026#34;enableCopyright\u0026#34; }} {{ partial \u0026#34;copyright.html\u0026#34; . }} {{ end }} \u0026lt;footer class=\u0026#34;post-footer\u0026#34;\u0026gt; ... \u0026lt;/footer\u0026gt; \u0026lt;/article\u0026gt; 启用 copyright 在 hugo 配置文件中添加以下配置：\nyaml 1 2 params: enableCopyright: true 原创文章 原创文章应在文章 frontmatter 中添加以下参数：(以下仅为示例，请根据实际自行修改)\nmarkdown 1 2 3 4 5 --- author: tofuwine licenseLink: \u0026#34;https://creativecommons.org/licenses/by-nc/4.0/\u0026#34; licenseName: \u0026#34;CC BY-NC 4.0\u0026#34; --- 也可直接在 hugo 配置文件中指定默认值：\nyaml 1 2 3 4 params: author: tofuwine licenseLink: \u0026#34;https://creativecommons.org/licenses/by-nc/4.0/\u0026#34; licenseName: \u0026#34;CC BY-NC 4.0\u0026#34; 其中 author 为 Hugo-PaperMod 已有参数。\n转载文章 转载文章应在文章 frontmatter 中添加以下参数：\nmarkdown 1 2 3 4 5 6 7 --- reposted: true repostedTitle: \u0026#34;修改为原文章标题\u0026#34; repostedAuthor: \u0026#34;修改为原文章作者名\u0026#34; repostedLink: \u0026#34;修改为原文章链接\u0026#34; contactEmail: your email --- 其中 contactEmail 参数可在 hugo 配置中指定全局默认值：\nyaml 1 2 params: contactEmail: your email 源码 本站主题已开源，最新源码请参考：PaperMod-PE\n","permalink":"https://tofuwine.github.io/posts/18b224b5/","summary":"在文章章末添加版权声明","title":"PaperMod 添加文章版权声明"},{"content":" 官方文档: Search Page\nPaperMod 使用 Fuse.js Basic 实现搜索功能\nHugo 配置 修改 Hugo 配置，添加 JSON 配置以启用搜索。参考如下：\nyaml config.yml 1 2 3 4 5 outputs: home: - HTML - RSS - JSON # 添加此项 搜索页面 新建文件 search.md，内容参考如下：\nmarkdown content/search.md 1 2 3 4 5 6 7 --- title: \u0026#34;Search\u0026#34; # in any language you want layout: \u0026#34;search\u0026#34; # 对应 search.html，不要修改 description: \u0026#34;Description for Search\u0026#34; summary: \u0026#34;search\u0026#34; placeholder: \u0026#34;placeholder text in search input box\u0026#34; --- 重新启动 hugo server -D，就可以通过 http://localhost:1313/search 进入到搜索页面。\n搜索配置 搜索隐藏 如果不希望某篇文章被搜索，可在文章 frontmatter 中添加：\nmarkdown 1 searchHidden: true Fuse.js Options 参考：https://fusejs.io/api/options.html\n本站搜索配置变更参考：\nyaml config.yml 1 2 3 4 5 6 7 8 9 params: fuseOpts: isCaseSensitive: false shouldSort: true location: 0 distance: 1000 threshold: 0.0 # 完全匹配。PaperMod 默认为 0.4 minMatchCharLength: 0 keys: [\u0026#34;title\u0026#34;, \u0026#34;permalink\u0026#34;, \u0026#34;summary\u0026#34;, \u0026#34;content\u0026#34;] 个性化 个性化内容参考其他博主，请点击相应链接前往，如有疑问可在评论区留言。\n搜索页添加标签 教程参考 PaperMod 搜索页展示标签列表 —— loyayz 搜索页添加分类 教程参考 PaperMod 搜索页展示系列列表 —— loyayz ","permalink":"https://tofuwine.github.io/posts/e62f6a1b/","summary":"Hugo PaperMod 主题添加搜索页以及搜索页样式优化","title":"PaperMod 添加搜索页"},{"content":" IntelliJ IDEA 2024.1\nFile Template 配置路径：File \u0026gt; New \u0026gt; Edit File Templates...，会打开 File and Code Templates 窗口。\nHugo Note 快速生成 Hugo 文章文件及元信息，替代 hugo new 命令。\n在 Files 界面，插入新的模板：\nName: Hugo Note\nExtension: md\nFile name: ${YEAR}-${MONTH}-${DAY}-${NAME}\nvelocity --- title: \u0026#34;${NAME}\u0026#34; date: ${YEAR}-${MONTH}-${DAY}T${HOUR}:${MINUTE}:${SECOND}+08:00 slug: \u0026#34;\u0026#34; description: \u0026#34;\u0026#34; summary: \u0026#34;\u0026#34; tags: - series: - keywords: - ##weight: 1 shotTop: true draft: true --- 以上内容按个人需求更改。\n使用方式：File \u0026gt; New \u0026gt; Hugo Note。\n输入文件名，如 TestNote，则会创建文件 2024-05-10-TestNote.md （日期为创建文件日期）\n配置说明 作者优先使用文件名中的日期作为文章日期，hugo 配置如下：\nyml config.yml 1 2 3 4 frontmatter: date: - :filename - :default 如果你不需要，上述模板中 File name 请留空。\nLive Template 使用 Live Template 配合 ShortCode 可以快速实现期望样式。\n配置路径：File \u0026gt; Settings \u0026gt; Editor \u0026gt; Live Templates，添加 Live Template。\nShortCode 通用，快速生成 Hugo ShortCode 结构。\nAbbreviation: shortcode\nDescription: Hugo ShortCode\nTemplate text:\nhugo {{\u0026lt;$1$\u0026gt;}} $END$ {{\u0026lt;/$1$\u0026gt;}} Applicable contexts Define: Other\nadmonition Abbreviation: admonition\nDescription: Hugo ShortCode admonition\nTemplate text:\nhugo {{\u0026lt;admonition type=$1$ title=$2$ open=true\u0026gt;}} $END$ {{\u0026lt;/admonition\u0026gt;}} Applicable contexts Define: Other\nhl Abbreviation: hl\nDescription: Hugo ShortCode text highlight\nTemplate text:\nhugo {{\u0026lt;hl\u0026gt;}}$END${{\u0026lt;/hl\u0026gt;}} Applicable contexts Define: Other\n最后 你可以基于你的使用场景，将高频内容配置为 File Template 或 Live Template，提高文章编写效率。\n","permalink":"https://tofuwine.github.io/posts/91f489d1/","summary":"IntelliJ IDEA Settings For Hugo","title":"使用 IntelliJ IDEA 编写 Hugo 文章"},{"content":" 温馨提示 本站集成: Mermaid@10.9.0， 如果使用其他版本可能存在图形样式不一致等问题。 本站 Mermaid diagrams 未适配 dark 主题，请切换使用 light 主题预览。 流程图 文档参考：Mermaid - Flowchart\nmermaid 1 2 3 4 5 flowchart LR A[Hard] --\u0026gt;|Text| B(Round) B --\u0026gt; C{Decision} C --\u0026gt;|One| D[Result 1] C --\u0026gt;|Two| E[Result 2] flowchart LR A[Hard] --\u003e|Text| B(Round) B --\u003e C{Decision} C --\u003e|One| D[Result 1] C --\u003e|Two| E[Result 2] 时序图 文档参考：Mermaid - Sequence Diagram\nmermaid 1 2 3 4 5 6 7 8 9 sequenceDiagram Alice-\u0026gt;\u0026gt;John: Hello John, how are you? loop HealthCheck John-\u0026gt;\u0026gt;John: Fight against hypochondria end Note right of John: Rational thoughts! John--\u0026gt;\u0026gt;Alice: Great! John-\u0026gt;\u0026gt;Bob: How about you? Bob--\u0026gt;\u0026gt;John: Jolly good! sequenceDiagram Alice-\u003e\u003eJohn: Hello John, how are you? loop HealthCheck John-\u003e\u003eJohn: Fight against hypochondria end Note right of John: Rational thoughts! John--\u003e\u003eAlice: Great! John-\u003e\u003eBob: How about you? Bob--\u003e\u003eJohn: Jolly good! 甘特图 文档参考：Mermaid - Gantt\nmermaid 1 2 3 4 5 6 7 8 gantt section Section Completed :done, des1, 2014-01-06,2014-01-08 Active :active, des2, 2014-01-07, 3d Parallel 1 : des3, after des1, 1d Parallel 2 : des4, after des1, 1d Parallel 3 : des5, after des3, 1d Parallel 4 : des6, after des4, 1d gantt section Section Completed :done, des1, 2014-01-06,2014-01-08 Active :active, des2, 2014-01-07, 3d Parallel 1 : des3, after des1, 1d Parallel 2 : des4, after des1, 1d Parallel 3 : des5, after des3, 1d Parallel 4 : des6, after des4, 1d 类图 文档参考：Mermaid - Class Diagram\nmermaid 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 classDiagram Class01 \u0026lt;|-- AveryLongClass : Cool \u0026lt;\u0026lt; Interface \u0026gt;\u0026gt; Class01 Class09 --\u0026gt; C2 : Where am I? Class09 --* C3 Class09 --|\u0026gt; Class07 Class07 : equals() Class07 : Object[] elementData Class01 : size() Class01 : int chimp Class01 : int gorilla class Class10 { \u0026lt;\u0026lt; service \u0026gt;\u0026gt; int id size() } classDiagram Class01 \u003c|-- AveryLongClass : Cool \u003c\u003c Interface \u003e\u003e Class01 Class09 --\u003e C2 : Where am I? Class09 --* C3 Class09 --|\u003e Class07 Class07 : equals() Class07 : Object[] elementData Class01 : size() Class01 : int chimp Class01 : int gorilla class Class10 { \u003c\u003c service \u003e\u003e int id size() } ER 图 文档参考：Mermaid - Entity Relationship Diagram\nmermaid 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 erDiagram CAR ||--o{ NAMED-DRIVER : allows CAR { string registrationNumber PK string make string model string[] parts } PERSON ||--o{ NAMED-DRIVER : is PERSON { string driversLicense PK \u0026#34;The license #\u0026#34; string(99) firstName \u0026#34;Only 99 characters are allowed\u0026#34; string lastName string phone UK int age } NAMED-DRIVER { string carRegistrationNumber PK, FK string driverLicence PK, FK } MANUFACTURER only one to zero or more CAR : makes erDiagram CAR ||--o{ NAMED-DRIVER : allows CAR { string registrationNumber PK string make string model string[] parts } PERSON ||--o{ NAMED-DRIVER : is PERSON { string driversLicense PK \"The license #\" string(99) firstName \"Only 99 characters are allowed\" string lastName string phone UK int age } NAMED-DRIVER { string carRegistrationNumber PK, FK string driverLicence PK, FK } MANUFACTURER only one to zero or more CAR : makes 状态图 文档参考：Mermaid - State Diagram\nmermaid 1 2 3 4 5 6 7 stateDiagram-v2 [*] --\u0026gt; Still Still --\u0026gt; [*] Still --\u0026gt; Moving Moving --\u0026gt; Still Moving --\u0026gt; Crash Crash --\u0026gt; [*] stateDiagram-v2 [*] --\u003e Still Still --\u003e [*] Still --\u003e Moving Moving --\u003e Still Moving --\u003e Crash Crash --\u003e [*] 饼图 文档参考：Mermaid - Pie Chart\nmermaid 1 2 3 4 pie \u0026#34;Dogs\u0026#34; : 386 \u0026#34;Cats\u0026#34; : 85 \u0026#34;Rats\u0026#34; : 15 pie \"Dogs\" : 386 \"Cats\" : 85 \"Rats\" : 15 思维导图 文档参考：Mermaid - Mindmaps\nmermaid 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 mindmap root((mindmap)) Origins Long history ::icon(fa fa-book) Popularisation British popular psychology author Tony Buzan Research On effectiveness\u0026lt;br/\u0026gt;and features On Automatic creation Uses Creative techniques Strategic planning Argument mapping Tools Pen and paper Mermaid mindmap root((mindmap)) Origins Long history ::icon(fa fa-book) Popularisation British popular psychology author Tony Buzan Research On effectivenessand features On Automatic creation Uses Creative techniques Strategic planning Argument mapping Tools Pen and paper Mermaid 用户体验旅程图 文档参考：Mermaid - User Journey\nmermaid 1 2 3 4 5 6 7 8 9 journey title My working day section Go to work Make tea: 5: Me Go upstairs: 3: Me Do work: 1: Me, Cat section Go home Go downstairs: 5: Me Sit down: 3: Me journey title My working day section Go to work Make tea: 5: Me Go upstairs: 3: Me Do work: 1: Me, Cat section Go home Go downstairs: 5: Me Sit down: 3: Me C4 图⚠️ ⚠️ Experimental.\n文档参考：Mermaid - C4 Diagram\nmermaid 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 C4Context title System Context diagram for Internet Banking System Person(customerA, \u0026#34;Banking Customer A\u0026#34;, \u0026#34;A customer of the bank, with personal bank accounts.\u0026#34;) Person(customerB, \u0026#34;Banking Customer B\u0026#34;) Person_Ext(customerC, \u0026#34;Banking Customer C\u0026#34;) System(SystemAA, \u0026#34;Internet Banking System\u0026#34;, \u0026#34;Allows customers to view information about their bank accounts, and make payments.\u0026#34;) Person(customerD, \u0026#34;Banking Customer D\u0026#34;, \u0026#34;A customer of the bank, \u0026lt;br/\u0026gt; with personal bank accounts.\u0026#34;) Enterprise_Boundary(b1, \u0026#34;BankBoundary\u0026#34;) { SystemDb_Ext(SystemE, \u0026#34;Mainframe Banking System\u0026#34;, \u0026#34;Stores all of the core banking information about customers, accounts, transactions, etc.\u0026#34;) System_Boundary(b2, \u0026#34;BankBoundary2\u0026#34;) { System(SystemA, \u0026#34;Banking System A\u0026#34;) System(SystemB, \u0026#34;Banking System B\u0026#34;, \u0026#34;A system of the bank, with personal bank accounts.\u0026#34;) } System_Ext(SystemC, \u0026#34;E-mail system\u0026#34;, \u0026#34;The internal Microsoft Exchange e-mail system.\u0026#34;) SystemDb(SystemD, \u0026#34;Banking System D Database\u0026#34;, \u0026#34;A system of the bank, with personal bank accounts.\u0026#34;) Boundary(b3, \u0026#34;BankBoundary3\u0026#34;, \u0026#34;boundary\u0026#34;) { SystemQueue(SystemF, \u0026#34;Banking System F Queue\u0026#34;, \u0026#34;A system of the bank, with personal bank accounts.\u0026#34;) SystemQueue_Ext(SystemG, \u0026#34;Banking System G Queue\u0026#34;, \u0026#34;A system of the bank, with personal bank accounts.\u0026#34;) } } BiRel(customerA, SystemAA, \u0026#34;Uses\u0026#34;) BiRel(SystemAA, SystemE, \u0026#34;Uses\u0026#34;) Rel(SystemAA, SystemC, \u0026#34;Sends e-mails\u0026#34;, \u0026#34;SMTP\u0026#34;) Rel(SystemC, customerA, \u0026#34;Sends e-mails to\u0026#34;) C4Context title System Context diagram for Internet Banking System Person(customerA, \"Banking Customer A\", \"A customer of the bank, with personal bank accounts.\") Person(customerB, \"Banking Customer B\") Person_Ext(customerC, \"Banking Customer C\") System(SystemAA, \"Internet Banking System\", \"Allows customers to view information about their bank accounts, and make payments.\") Person(customerD, \"Banking Customer D\", \"A customer of the bank, with personal bank accounts.\") Enterprise_Boundary(b1, \"BankBoundary\") { SystemDb_Ext(SystemE, \"Mainframe Banking System\", \"Stores all of the core banking information about customers, accounts, transactions, etc.\") System_Boundary(b2, \"BankBoundary2\") { System(SystemA, \"Banking System A\") System(SystemB, \"Banking System B\", \"A system of the bank, with personal bank accounts.\") } System_Ext(SystemC, \"E-mail system\", \"The internal Microsoft Exchange e-mail system.\") SystemDb(SystemD, \"Banking System D Database\", \"A system of the bank, with personal bank accounts.\") Boundary(b3, \"BankBoundary3\", \"boundary\") { SystemQueue(SystemF, \"Banking System F Queue\", \"A system of the bank, with personal bank accounts.\") SystemQueue_Ext(SystemG, \"Banking System G Queue\", \"A system of the bank, with personal bank accounts.\") } } BiRel(customerA, SystemAA, \"Uses\") BiRel(SystemAA, SystemE, \"Uses\") Rel(SystemAA, SystemC, \"Sends e-mails\", \"SMTP\") Rel(SystemC, customerA, \"Sends e-mails to\") 象限图 文档参考：Mermaid - Quadrant Chart\nmermaid 1 2 3 4 5 6 7 8 9 10 11 12 13 14 quadrantChart title Reach and engagement of campaigns x-axis Low Reach --\u0026gt; High Reach y-axis Low Engagement --\u0026gt; High Engagement quadrant-1 We should expand quadrant-2 Need to promote quadrant-3 Re-evaluate quadrant-4 May be improved Campaign A: [0.3, 0.6] Campaign B: [0.45, 0.23] Campaign C: [0.57, 0.69] Campaign D: [0.78, 0.34] Campaign E: [0.40, 0.34] Campaign F: [0.35, 0.78] quadrantChart title Reach and engagement of campaigns x-axis Low Reach --\u003e High Reach y-axis Low Engagement --\u003e High Engagement quadrant-1 We should expand quadrant-2 Need to promote quadrant-3 Re-evaluate quadrant-4 May be improved Campaign A: [0.3, 0.6] Campaign B: [0.45, 0.23] Campaign C: [0.57, 0.69] Campaign D: [0.78, 0.34] Campaign E: [0.40, 0.34] Campaign F: [0.35, 0.78] 需求图 文档参考：Mermaid - Requirement Diagram\nmermaid 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 requirementDiagram requirement test_req { id: 1 text: the test text. risk: high verifymethod: test } functionalRequirement test_req2 { id: 1.1 text: the second test text. risk: low verifymethod: inspection } performanceRequirement test_req3 { id: 1.2 text: the third test text. risk: medium verifymethod: demonstration } interfaceRequirement test_req4 { id: 1.2.1 text: the fourth test text. risk: medium verifymethod: analysis } physicalRequirement test_req5 { id: 1.2.2 text: the fifth test text. risk: medium verifymethod: analysis } designConstraint test_req6 { id: 1.2.3 text: the sixth test text. risk: medium verifymethod: analysis } element test_entity { type: simulation } element test_entity2 { type: word doc docRef: reqs/test_entity } element test_entity3 { type: \u0026#34;test suite\u0026#34; docRef: github.com/all_the_tests } test_entity - satisfies -\u0026gt; test_req2 test_req - traces -\u0026gt; test_req2 test_req - contains -\u0026gt; test_req3 test_req3 - contains -\u0026gt; test_req4 test_req4 - derives -\u0026gt; test_req5 test_req5 - refines -\u0026gt; test_req6 test_entity3 - verifies -\u0026gt; test_req5 test_req \u0026lt;- copies - test_entity2 requirementDiagram requirement test_req { id: 1 text: the test text. risk: high verifymethod: test } functionalRequirement test_req2 { id: 1.1 text: the second test text. risk: low verifymethod: inspection } performanceRequirement test_req3 { id: 1.2 text: the third test text. risk: medium verifymethod: demonstration } interfaceRequirement test_req4 { id: 1.2.1 text: the fourth test text. risk: medium verifymethod: analysis } physicalRequirement test_req5 { id: 1.2.2 text: the fifth test text. risk: medium verifymethod: analysis } designConstraint test_req6 { id: 1.2.3 text: the sixth test text. risk: medium verifymethod: analysis } element test_entity { type: simulation } element test_entity2 { type: word doc docRef: reqs/test_entity } element test_entity3 { type: \"test suite\" docRef: github.com/all_the_tests } test_entity - satisfies -\u003e test_req2 test_req - traces -\u003e test_req2 test_req - contains -\u003e test_req3 test_req3 - contains -\u003e test_req4 test_req4 - derives -\u003e test_req5 test_req5 - refines -\u003e test_req6 test_entity3 - verifies -\u003e test_req5 test_req \u003c- copies - test_entity2 Gitgraph 图 文档参考：Mermaid - Gitgraph Diagrams\nmermaid 1 2 3 4 5 6 7 8 9 10 11 12 13 14 --- title: Example Git diagram --- gitGraph commit commit branch develop checkout develop commit commit checkout main merge develop commit commit --- title: Example Git diagram --- gitGraph commit commit branch develop checkout develop commit commit checkout main merge develop commit commit 时间线图 文档参考：Mermaid - Timeline\nmermaid 1 2 3 4 5 6 7 timeline title History of Social Media Platform 2002 : LinkedIn 2004 : Facebook : Google 2005 : Youtube 2006 : Twitter timeline title History of Social Media Platform 2002 : LinkedIn 2004 : Facebook : Google 2005 : Youtube 2006 : Twitter XY 图表 文档参考：Mermaid - XYChart\nmermaid 1 2 3 4 5 6 xychart-beta title \u0026#34;Sales Revenue\u0026#34; x-axis [jan, feb, mar, apr, may, jun, jul, aug, sep, oct, nov, dec] y-axis \u0026#34;Revenue (in $)\u0026#34; 4000 --\u0026gt; 11000 bar [5000, 6000, 7500, 8200, 9500, 10500, 11000, 10200, 9200, 8500, 7000, 6000] line [5000, 6000, 7500, 8200, 9500, 10500, 11000, 10200, 9200, 8500, 7000, 6000] xychart-beta title \"Sales Revenue\" x-axis [jan, feb, mar, apr, may, jun, jul, aug, sep, oct, nov, dec] y-axis \"Revenue (in $)\" 4000 --\u003e 11000 bar [5000, 6000, 7500, 8200, 9500, 10500, 11000, 10200, 9200, 8500, 7000, 6000] line [5000, 6000, 7500, 8200, 9500, 10500, 11000, 10200, 9200, 8500, 7000, 6000] 框图文档 文档参考：Mermaid - Block Diagram\nmermaid 1 2 3 4 5 6 7 8 9 10 11 12 13 14 block-beta columns 1 db((\u0026#34;DB\u0026#34;)) blockArrowId6\u0026lt;[\u0026#34;\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;\u0026#34;]\u0026gt;(down) block:ID A B[\u0026#34;A wide one in the middle\u0026#34;] C end space D ID --\u0026gt; D C --\u0026gt; D style B fill:#969,stroke:#333,stroke-width:4px block-beta columns 1 db((\"DB\")) blockArrowId6\u003c[\"\u0026nbsp;\u0026nbsp;\u0026nbsp;\"]\u003e(down) block:ID A B[\"A wide one in the middle\"] C end space D ID --\u003e D C --\u003e D style B fill:#969,stroke:#333,stroke-width:4px 桑基图 文档参考：Mermaid - Sankey\nmermaid 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 --- config: sankey: showValues: false --- sankey-beta Agricultural \u0026#39;waste\u0026#39;,Bio-conversion,124.729 Bio-conversion,Liquid,0.597 Bio-conversion,Losses,26.862 Bio-conversion,Solid,280.322 Bio-conversion,Gas,81.144 Biofuel imports,Liquid,35 Biomass imports,Solid,35 Coal imports,Coal,11.606 Coal reserves,Coal,63.965 Coal,Solid,75.571 District heating,Industry,10.639 District heating,Heating and cooling - commercial,22.505 District heating,Heating and cooling - homes,46.184 Electricity grid,Over generation / exports,104.453 Electricity grid,Heating and cooling - homes,113.726 Electricity grid,H2 conversion,27.14 Electricity grid,Industry,342.165 Electricity grid,Road transport,37.797 Electricity grid,Agriculture,4.412 Electricity grid,Heating and cooling - commercial,40.858 Electricity grid,Losses,56.691 Electricity grid,Rail transport,7.863 Electricity grid,Lighting \u0026amp; appliances - commercial,90.008 Electricity grid,Lighting \u0026amp; appliances - homes,93.494 Gas imports,Ngas,40.719 Gas reserves,Ngas,82.233 Gas,Heating and cooling - commercial,0.129 Gas,Losses,1.401 Gas,Thermal generation,151.891 Gas,Agriculture,2.096 Gas,Industry,48.58 Geothermal,Electricity grid,7.013 H2 conversion,H2,20.897 H2 conversion,Losses,6.242 H2,Road transport,20.897 Hydro,Electricity grid,6.995 Liquid,Industry,121.066 Liquid,International shipping,128.69 Liquid,Road transport,135.835 Liquid,Domestic aviation,14.458 Liquid,International aviation,206.267 Liquid,Agriculture,3.64 Liquid,National navigation,33.218 Liquid,Rail transport,4.413 Marine algae,Bio-conversion,4.375 Ngas,Gas,122.952 Nuclear,Thermal generation,839.978 Oil imports,Oil,504.287 Oil reserves,Oil,107.703 Oil,Liquid,611.99 Other waste,Solid,56.587 Other waste,Bio-conversion,77.81 Pumped heat,Heating and cooling - homes,193.026 Pumped heat,Heating and cooling - commercial,70.672 Solar PV,Electricity grid,59.901 Solar Thermal,Heating and cooling - homes,19.263 Solar,Solar Thermal,19.263 Solar,Solar PV,59.901 Solid,Agriculture,0.882 Solid,Thermal generation,400.12 Solid,Industry,46.477 Thermal generation,Electricity grid,525.531 Thermal generation,Losses,787.129 Thermal generation,District heating,79.329 Tidal,Electricity grid,9.452 UK land based bioenergy,Bio-conversion,182.01 Wave,Electricity grid,19.013 Wind,Electricity grid,289.366 --- config: sankey: showValues: false --- sankey-beta Agricultural 'waste',Bio-conversion,124.729 Bio-conversion,Liquid,0.597 Bio-conversion,Losses,26.862 Bio-conversion,Solid,280.322 Bio-conversion,Gas,81.144 Biofuel imports,Liquid,35 Biomass imports,Solid,35 Coal imports,Coal,11.606 Coal reserves,Coal,63.965 Coal,Solid,75.571 District heating,Industry,10.639 District heating,Heating and cooling - commercial,22.505 District heating,Heating and cooling - homes,46.184 Electricity grid,Over generation / exports,104.453 Electricity grid,Heating and cooling - homes,113.726 Electricity grid,H2 conversion,27.14 Electricity grid,Industry,342.165 Electricity grid,Road transport,37.797 Electricity grid,Agriculture,4.412 Electricity grid,Heating and cooling - commercial,40.858 Electricity grid,Losses,56.691 Electricity grid,Rail transport,7.863 Electricity grid,Lighting \u0026 appliances - commercial,90.008 Electricity grid,Lighting \u0026 appliances - homes,93.494 Gas imports,Ngas,40.719 Gas reserves,Ngas,82.233 Gas,Heating and cooling - commercial,0.129 Gas,Losses,1.401 Gas,Thermal generation,151.891 Gas,Agriculture,2.096 Gas,Industry,48.58 Geothermal,Electricity grid,7.013 H2 conversion,H2,20.897 H2 conversion,Losses,6.242 H2,Road transport,20.897 Hydro,Electricity grid,6.995 Liquid,Industry,121.066 Liquid,International shipping,128.69 Liquid,Road transport,135.835 Liquid,Domestic aviation,14.458 Liquid,International aviation,206.267 Liquid,Agriculture,3.64 Liquid,National navigation,33.218 Liquid,Rail transport,4.413 Marine algae,Bio-conversion,4.375 Ngas,Gas,122.952 Nuclear,Thermal generation,839.978 Oil imports,Oil,504.287 Oil reserves,Oil,107.703 Oil,Liquid,611.99 Other waste,Solid,56.587 Other waste,Bio-conversion,77.81 Pumped heat,Heating and cooling - homes,193.026 Pumped heat,Heating and cooling - commercial,70.672 Solar PV,Electricity grid,59.901 Solar Thermal,Heating and cooling - homes,19.263 Solar,Solar Thermal,19.263 Solar,Solar PV,59.901 Solid,Agriculture,0.882 Solid,Thermal generation,400.12 Solid,Industry,46.477 Thermal generation,Electricity grid,525.531 Thermal generation,Losses,787.129 Thermal generation,District heating,79.329 Tidal,Electricity grid,9.452 UK land based bioenergy,Bio-conversion,182.01 Wave,Electricity grid,19.013 Wind,Electricity grid,289.366 ","permalink":"https://tofuwine.github.io/posts/cb59edb8/","summary":"Mermaid 作图以及本站显示效果示例","title":"Markdown 作图 —— Mermaid diagrams"},{"content":"Gisucs 官网：giscus.app\n利用 GitHub Discussions 实现的评论系统，让访客借助 GitHub 在你的网站上留下评论和反应吧！本项目深受 utterances 的启发。\n开源。🌏 无跟踪，无广告，永久免费。📡 🚫 无需数据库。所有数据均储存在 GitHub Discussions 中。:octocat: 支持自定义主题！🌗 支持多种语言。🌐 高可配置性。🔧 自动从 GitHub 拉取新评论与编辑。🔃 可自建服务！🤳 教程参考 本站集成方式参考以下博文，为尊重原创作者，本文不再赘述，请移步到其站点查看：\n教程参考 Hugo 博客引入 Giscus 评论系统 —— 意琦行 你也可以参考官方文档。\n主题切换 按上述教程集成了 Giscus 评论系统，但评论区主题不能动态变更。\n源码参考 issues#1200 —— giscus 如需评论区随界面主题变更，请按如下方式修改配置：\nHugo 配置 将 giscus 属性字段提取到 Hugo 配置中：\nyaml config.yml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 params: giscus: repo: \u0026#34;{{ YOUR REPOSITORY }}\u0026#34; repoId: \u0026#34;{{ YOUR REPO ID }}\u0026#34; category: \u0026#34;Announcements\u0026#34; categoryId: \u0026#34;{{ YOUR CATEGORY ID }}\u0026#34; mapping: \u0026#34;pathname\u0026#34; strict: \u0026#34;0\u0026#34; reactionsEnabled: \u0026#34;1\u0026#34; emitMetadata: \u0026#34;0\u0026#34; inputPosition: \u0026#34;top\u0026#34; lightTheme: \u0026#34;light\u0026#34; darkTheme: \u0026#34;dark\u0026#34; lang: \u0026#34;zh-CN\u0026#34; 评论界面 变更 comments.html 内容如下:\nhtml layouts/partials/comments.html 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 \u0026lt;div id=\u0026#34;tw-comment\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; const getStoredTheme = () =\u0026gt; localStorage.getItem(\u0026#34;pref-theme\u0026#34;) === \u0026#34;dark\u0026#34; ? \u0026#34;{{ .Site.Params.giscus.darkTheme }}\u0026#34; : \u0026#34;{{ .Site.Params.giscus.lightTheme }}\u0026#34;; const setGiscusTheme = () =\u0026gt; { const sendMessage = (message) =\u0026gt; { const iframe = document.querySelector(\u0026#39;iframe.giscus-frame\u0026#39;); if (iframe) { iframe.contentWindow.postMessage({giscus: message}, \u0026#39;https://giscus.app\u0026#39;); } } sendMessage({setConfig: {theme: getStoredTheme()}}) } document.addEventListener(\u0026#34;DOMContentLoaded\u0026#34;, () =\u0026gt; { const giscusAttributes = { \u0026#34;src\u0026#34;: \u0026#34;https://giscus.app/client.js\u0026#34;, \u0026#34;data-repo\u0026#34;: \u0026#34;{{ .Site.Params.giscus.repo }}\u0026#34;, \u0026#34;data-repo-id\u0026#34;: \u0026#34;{{ .Site.Params.giscus.repoId }}\u0026#34;, \u0026#34;data-category\u0026#34;: \u0026#34;{{ .Site.Params.giscus.category }}\u0026#34;, \u0026#34;data-category-id\u0026#34;: \u0026#34;{{ .Site.Params.giscus.categoryId }}\u0026#34;, \u0026#34;data-mapping\u0026#34;: \u0026#34;{{ .Site.Params.giscus.mapping | default \u0026#34;pathname\u0026#34; }}\u0026#34;, \u0026#34;data-strict\u0026#34;: \u0026#34;{{ .Site.Params.giscus.strict | default \u0026#34;0\u0026#34; }}\u0026#34;, \u0026#34;data-reactions-enabled\u0026#34;: \u0026#34;{{ .Site.Params.giscus.reactionsEnabled | default \u0026#34;1\u0026#34; }}\u0026#34;, \u0026#34;data-emit-metadata\u0026#34;: \u0026#34;{{ .Site.Params.giscus.emitMetadata | default \u0026#34;0\u0026#34; }}\u0026#34;, \u0026#34;data-input-position\u0026#34;: \u0026#34;{{ .Site.Params.giscus.inputPosition | default \u0026#34;bottom\u0026#34; }}\u0026#34;, \u0026#34;data-theme\u0026#34;: getStoredTheme(), \u0026#34;data-lang\u0026#34;: \u0026#34;{{ .Site.Params.giscus.lang | default \u0026#34;en\u0026#34; }}\u0026#34;, \u0026#34;data-loading\u0026#34;: \u0026#34;lazy\u0026#34;, \u0026#34;crossorigin\u0026#34;: \u0026#34;anonymous\u0026#34;, \u0026#34;async\u0026#34;: \u0026#34;\u0026#34;, }; // 动态创建 giscus script const giscusScript = document.createElement(\u0026#34;script\u0026#34;); Object.entries(giscusAttributes).forEach( ([key, value]) =\u0026gt; giscusScript.setAttribute(key, value)); document.querySelector(\u0026#34;#tw-comment\u0026#34;).appendChild(giscusScript); // 页面主题变更后，变更 giscus 主题 const themeSwitcher = document.querySelector(\u0026#34;#theme-toggle\u0026#34;); if (themeSwitcher) { themeSwitcher.addEventListener(\u0026#34;click\u0026#34;, setGiscusTheme); } const themeFloatSwitcher = document.querySelector(\u0026#34;#theme-toggle-float\u0026#34;); if (themeFloatSwitcher) { themeFloatSwitcher.addEventListener(\u0026#34;click\u0026#34;, setGiscusTheme); } }); \u0026lt;/script\u0026gt; 评论标题 \u0026amp; 子标题 增加评论区标题 \u0026amp; 子标题，引导用户进行评论。\n修改评论界面，在最上面添加如下内容：\nhtml layouts/partials/comments.html 1 2 3 4 \u0026lt;div class=\u0026#34;comments-title\u0026#34; id=\u0026#34;tw-comment-title\u0026#34;\u0026gt; \u0026lt;p class=\u0026#34;x-comments-title\u0026#34;\u0026gt;{{- .Param \u0026#34;discussionTitle\u0026#34; }}\u0026lt;/p\u0026gt; \u0026lt;p style=\u0026#34;font-size: 1rem\u0026#34;\u0026gt;{{- .Param \u0026#34;discussionSubtitle\u0026#34; }} \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; 添加样式：\ncss assets/css/extended/comment.css 1 2 3 4 5 6 7 8 9 10 11 12 13 14 /* giscus 评论组件 */ .comments-title { margin-top: 2rem; margin-bottom: 2rem; display: block; text-align: center; } .x-comments-title { display: block; font-size: 1.25em; font-weight: 700; padding: 1.5rem 0 .5rem; } 使用方式 你可以在 Hugo 配置中配置全局值： yaml 1 2 3 4 params: # 评论区 discussionTitle: 欢迎来到评论区 discussionSubtitle: 感谢您的耐心阅读！来选个表情，或者留个评论吧！ 也可在文章 frontmatter 中添加：(以本站 友链 为例) markdown 1 2 discussionTitle: 👇 申请友链 👇 discussionSubtitle: 在下方评论区留下你的链接吧! ","permalink":"https://tofuwine.github.io/posts/610b75f5/","summary":"Hugo \u0026amp; PaperMod 集成 Giscus 评论系统","title":"PaperMod 集成 Giscus 评论"},{"content":" 最新消息 2024-05-16\n本站主题已开源：PaperMod-PE。本文已失效。\n前言 本站使用 Hugo + PaperMod 主题， 并对样式进行了个性化修改，你可以在文中浏览到站点绝大部分的样式。\n文本 样式 效果 普通文本 This is plaintext 加粗 This is bold text 斜体 This text is italicized 删除 This was mistaken text 加粗嵌套斜体 This text is extremely important 加粗+斜体 All this text is important 下标 This is a subscript text 上标 This is a superscript text 部分样式通过 HTML 标签实现, 需开启配置:\nyaml config.yml 1 2 3 4 markup: goldmark: renderer: unsafe: true 代码 行内代码 Tofuwine\u0026rsquo;s Blog Powered by Hugo \u0026amp; PaperMod.\n代码块 主要配色参考:\nlight-theme: monokailight dark-theme: github-dark 标准样式 java 1 2 3 4 5 6 public class HelloHugo { public static void main(String[] args) { System.out.println(\u0026#34;Hello Hugo!\u0026#34;); } } 自定义标题 java io.github.tofuwine.main.HelloHugo.java 1 2 3 4 5 6 public class HelloHugo { public static void main(String[] args) { System.out.println(\u0026#34;Hello Hugo!\u0026#34;); } } 自定义起始行数 \u0026amp; 高亮指定行 go 100 101 102 103 104 105 106 107 108 109 func GetTitleFunc(style string) func(s string) string { switch strings.ToLower(style) { case \u0026#34;go\u0026#34;: return strings.Title case \u0026#34;chicago\u0026#34;: return transform.NewTitleConverter(transform.ChicagoStyle) default: return transform.NewTitleConverter(transform.APStyle) } } 折叠代码块 Since: 2024-05-09\njava HelloHugo.java 1 2 3 4 5 6 public class HelloHugo { public static void main(String[] args) { System.out.println(\u0026#34;Hello Hugo!\u0026#34;); } } 更多 ✅ 自定义语言类型显示名称 (Since 2024-05-07) ✅ 语法高亮使用自定义语言类型 (Since 2024-05-09) 引用 这是一段引用内容。\nShortCode admonition 移植自 Hugo 的 Loveit 主题。\n教程参考 如何移植HUGO Loveit主題的admonition shortcodes —— 懶懶 目前支持的 admonition 类型:\nnote admonition - note abstract admonition - abstract info admonition - info tip admonition - tip success admonition - success question admonition - question warning admonition - warning failure admonition - failure danger admonition - danger bug admonition - bug example admonition - example quote admonition - quote hl 文本高亮。效果如下：\nThis is a highlight text. 目录 章节默认以 H2 起始，H5 结束。\n主要改动:\n移动至屏幕左侧显示 教程参考 Hugo博客目录放在侧边 | PaperMod主题 —— Sulv 目录自动折叠/展开 你可以滚动界面观察左侧目录体验效果。\n悬浮按钮 前往评论区 (Go to comment) 前往评论区的悬浮按钮\n你可以在点击右侧对应的悬浮按钮进行体验。\n切换主题 (Theme toggle) 切换主题按钮。主题自带切换按钮在页面顶部，在阅读文章时切换很不方便 (即使有快捷键，也对访客不是很友好)。\n重新实现了一个悬浮按钮实现主题切换，同时保留 PaperMod 的切换按钮 (已禁用)。\n可以点击右侧对应的悬浮按钮进行体验。\n回到顶部 (Go to top) 回到顶部悬浮按钮, 显示进度。\n源码参考 博主网站: 有意栽花花满枝(https://blog.hjroyal.top/)\n开源代码: https://github.com/hjroyal/hugo-papermod-flowers 页面跳动效果 扩展实现了当用户滚动到页面最上方/最下方后，页面轻微的跳动提示用户已到顶/底。\n评论 📢 攻略已发布: PaperMod 集成 Giscus 评论\n赞赏 提供赞赏按钮，点击按钮显示微信 \u0026amp; 支付宝收款码，读者可扫码打赏作者。\n源码参考 博主网站: 有意栽花花满枝(https://blog.hjroyal.top/)\n开源代码: https://github.com/hjroyal/hugo-papermod-flowers 扩展实现了：\n按钮的动态效果 赞赏描述 (支持国际化) 赞赏码/收款码弹出显示 (支持主题切换) 文章自定义赞赏按钮显示内容 rewardButton 文章自定义赞赏描述 rewardSubtitle 赞赏描述开关控制 hideRewardSubtitle 搜索 📢 攻略已发布: PaperMod 添加搜索页\n归档/时间轴 教程参考 Hugo博客时间轴中文化 —— Sulv 置顶、转载、草稿等标识 在文章页、文章列表页、归档页等界面显示置顶、转载、草稿等标识。\n置顶：文章页、文章列表页 转载：文章页、文章列表页、归档页 草稿：归档页（文章页、文章列表页主题自带图标显示） 灯箱 教程参考 Hugo 使用 Fancybox 实现图片灯箱/放大功能 —— atpx 使用 Fancybox 实现图片灯箱效果。\nMermaid diagrams Since: 2024-05-07\n教程参考 Mermaid diagrams —— Hugo 按官方文档添加 code block render hook。\n效果参考：Markdown 作图 —— Mermaid diagrams\n已知缺陷：\n未适配 Dark 主题。请切换使用 Light 主题预览。 KaTex Since: 2024-05-09\n教程参考 Mathematics in Markdown —— Hugo Doc 添加对 LaTex 公式/内联公式的支持。以下是效果展示：\n块显示 $$ \\begin{aligned} KL(\\hat{y} || y) \u0026= \\sum_{c=1}^{M}\\hat{y}_c \\log{\\frac{\\hat{y}_c}{y_c}} \\\\ JS(\\hat{y} || y) \u0026= \\frac{1}{2}(KL(y||\\frac{y+\\hat{y}}{2}) + KL(\\hat{y}||\\frac{y+\\hat{y}}{2})) \\end{aligned} $$ 内联显示 两数和的平方，等于它们的平方和加上它们的积的2倍。 即：\\$(a+b)^2=a^2+2ab+b^2\\$\n自定义页面 友链 教程参考 Hugo 博客添加友链 —— Sulv 关于 Since: 2024-05-06\n显示 关于 界面。\n预览：点击此处\n最新 Since: 2024-05-11\n显示最新文章列表\n预览：点击此处\n文章版权声明 在文章末尾添加版权声明。\n结尾 除了上述内容，作者还对站点很多细节进行了优化。但由于站点搭建初期改动地方较多且频繁，很多内容并没有详尽的记载，在此就不过多赘述了。\n","permalink":"https://tofuwine.github.io/posts/3c96c5d2/","summary":"快速预览本站各种样式 (Hugo \u0026amp; PaperMod 主题)","title":"PaperMod 主题个性化"},{"content":"开发环境 JetBrains IDEA 2024.1 Java 17 Spring Boot 3.2.5 Maven 3.9.6 Gradle 8.7 我们以本地 hutool 5.8.26 为例。\nMaven 新建 Spring Boot 工程，使用 Maven 构建。\n存放 Jar 新建 libs 目录，将下载好的 hutool-all-5.8.26.jar 放在其中：\n引入依赖 修改 pom.xml 文件，添加 hutool 依赖：\nxml 1 2 3 4 5 6 7 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;cn.hutool\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;hutool-all\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.8.26\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;system\u0026lt;/scope\u0026gt; \u0026lt;systemPath\u0026gt;${project.basedir}/libs/hutool-all-5.8.26.jar\u0026lt;/systemPath\u0026gt; \u0026lt;/dependency\u0026gt; 测试 编写测试方法：\njava 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package cn.tofuwine.spring.boot3.maven.example; import cn.hutool.core.util.StrUtil; import org.springframework.boot.ApplicationArguments; import org.springframework.boot.ApplicationRunner; import org.springframework.stereotype.Component; @Component public class Test implements ApplicationRunner { @Override public void run(ApplicationArguments args) throws Exception { String helloWorld = StrUtil.builder() .append(\u0026#34;hello\u0026#34;) .append(\u0026#34; world\u0026#34;) .toString(); System.out.println(helloWorld); } } 启动工程，控制台打印 hello world。\n打包 修改 pom.xml，添加如下：\nxml 1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;!-- 添加如下配置，包含本地 Jar --\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;includeSystemScope\u0026gt;true\u0026lt;/includeSystemScope\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; 项目打包后，以压缩文件形式打开生成的 jar，查看是否包含 hutool-all：（目录：BOOT-INF/lib）\n运行 Jar，查看是否能打印出 hello world：\nbash 1 java -jar .\\spring-boot-3-maven-example-0.0.1-SNAPSHOT.jar 验证结束，无问题。\nGradle 新建 Spring Boot 工程，使用 Gradle - Kotlin DSL 构建。\n存放 Jar 新建 libs 目录，将下载好的 hutool-all-5.8.26.jar 放在其中：\n引入依赖 方式一 单独引入一个 Jar 文件（Jar：hutool-all-5.8.26.jar）：\nkotlin 1 2 3 4 5 dependencies { // ... other dependencies implementation(files(\u0026#34;libs/hutool-all-5.8.26.jar\u0026#34;)) // ... other dependencies } 方式二 引入一个文件夹中的所有 Jar（文件夹： libs）：\nkotlin 1 2 3 4 5 dependencies { // ... other dependencies implementation(fileTree(mapOf(\u0026#34;dir\u0026#34; to \u0026#34;libs\u0026#34;, \u0026#34;include\u0026#34; to listOf(\u0026#34;*.jar\u0026#34;)))) // ... other dependencies } 测试 编写测试方法：\njava 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package cn.tofuwine.spring.boot3.gradle.kotlin; import cn.hutool.core.util.StrUtil; import org.springframework.boot.ApplicationArguments; import org.springframework.boot.ApplicationRunner; import org.springframework.stereotype.Component; @Component public class Test implements ApplicationRunner { @Override public void run(ApplicationArguments args) throws Exception { String helloWorld = StrUtil.builder() .append(\u0026#34;hello\u0026#34;) .append(\u0026#34; world\u0026#34;) .toString(); System.out.println(helloWorld); } } 启动工程，控制台打印 hello world。\n打包 使用 bootJar 进行打包：\n生成的 Jar 目录为 build/libs。以压缩文件形式打开生成的 jar，查看是否包含 hutool-all：（目录：BOOT-INF/lib）\n运行 Jar，查看是否能打印出 hello world：\nbash 1 java -jar .\\spring-boot-3-gradle-kotlin-0.0.1-SNAPSHOT.jar 验证结束，无问题。\n","permalink":"https://tofuwine.github.io/posts/c9102d8e/","summary":"Spring Boot 工程引入并打包本地 Jar","title":"Spring Boot 引入本地 Jar 包"},{"content":" Gradle 目前支持两种 DSL（Domain Specific Language）：Groovy DSL 和 Kotlin DSL\n更改 Gradle 本地仓库 新建环境变量 GRADLE_USER_HOME，并指定路径，即可修改 Gradle 本地仓库地址。\n指定 Java 版本 Kotlin DSL\nkotlin 1 java.sourceCompatibility = JavaVersion.VERSION_17 Javadoc 编码问题 问题详情：\ntext 1 error: unmappable character (0x89) for encoding GBK 解决方式：\nKotlin DSL\n在 build.gradle.kts 文件中添加如下内容：\nkotlin 1 2 3 4 5 6 7 8 tasks { compileJava { options.encoding = \u0026#34;UTF-8\u0026#34; } compileTestJava { options.encoding = \u0026#34;UTF-8\u0026#34; } } 无法识别 lombok 问题 Kotlin DSL\nkotlin 1 2 3 4 // lombok 使用如下依赖 (版本号可替换) // https://mvnrepository.com/artifact/org.projectlombok/lombok compileOnly(\u0026#34;org.projectlombok:lombok:1.18.26\u0026#34;) annotationProcessor(\u0026#34;org.projectlombok:lombok:1.18.26\u0026#34;) distributionUrl 国内镜像 gradle/wrapper/gradle-wrapper.properties 文件 distributionUrl 默认如下（以 Gradle 8.7 为例）：\nproperties 1 distributionUrl=https\\://services.gradle.org/distributions/gradle-8.7-bin.zip 因为众所周知的原因，在国内使用该地址下载可能受阻。我们可以改用国内镜像地址（以腾讯镜像为例）：\nproperties 1 distributionUrl=https\\://mirrors.cloud.tencent.com/gradle/gradle-8.7-bin.zip 或者也可以指向本地文件：\nproperties 1 distributionUrl=file:///D:/Downloads/gradle-8.7-bin.zip 建议使用国内镜像。\n","permalink":"https://tofuwine.github.io/posts/879d9ef5/","summary":"Gradle 常见问题汇总","title":"Gradle FAQs"},{"content":"数据库中如何执行 SQL 语句？\n下图显示了这一过程。请注意，不同数据库的架构各不相同，下图展示了一些常见的设计。\n第 1 步 通过传输层协议（如 TCP）向数据库发送 SQL 语句。\n第 2 步 将 SQL 语句发送到命令解析器，在那里进行语法和语义分析，然后生成查询树。\n第 3 步 将查询树发送给优化器。优化器会创建一个执行计划。\n第 4 步 将执行计划发送给执行器。执行器从执行计划中获取数据。执行器与存储引擎交互以访问数据。\n第 5 步 访问方法提供执行所需的数据获取逻辑，从存储引擎获取数据。\n第 6 步 访问方法决定 SQL 语句是否只读。如果查询是只读的（SELECT 语句），则将其传递给缓冲区管理器进行进一步处理。缓冲区管理器会在缓存或数据文件中查找数据。\n第 7 步 如果语句是 UPDATE 或 INSERT，则将其传递给事务管理器做进一步处理。\n第 8 步 在事务处理期间，数据处于锁定模式。这是由锁管理器保证的。它还能确保事务的 ACID 属性。\n","permalink":"https://tofuwine.github.io/posts/21eb59d0/","summary":"数据库中如何执行 SQL 语句？\n下图显示了这一过程。请注意，不同数据库的架构各不相同，下图展示了一些常见的设计。\n第 1 步 通过传输层协议（如 TCP）向数据库发送 SQL 语句。\n第 2 步 将 SQL 语句发送到命令解析器，在那里进行语法和语义分析，然后生成查询树。\n第 3 步 将查询树发送给优化器。优化器会创建一个执行计划。\n第 4 步 将执行计划发送给执行器。执行器从执行计划中获取数据。执行器与存储引擎交互以访问数据。\n第 5 步 访问方法提供执行所需的数据获取逻辑，从存储引擎获取数据。\n第 6 步 访问方法决定 SQL 语句是否只读。如果查询是只读的（SELECT 语句），则将其传递给缓冲区管理器进行进一步处理。缓冲区管理器会在缓存或数据文件中查找数据。\n第 7 步 如果语句是 UPDATE 或 INSERT，则将其传递给事务管理器做进一步处理。\n第 8 步 在事务处理期间，数据处于锁定模式。这是由锁管理器保证的。它还能确保事务的 ACID 属性。","title":"SQL 语句是如何执行的？"},{"content":"简介 Spring Boot Starters are a set of convenient dependency descriptors that you can include in your application. You get a one-stop-shop for all the Spring and related technology that you need without having to hunt through sample code and copy paste loads of dependency descriptors. For example, if you want to get started using Spring and JPA for database access include the spring-boot-starter-data-jpa dependency in your project, and you are good to go. Spring Boot Starter 是 Spring Boot 中的一个重要概念，它是一种提供依赖项的方式，可以帮助开发人员快速集成第三方库和框架。Spring Boot Starter 的目的是简化 Spring 应用程序的依赖管理，将一组相关的依赖项打包在一起，并提供一个依赖项描述文件，使开发人员可以快速集成。\nSpring Boot Starter 的核心原理是基于 Spring Boot 的自动配置机制，它是 Spring Boot 的一个重要特性，也是实现 Spring Boot Starter 的关键。Spring Boot 的自动配置机制通过扫描 classpath 上的 Jar 包和配置文件，自动创建 Spring Bean，完成对应的配置。开发人员只需引入对应的 Starter 依赖，就能够自动配置所需的 Bean，不需要手动编写配置文件。\n查看 Spring 提供的 Starters：spring-boot-starters\n结构 官方文档参考: custom-starter 一个 Starter 工程通常包含两个模块（不是必须的）：\nautoconfigure。定义自动配置类以及用于自定义配置的属性类等。 starter。用于引入库和自动配置项目的依赖项。 以 Mybatis 为例\nmybatis/spring-boot-starter 其包含如下模块：\nmybatis-spring-boot-autoconfigure mybatis-spring-boot-starter mybatis-spring-boot-samples mybatis-spring-boot-starter-test mybatis-spring-boot-test-autoconfigure 命名 实现自己的 Starter，第一步就是为其命名。看一下官方提供的介绍：\nWhat is in a name\nAll official starters follow a similar naming pattern; spring-boot-starter-*, where * is a particular type of application. This naming structure is intended to help when you need to find a starter. The Maven integration in many IDEs lets you search dependencies by name. For example, with the appropriate Eclipse or Spring Tools plugin installed, you can press ctrl-space in the POM editor and type “spring-boot-starter” for a complete list.\nAs explained in the “Creating Your Own Starter” section, third party starters should not start with spring-boot, as it is reserved for official Spring Boot artifacts. Rather, a third-party starter typically starts with the name of the project. For example, a third-party starter project called thirdpartyproject would typically be named thirdpartyproject-spring-boot-starter.\n建议格式：\n官方的 Starter 命名格式为：spring-boot-starter-* 第三方，即我们自建的 Starter 命名格式为 *-spring-boot-starter 自定义 Starter 我们以基本结构为例（即包含 autoconfigure 和 starter 两个模块），创建我们的自定义 Starter：\n创建一个空项目 新建项目 example-spring-boot：\npom.xml pom.xml 内容参考如下：（建议先将两个模块创建完后再修改）\nxml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;groupId\u0026gt;cn.tofuwine\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;example-spring-boot\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;packaging\u0026gt;pom\u0026lt;/packaging\u0026gt; \u0026lt;modules\u0026gt; \u0026lt;module\u0026gt;example-spring-boot-autoconfigure\u0026lt;/module\u0026gt; \u0026lt;module\u0026gt;exmaple-spring-boot-starter\u0026lt;/module\u0026gt; \u0026lt;/modules\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;java.version\u0026gt;21\u0026lt;/java.version\u0026gt; \u0026lt;maven.compiler.source\u0026gt;21\u0026lt;/maven.compiler.source\u0026gt; \u0026lt;maven.compiler.target\u0026gt;21\u0026lt;/maven.compiler.target\u0026gt; \u0026lt;project.build.sourceEncoding\u0026gt;UTF-8\u0026lt;/project.build.sourceEncoding\u0026gt; \u0026lt;spring-boot.version\u0026gt;3.2.4\u0026lt;/spring-boot.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencyManagement\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-dependencies\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring-boot.version}\u0026lt;/version\u0026gt; \u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt; \u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring-boot.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;cn.tofuwine\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;example-spring-boot-autoconfigure\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${project.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;cn.tofuwine\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;example-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/dependencyManagement\u0026gt; \u0026lt;build\u0026gt; \u0026lt;pluginManagement\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring-boot.version}\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;excludes\u0026gt; \u0026lt;exclude\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-autoconfigure-processor\u0026lt;/artifactId\u0026gt; \u0026lt;/exclude\u0026gt; \u0026lt;/excludes\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/pluginManagement\u0026gt; \u0026lt;/build\u0026gt; \u0026lt;/project\u0026gt; 创建 autoconfigure 模块 右键项目，选择 New -\u0026gt; Module...，创建 example-spring-boot-autoconfigure 模块：\npom.xml pom.xml 内容参考如下：（建议先将两个模块创建完后再修改）\nxml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;cn.tofuwine\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;example-spring-boot\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;artifactId\u0026gt;example-spring-boot-autoconfigure\u0026lt;/artifactId\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;maven.compiler.source\u0026gt;21\u0026lt;/maven.compiler.source\u0026gt; \u0026lt;maven.compiler.target\u0026gt;21\u0026lt;/maven.compiler.target\u0026gt; \u0026lt;project.build.sourceEncoding\u0026gt;UTF-8\u0026lt;/project.build.sourceEncoding\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!-- Compile dependencies --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-autoconfigure\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Optional dependencies --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-autoconfigure-processor\u0026lt;/artifactId\u0026gt; \u0026lt;optional\u0026gt;true\u0026lt;/optional\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- @ConfigurationProperties annotation processing (metadata for IDEs) --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-configuration-processor\u0026lt;/artifactId\u0026gt; \u0026lt;optional\u0026gt;true\u0026lt;/optional\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Test dependencies --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-test-autoconfigure\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/project\u0026gt; 创建 starter 模块 右键项目，选择 New -\u0026gt; Module...，创建 example-spring-boot-starter 模块：\npom.xml pom.xml 内容参考如下：\nxml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;cn.tofuwine\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;example-spring-boot\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;packaging\u0026gt;pom\u0026lt;/packaging\u0026gt; \u0026lt;artifactId\u0026gt;example-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;maven.compiler.source\u0026gt;21\u0026lt;/maven.compiler.source\u0026gt; \u0026lt;maven.compiler.target\u0026gt;21\u0026lt;/maven.compiler.target\u0026gt; \u0026lt;project.build.sourceEncoding\u0026gt;UTF-8\u0026lt;/project.build.sourceEncoding\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;cn.tofuwine\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;example-spring-boot-autoconfigure\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/project\u0026gt; The starter module that provides a dependency to the autoconfigure module as well as \u0026ldquo;acme\u0026rdquo; and any additional dependencies that are typically useful. In a nutshell, adding the starter should provide everything needed to start using that library.\nstarter 模块主要为了提供 autoconfigure 模块的依赖，正常情况下，autoconfigure 引用的依赖应该在此声明。由于我们 autoconfigure 模块未引用其他依赖，此处仅引入 autoconfigure 和 spring-boot-starter。\n实现一个简单的功能 在 autoconfigure 模块实现获取当前时间的功能（时间格式根据配置而变）：\nProperties 作为 Starter 项目，很多情况下需要用户进行必要的配置更改，用户一般在配置文件 (application.properties 或 application.yml）中更改这些配置。我们一般使用 @ConfigurationProperties 进行获取（也可通过 @Vaule + SpEL 表达式获取）。\n创建 ExampleProperties，使用 @ConfigurationProperties(\u0026quot;example\u0026quot;) 注入配置文件 example 节点配置。\njava 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package cn.tofuwine.example.starter.config; import org.springframework.boot.context.properties.ConfigurationProperties; @ConfigurationProperties(prefix = \u0026#34;example\u0026#34;) public class ExampleProperties { private String timePattern = \u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;; public String getTimePattern() { return timePattern; } public void setTimePattern(String timePattern) { this.timePattern = timePattern; } } 元数据 [可选] 官方文档参考：configuration-metadata 元数据文件 spring-configuration-metadata.json，提供所有支持的配置属性的详细信息。这些文件旨在允许 IDE 开发人员在用户使用配置文件 application.properties 或 application.yml 文件时提供上下文帮助和自动补全。\n手动创建\n在 resources 目录下创建 META-INF 目录，创建 spring-configuration-metadata.json 文件，内容如下：\njson 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 { \u0026#34;groups\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;example\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;cn.tofuwine.example.config.ExampleProperties\u0026#34;, \u0026#34;sourceType\u0026#34;: \u0026#34;cn.tofuwine.example.config.ExampleProperties\u0026#34; } ], \u0026#34;properties\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;example.time-pattern\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;java.lang.String\u0026#34;, \u0026#34;sourceType\u0026#34;: \u0026#34;cn.tofuwine.example.config.ExampleProperties\u0026#34;, \u0026#34;defaultValue\u0026#34;: \u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34; } ], \u0026#34;hints\u0026#34;: [] } 自动创建\n本文示例采用此方式。\n通过 spring-boot-configuration-processor 搭配 @ConfigurationProperties 自动创建元数据文件。仅需引入依赖：\nxml 1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-configuration-processor\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; Service 新建 TimeService，实现功能：\njava 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package cn.tofuwine.example.starter.service; import cn.tofuwine.example.starter.config.ExampleProperties; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; import java.time.LocalDateTime; import java.time.format.DateTimeFormatter; @Service public class TimeService { private ExampleProperties exampleProperties; public String now() { DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(exampleProperties.getTimePattern()); String time = LocalDateTime.now().format(dateTimeFormatter); return \u0026#34;Example Starter Now: \u0026#34; + time; } @Autowired public void setExampleProperties(ExampleProperties exampleProperties) { this.exampleProperties = exampleProperties; } } Configuration 新建配置类，将 Starter 的 Bean 注入到 IoC 中。\n使用 @Bean 添加指定的对象到 IoC 中：\njava 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package cn.tofuwine.example.config; import cn.tofuwine.example.service.TimeService; import org.springframework.boot.context.properties.EnableConfigurationProperties; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @EnableConfigurationProperties(ExampleProperties.class) @Configuration public class ExampleAutoConfiguration { @Bean public TimeService timeService() { return new TimeService(); } } 也可以使用 @ComponentScan 将所有 cn.tofuwine.example 为前缀的包 Component 均加入到 IoC 中：\njava 1 2 3 4 5 6 7 8 9 10 11 package cn.tofuwine.example.config; import org.springframework.boot.context.properties.EnableConfigurationProperties; import org.springframework.context.annotation.ComponentScan; import org.springframework.context.annotation.Configuration; @EnableConfigurationProperties(ExampleProperties.class) @Configuration @ComponentScan(basePackages = \u0026#34;cn.tofuwine.example\u0026#34;) public class ExampleAutoConfiguration { } 至此，我们的功能已经实现。\n自动配置 官方文档参考：locating-auto-configuration-candidates 为了让我们的 Starter 在被其他 Spring Boot 项目引用时可直接使用，我们需要指定我们的配置类，并让其自动加载到 ApplicationContext 中。方式如下：\n创建文件 META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports，并指定 ExampleConfiguration：（如需导入多个，每个占一行）\ntext 1 cn.tofuwine.example.starter.config.ExampleAutoConfiguration 此方式在 Spring Boot 2.7 起开始支持。其他方式请参考附录。\n打包 项目打包并注册到本地仓库（以 IDEA 为例）。\n打包后，在 example-spring-boot-autoconfigure 模块 target 目录下生成文件 example-spring-boot-starter-1.0-SNAPSHOT.jar ，同时可以看到在 target/classes/META-INF 目录下包含 spring-configuration-metadata.json 文件。\n使用 Starter 新建 Spring Boot 项目 我们新建一个 Spring Boot 项目 using-example-starter （建议使用与 Starter 同版本 Java 和 Spring Boot）：\n引入 Starter 依赖 编辑 pom.xml，添加 Starter 依赖：\nxml 1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;cn.tofuwine\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;example-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 模拟使用 新建类 ExampleRunner，参考如下：\njava 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package cn.tofuwine.using.example.starter; import cn.tofuwine.example.starter.service.TimeService; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.ApplicationArguments; import org.springframework.boot.ApplicationRunner; import org.springframework.stereotype.Component; @Component public class ExampleRunner implements ApplicationRunner { private TimeService timeService; @Override public void run(ApplicationArguments args) throws Exception { System.out.println(timeService.now()); } @Autowired public void setTimeService(TimeService timeService) { this.timeService = timeService; } } 修改配置文件，添加如下配置（将输出的格式修改为 yyyy-MM-dd）：\nproperties 1 example.time-pattern=yyyy-MM-dd 运行程序，观察控制台输出：\n可以看到输出结果是 2024-04-17，符合预期。\n单元测试 由于单独的 Starter 并不是一个完整的应用，大多数情况只是作为一个应用的一部分，如果只是通过另一个项目引用并启动，对 debug 有很大的影响，所以我们需要创建可以独立运行的 Test。\n依赖 Starter 单元测试引入以下两个依赖（本文上述示例中已经引入）：\nxml 1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;!-- Test dependencies --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-test-autoconfigure\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; 首先在 test/resources 目录下创建配置文件 application-test.properties，内容如下：\nproperties 1 example.time-pattern=yyyy-MM-dd 然后，为 TestService 写一个简单的测试：\njava 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package cn.tofuwine.example.starter.service; import cn.tofuwine.example.starter.config.ExampleAutoConfiguration; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.context.annotation.Profile; import org.springframework.test.context.TestPropertySource; import java.time.LocalDateTime; import java.time.format.DateTimeFormatter; import static org.junit.jupiter.api.Assertions.*; @SpringBootTest(classes = {ExampleAutoConfiguration.class}) @TestPropertySource(\u0026#34;classpath:application-test.properties\u0026#34;) class TimeServiceTest { @Autowired private TimeService timeService; @Test void now() { DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(\u0026#34;yyyy-MM-dd\u0026#34;); String expect = \u0026#34;Example Starter Now: \u0026#34; + LocalDateTime.now().format(dateTimeFormatter); assertEquals(expect, timeService.now()); } } 然后运行查看测试结果，显示 Tests passed: 1。\n附录 如何将自定义 Starter 中的组件集成到 Spring Boot 应用中 方式一 在 META-INF 创建文件显示指定配置类。\nSpring Boot 2.7 以上版本：\n创建文件 META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports，并指定相关的类（如需导入多个，每个占一行）。参考文中示例。\nSpring Boot 3.0 以下版本\n（注意：此方式在 Spring Boot 2.7 开始被标记为 deprecated，并在 Spring Boot 3 开始移除）\n创建 META-INF/spring.factories 文件，并指定相关的类（如需导入多个，每个占一行，换行使用 \\）。\n使用此方式时，当一个 Spring Boot 项目引入我们的 Starter，那么会自动将 Starter 的相关组件注入到其 ApplicationContext 中。\n以本文 Starter 为例，spring.factories 内容参考如下：\ntext 1 2 org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\ cn.tofuwine.example.starter.config.ExampleAutoConfiguration 方式二 创建自定义注解 @EnableXxx，以本文示例，新建注解 @EnableExample，内容如下：\njava 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package cn.tofuwine.example.starter.annotations; import cn.tofuwine.example.starter.config.ExampleAutoConfiguration; import org.springframework.context.annotation.Import; import java.lang.annotation.Documented; import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; @Target({ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented @Import({ExampleAutoConfiguration.class}) public @interface EnableExample { } 当一个 Spring Boot 项目引入我们的 Starter 后，可以通过使用 @EnableExample 注解开启我们的 Starter，将相关组件注入到其 ApplicationContext 中。相较于方式一，将选择权交给了引用方。\n","permalink":"https://tofuwine.github.io/posts/d41b9ed5/","summary":"介绍 Spring Boot 如何自定义 Starter 工程","title":"Spring Boot 自定义 Starter"},{"content":"为了实现在 Spring Boot 工程启动后，自动执行特定方法的功能，我们可以通过以下方式实现。\nCommandLineRunner 实现 CommandLineRunner 接口，在 run 方法里面调用需要执行的方法即可。\n特定：\n方式执行时，项目已初始化完毕，可提供正常服务。 可以接受参数，不限制格式。项目启动时传入参数：java -jar example.jar arg1 arg2 arg3 可直接注入 Spring IoC 容器的 bean。 代码示例：\njava 1 2 3 4 5 6 7 8 9 10 import org.springframework.boot.CommandLineRunner; import org.springframework.stereotype.Component; @Component public class Runner implements CommandLineRunner { @Override public void run(String... args) throws Exception { // todo your code } } ApplicationRunner 实现 ApplicationRunner 接口与实现 CommandLineRunner 接口基本一致。\n唯一不同是启动是参数的格式：CommandLineRunner 对于参数格式没有限制，ApplicationRunner 接口参数格式必须是 -key=value\n代码示例：\njava 1 2 3 4 5 6 7 8 9 10 11 12 import org.springframework.boot.ApplicationArguments; import org.springframework.boot.ApplicationRunner; import org.springframework.stereotype.Component; @Component public class Runner implements ApplicationRunner { @Override public void run(ApplicationArguments args) throws Exception { // todo your code } } ApplicationListener 实现接口 ApplicationListener 方式和实现 ApplicationRunner、CommandLineRunner 接口都不影响服务，均可正常提供服务。\n为了可以直接注入 bean，监听事件一般为 ApplicationStartedEvent 或 ApplicationReadyEvent，其他事件可能无法正常注入 bean。\n代码示例:\njava ApplicationStartedEvent 1 2 3 4 5 6 7 8 9 10 11 import org.springframework.boot.context.event.ApplicationStartedEvent; import org.springframework.context.ApplicationListener; import org.springframework.stereotype.Component; @Component public class Runner implements ApplicationListener\u0026lt;ApplicationStartedEvent\u0026gt; { @Override public void onApplicationEvent(ApplicationStartedEvent event) { // todo your code } } java ApplicationReadyEvent 1 2 3 4 5 6 7 8 9 10 11 import org.springframework.boot.context.event.ApplicationReadyEvent; import org.springframework.context.ApplicationListener; import org.springframework.stereotype.Component; @Component public class Runner implements ApplicationListener\u0026lt;ApplicationReadyEvent\u0026gt; { @Override public void onApplicationEvent(ApplicationReadyEvent event) { // todo your code } } 其他方式 你也可以通过自定义 Spring Bean 初始化逻辑来实现程序启动时自动执行方法。 但一般此类方式均在项目启动过程中执行，且执行过程期间无法提供正常服务。 如使用 @PostConstruct 注解、实现 InitializingBean 接口、指定 init-method 方法等。\n执行顺序 其他方式（通过自定义 Bean 初始化逻辑）始终最先执行。 如果监听 ApplicationStartedEvent 事件，则一定会在 CommandLineRunner 和 ApplicationRunner 之前执行。 如果监听 ApplicationReadyEvent 事件，则一定会在 CommandLineRunner 和 ApplicationRunner 之后执行。 CommandLineRunner 和 ApplicationRunner 默认是 ApplicationRunner 先执行。如果指定了 @Order 则按照 @Order 大的先执行。 ","permalink":"https://tofuwine.github.io/posts/14d680b0/","summary":"Spring Boot 启动后自动执行特定方法","title":"Spring Boot 启动后自动执行方法的几种方式"},{"content":"简介 Apache FreeMarker™ 是一个模板引擎：一个基于模板和变更数据生成文本输出（HTML 网页、电子邮件、配置文件、源代码等）的 Java 库。\nFreeMarker 没有其他任何依赖，仅仅依赖 Java 自身。\n最新版本：FreeMarker 2.3.32（2023-01-12）\nmaven 依赖 普通 Java 工程按如下方式引入：\nxml pom.xml 1 2 3 4 5 6 \u0026lt;!-- https://mvnrepository.com/artifact/org.freemarker/freemarker --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.freemarker\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;freemarker\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.3.32\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 如果是 Spring Boot 工程可以引入 spring-boot-starter-freemarker：\nxml pom.xml 1 2 3 4 5 \u0026lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-freemarker --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-freemarker\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 代码示例 普通工程 以下代码来源于 FreeMarker 官方教程：\njava 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 import freemarker.template.*; import java.util.*; import java.io.*; public class Test { public static void main(String[] args) throws Exception { /* ------------------------------------------------------------------------ */ /* You should do this ONLY ONCE in the whole application life-cycle: */ /* Create and adjust the configuration singleton */ Configuration cfg = new Configuration(Configuration.VERSION_2_3_32); cfg.setDirectoryForTemplateLoading(new File(\u0026#34;/where/you/store/templates\u0026#34;)); // Recommended settings for new projects: cfg.setDefaultEncoding(\u0026#34;UTF-8\u0026#34;); cfg.setTemplateExceptionHandler(TemplateExceptionHandler.RETHROW_HANDLER); cfg.setLogTemplateExceptions(false); cfg.setWrapUncheckedExceptions(true); cfg.setFallbackOnNullLoopVariable(false); cfg.setSQLDateAndTimeTimeZone(TimeZone.getDefault()); /* ------------------------------------------------------------------------ */ /* You usually do these for MULTIPLE TIMES in the application life-cycle: */ /* Create a data-model */ Map root = new HashMap(); root.put(\u0026#34;user\u0026#34;, \u0026#34;Big Joe\u0026#34;); Product latest = new Product(); latest.setUrl(\u0026#34;products/greenmouse.html\u0026#34;); latest.setName(\u0026#34;green mouse\u0026#34;); root.put(\u0026#34;latestProduct\u0026#34;, latest); /* Get the template (uses cache internally) */ Template temp = cfg.getTemplate(\u0026#34;test.ftlh\u0026#34;); /* Merge data-model with template */ Writer out = new OutputStreamWriter(System.out); temp.process(root, out); // Note: Depending on what `out` is, you may need to call `out.close()`. // This is usually the case for file output, but not for servlet output. } } Product 类如下：\njava 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 /** * Product bean; note that it must be a public class! */ public class Product { private String url; private String name; // As per the JavaBeans spec., this defines the \u0026#34;url\u0026#34; bean property // It must be public! public String getUrl() { return url; } public void setUrl(String url) { this.url = url; } // As per the JavaBean spec., this defines the \u0026#34;name\u0026#34; bean property // It must be public! public String getName() { return name; } public void setName(String name) { this.name = name; } } FreeMarker 模板 test.ftlh 如下：\nhtml 1 2 3 4 5 6 7 8 9 10 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Welcome!\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Welcome ${user}!\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;Our latest product: \u0026lt;a href=\u0026#34;${latestProduct.url}\u0026#34;\u0026gt;${latestProduct.name}\u0026lt;/a\u0026gt;! \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Spring Boot 工程 在 Spring Boot 中实现上述功能（需引入 spring-boot-starter-freemarker 依赖）：\njava 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 import freemarker.template.Configuration; import freemarker.template.Template; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.ApplicationArguments; import org.springframework.boot.ApplicationRunner; import org.springframework.stereotype.Component; import java.io.OutputStreamWriter; import java.io.Writer; import java.util.HashMap; import java.util.Map; @Component public class TestRunner implements ApplicationRunner { private Configuration configuration; @Autowired public void setConfiguration(Configuration configuration) { this.configuration = configuration; } @Override public void run(ApplicationArguments args) throws Exception { Map root = new HashMap(); root.put(\u0026#34;user\u0026#34;, \u0026#34;Big Joe\u0026#34;); Product latest = new Product(); latest.setUrl(\u0026#34;products/greenmouse.html\u0026#34;); latest.setName(\u0026#34;green mouse\u0026#34;); root.put(\u0026#34;latestProduct\u0026#34;, latest); Template temp = configuration.getTemplate(\u0026#34;test.ftlh\u0026#34;); Writer out = new OutputStreamWriter(System.out); temp.process(root, out); } } Product 类（使用 Lombok)：\njava 1 2 3 4 5 6 7 import lombok.Data; @Data public class Product { private String url; private String name; } 模板文件放在 /resources/templates 目录下。\n提示 Spring Boot 默认封装了 FreeMarker 配置，我们可以直接注入使用。也可以修改 FreeMarker 配置，如缓存、模板路径、模板文件后缀等。配置节点以 spring.freemarker 为前缀。 模板语法 提示 具体详细的语法及说明应参考官方文档。 模板结构 FTL 模板由以下部分混合而成：\n文本（Text）： 文本内容会原样输出。 插值（Interpolation）：这部分的输出会被计算结果替代。插值使用 ${...}。（注：#{...} 已被弃用。See more here） FTL 标签（FTL tags）：与 HTML 标签相似，用于 FreeMarker 指令。 注释（Comments）：使用 \u0026lt;#-- 和 --\u0026gt; 来分隔。注释会被 FreeMarker 直接忽略，不会在输出内容中显示。 插值 标准格式为：${expression} 。其中 expression 可以是所有类型的表达式。如：${100 + x}\n提示 插值表达式也可以使用 [=expression] 形式。参考 See more about alternative syntaxes\u0026hellip; 表达式 直接指定值 Strings: \u0026quot;Foo\u0026quot; or 'Foo' or \u0026quot;It's \\\u0026quot;quoted\\\u0026quot;\u0026quot; or 'It\\'s \u0026quot;quoted\u0026quot;' or r\u0026quot;C:\\raw\\string\u0026quot; Numbers: 123.45 Booleans: true, false Sequences: [\u0026quot;foo\u0026quot;, \u0026quot;bar\u0026quot;, 123.45]; Ranges: 0..9, 0..\u0026lt;10 (or 0..!10), 0.. Hashes: {\u0026quot;name\u0026quot;:\u0026quot;green mouse\u0026quot;, \u0026quot;price\u0026quot;:150} 检索变量 顶层变量: user 从 Hashes 中检索数据: user.name, user[\u0026quot;name\u0026quot;] 从 Sequences 中检索数据: products[5] 特殊变量: .main 字符串操作 插值（或连接）: \u0026quot;Hello ${user}!\u0026quot; (or \u0026quot;Hello \u0026quot; + user + \u0026quot;!\u0026quot;) 获取一个字符: name[0] 字符串切片 Inclusive end: name[0..4], Exclusive end: name[0..\u0026lt;5], Length-based (lenient): name[0..*5], Remove starting: name[5..] Sequence 操作 连接: users + [\u0026quot;guest\u0026quot;] Sequence 切片: Inclusive end: products[20..29], Exclusive end: products[20..\u0026lt;30], Length-based (lenient): products[20..*10], Remove starting: products[20..] Hash 操作 连接: passwords + { \u0026quot;joe\u0026quot;: \u0026quot;secret42\u0026quot; } 算数运算: (x * 1.5 + 10) / 2 - y % 100 比较运算: x == y, x != y, x \u0026lt; y, x \u0026gt; y, x \u0026gt;= y, x \u0026lt;= y, x lt y, x lte y, x gt y, x gte y, \u0026hellip;etc. 逻辑操作: !registered \u0026amp;\u0026amp; (firstVisit || fromEurope) 内建函数: name?upper_case, path?ensure_starts_with('/') 方法调用: repeat(\u0026quot;What\u0026quot;, 3) 处理不存在的值: 默认值: name!\u0026quot;unknown\u0026quot; or (user.name)!\u0026quot;unknown\u0026quot; or name! or (user.name)! 检测不存在值: name?? or (user.name)?? 赋值操作: =, +=, -=, *=, /=, %=, ++, -- Local lambdas: x -\u0026gt; x + 1, (x, y) -\u0026gt; x + y 内置函数参考 字母索引 字符串内置函数 数字内置函数 日期内置函数 布尔值内置函数 序列内置函数 哈希内置函数 结点（XML） 内置函数 循环变量内置函数 独立类型内置函数 很少使用的专家内置函数 指令 标准格式是使用两种 FTL 标签：\n开始标签：\u0026lt;#directivename parameters\u0026gt; 结束标签：\u0026lt;/#directivename\u0026gt; 例如：\u0026lt;#if something\u0026gt;...\u0026lt;/#if\u0026gt;\nFTL 标签与 HTML 标签一样，必须正确嵌套。所以下面的代码是错误的，因为 if 指令既在 list 指令的嵌套内容的内部又在外部：\nhtml 1 2 3 4 5 6 7 8 \u0026lt;ul\u0026gt; \u0026lt;#list animals as animal\u0026gt; \u0026lt;li\u0026gt;${animal.name} for ${animal.price} Euros \u0026lt;#if user == \u0026#34;Big Joe\u0026#34;\u0026gt; (except for you) \u0026lt;/#list\u0026gt; \u0026lt;#-- WRONG! The \u0026#34;if\u0026#34; has to be closed first. --\u0026gt; \u0026lt;/#if\u0026gt; \u0026lt;/ul\u0026gt; 提示 FreeMarker 可以使用 [ 和 ] 替代 \u0026lt; 和 \u0026gt;。例如：[#if user == \u0026quot;Big Joe\u0026quot;]...[/#if]。\n更多信息请阅读：Miscellaneous/Alternative (square bracket) syntax.\n指令参考：\nAlphabetical index assign attempt, recover autoesc compress escape, noescape (deprecated) flush ftl function, return global if, else, elseif import include list, else, items, sep, break, continue local macro, nested, return noautoesc noparse nt outputformat setting stop switch, case, default, break t, lt, rt User-defined directive (\u0026lt;@\u0026hellip;\u0026gt;) visit, recurse, fallback 参考 FreeMarker 官方文档 FreeMarker 中文手册 附录 FreeMarker 支持的转义字符 Escape sequence Meaning \\\u0026quot; 引号 (u0022) \\' 单引号 (u0027) \\{ 起始花括号:{ \\= 等号:= (Supported since FreeMarker 2.3.28.) \\\\ 反斜杠 (u005C) \\n 换行符 (u000A) \\r 回车 (u000D) \\t 水平制表符(又称为tab) (u0009) \\b 退格 (u0008) \\f 换页 (u000C) \\l 小于号:\u0026lt; \\g 大于号:\u0026gt; \\a \u0026amp; 符:\u0026amp; \\xCode 字符的十六进制Unicode 码 (UCS code) 在 \\x 之后的 Code 是 1-4 位的十六进制码。下面这个示例中都是在字符串中放置版权符号： \u0026quot;\\xA9 1999-2001\u0026quot;， \u0026quot;\\x0A9 1999-2001\u0026quot;， \u0026quot;\\x00A9 1999-2001\u0026quot;。 如果紧跟十六进制码后一位的字符也能解释成十六进制码时， 就必须把 4 位补全，否则 FreeMarker 就会误解你的意图。\nFTL 中的保留名称 下面的这些名称不能在非方括号语法中被用作顶层变量 (比如 .vars[\u0026quot;in\u0026quot;])，因为这是 FTL 中的关键字：\ntrue：布尔值\u0026quot;true\u0026quot; false：布尔值\u0026quot;false\u0026quot; gt：比较运算符\u0026quot;大于\u0026quot; gte：比较运算符\u0026quot;大于或等于\u0026quot; lt：比较运算符\u0026quot;小于\u0026quot; lte：比较运算符\u0026quot;小于或等于\u0026quot; as：由少数指令使用 in：由少数指令使用 using：由少数指令使用 ","permalink":"https://tofuwine.github.io/posts/28095def/","summary":"FreeMarker 基本语法介绍","title":"FreeMarker 基本用法"},{"content":"技巧 当前目录打开终端 方式一：\nShift + 鼠标右键 选择 在此处打开 PowerShell 窗口。如果要使用 CMD 则在 PowerShell 中输入如下命令：\npowershell 1 start cmd 方式二：\n打开 CMD：在路径显示框中输入 cmd 后按回车键 打开 PowerShell 7：在路径显示框中输入 pwsh 后按回车键 在终端打开当前目录 使用如下命令在终端当前目录打开资源管理器：\npowershell 1 explorer . 打开其他目录，把 . 替换为指定路径即可。例如打开 D:\\Software：\npowershell 1 explorer D:\\Software 注意：路径需使用反斜线 \\，不可用 /。\n快捷指令 任务管理器 运行：taskmgr 终端：taskmgr 快捷键：Ctrl + Alt + Delete 或 Ctrl + Alt + . 远程桌面 运行：mstsc 终端：mstsc 目录结构树 终端：TREE [drive:][path] [/F] [/A] 存入文件：\npowershell 1 tree D:\\Software /f \u0026gt; tree.txt FAQ 注册表相关 锁屏 Windows + L 键不可用 注册表位置：\ntext 1 计算机\\HKEY_CURRENT_USER\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System 修改 DisableLockWorkstation 为 0 即可。\n“打开方式”中存在已卸载的应用 注册表位置：\ntext 1 计算机\\HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FileExts\\xxx\\OpenWithList 选择对应的后缀名，如删除 notepad++，对 .gradle 文件的打开方式，则注册表路径为：\ntext 1 计算机\\HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FileExts\\.gradle\\OpenWithList 或者更简单的方式，打开注册表从头开始搜索 notepad++，然后把相关内容都删除即可。\n右键菜单默认打开更多选项（Windows 11） 设置命令：\npowershell 1 reg.exe add \u0026#34;HKCU\\Software\\Classes\\CLSID\\{86ca1aa0-34aa-4e8b-a509-50c905bae2a2}\\InprocServer32\u0026#34; /f /ve 恢复命令：\npowershell 1 reg.exe delete \u0026#34;HKCU\\Software\\Classes\\CLSID\\{86ca1aa0-34aa-4e8b-a509-50c905bae2a2}\\InprocServer32\u0026#34; /va /f BAT 相关 中文乱码 Windows 下的批处理文件（.bat）是以 ANSI 编码方式。若以别的方式（如 UTF-8），需转成 ANSI 格式或者将执行编码格式改成 UTF-8。\nbat 1 chcp 65001 常见代码页映射：\n代码页 编码 65001 UTF-8 936 GB2312 20127 US-ASCII ","permalink":"https://tofuwine.github.io/posts/dfe4b5cc/","summary":"Windows 常用技巧","title":"Windows 常用技巧"},{"content":"ManagementFactory ManagementFactory 是一个为我们提供各种获取 JVM 信息的工厂类，使用 ManagementFactory 可以获取大量的运行时 JVM 信息，比如 JVM 堆的使用情况，GC 情况，线程信息等。通过这些数据项我们可以了解正在运行的 JVM 的情况，以便我们可以做出相应的调整。\n使用 ManagementFactory 获取运行时进程 PID 方式如下：\njava 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 import java.lang.management.ManagementFactory; public class JVMUtil { /** * 方式一: 根据 SystemProperties 获取 PID * * @since JDK 1.5 */ public static long getPID() { return Long.parseLong(ManagementFactory.getRuntimeMXBean().getSystemProperties().get(\u0026#34;PID\u0026#34;)); } /** * 方式二: 根据 Name 截取 PID * * @since JDK 1.5 */ public static long getPID() { return Long.parseLong(ManagementFactory.getRuntimeMXBean().getName().split(\u0026#34;@\u0026#34;)[0]); } /** * 方式三: 直接获取 PID * * @since JDK 10 */ public static long getPID() { return ManagementFactory.getRuntimeMXBean().getPid(); } } ApplicationPidFileWriter 官方文档参考：Process Monitoring 在任何 Java 工程中我们可以将 ManagementFactory 方式封装成一个工具类使用，如果我们基于 Spring Boot 搭建工程，也可使用其提供的机制进行获取 PID。\nApplicationPidFileWriter 是 Spring Boot 提供的一个 Listener，它可以在应用启动后把 PID 写入到指定的文件，具体实现方式如下：\n修改启动类：\njava 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.boot.builder.SpringApplicationBuilder; import org.springframework.boot.context.ApplicationPidFileWriter; @SpringBootApplication public class Application { public static void main(String[] args) { SpringApplication app = new SpringApplicationBuilder() .listeners(new ApplicationPidFileWriter()) .sources(Application.class) .build(args); app.run(args); } } 默认会将 pid 写入到 appplication.pid 文件中。\n也可修改配置文件（以 application.properties 为例）：\nproperties 1 2 3 4 # PID 写入的文件名 spring.pid.file=app.pid # PID 写入失败是否抛出异常 spring.pid.fail-on-write-error=false 如此配置后，在启动 Spring Boot 工程后，会将当前 PID 写入到 spring.pid.file 指定的文件中。\nJPS JDK 提供了 jps 命令。（JDK 提供的工具，需在机器上安装 JDK 并正确配置环境变量）\n直接在终端输入 jps，即可列出所有 Java 进程的 PID 及对应的进程名称。\nPS 如果应用运行在 Linux 系统，同时机器未安装 JDK，那么可以通过 ps 命令配合表达式来查询指定进程的 PID：\nshell 1 ps -ef | grep your-jar-name.jar 命令说明：\nps 是一个用于查询当前运行进程的命令 -ef 是 ps 命令的选项，用于显示所有进程的详细信息，包括进程的用户、进程 ID（PID）、父进程 ID（PPID）、CPU 使用情况等。 | 是管道符号，用于将一个命令的输出作为另一个命令的输入。 grep 是一个用于在文本中搜索指定内容的命令。 your-jar-name.jar 是指要搜索的内容关键字 $! 如果应用运行在 Linux 系统，同时使用 shell 脚本启动应用，则可通过 $! 变量获取应用的 PID：\nshell 1 nohup java -jar your-jar-name.jar \u0026amp; echo $! \u0026gt; app.pid 命令说明：\nnohup：它会忽略 SIGHUP 信号（终端挂起信号），这样即使关闭终端，进程也会继续运行。 \u0026amp;：将命令置于后台运行。 echo $! \u0026gt; app.pid 将刚刚启动的进程 PID 写入到文件 app.pid 中。 ","permalink":"https://tofuwine.github.io/posts/5d7a2ee8/","summary":"本文介绍 Java 获取应用 PID 的几种方式","title":"Java 获取应用 PID"},{"content":"Overview 当创建一个 bean definition 时，实际上创建了一个用于创建该 bean definition 所定义类的实例的 recipe (配方)。 将 bean 定义视为 recipe (配方) 的概念很重要，这意味着，你可以从单个配方中创建许多对象实例，就像类一样。\n你不仅可以控制从特定 bean definition 创建的对象中插入各种依赖项和配置值，还可以控制从特定 bean definition 创建的对象的作用域。 这种方法强大且灵活，你可以通过配置选择创建对象的作用域，而不是在 Java 类级别固定对象的作用域。\nSpring 框架支持六种作用域，其中四种仅在使用 Web-aware ApplicationContext 时可用。 此外，你还可以创建自定义作用域。\n下表描述了支持的作用域：\nScope Description singleton (Default) Scopes a single bean definition to a single object instance for each Spring IoC container. prototype Scopes a single bean definition to any number of object instances. request Scopes a single bean definition to the lifecycle of a single HTTP request. That is, each HTTP request has its own instance of a bean created off the back of a single bean definition. Only valid in the context of a web-aware Spring ApplicationContext . session Scopes a singe bean definition to the lifecycle of an HTTP Session . Only valid in the context of a web-aware Spring ApplicationContext . application Scopes a single bean definition to the lifecycle of a ServletContext . Only valid in the context of a web-aware Spring ApplicationContext . websocket Scopes a single bean definition to the lifecycle of a WebSocket . Only valid in the context of a web-aware Spring ApplicationContext . The Singleton Scope 单例作用域是 Spring 中的默认作用域\n当定义一个 bean 定义，并将该 bean 定义的作用域设置为 Singleton 时，Spring IoC 容器会创建该 bean 定义所定义的对象的一个实例。 这个单一实例被存储在这些单例 bean 的缓存中，所有对于该命名 bean 的后续请求和应用都会返回该缓存的对象。\n下图展示了单例作用域的工作原理：\nSpring 框架中的单例 Bean 的概念与设计模式中定义的单例模式有所不同。设计模式中的单例模式将对象的作用域硬编码为每个 ClassLoader 仅创建一个特定类的实例。Spring 中单例的作用域最好描述为每个容器和每个 Bean。这意味着，如果你在一个 Spring 容器中为特定类定义了一个 bean，Spring 容器将只创建一个该 bean definition 所定义类的实例。\n要在 XML 中将一个 bean 定义为 Singleton，你可以按照以下示例定义一个 bean：\nxml 1 2 3 4 5 6 7 8 9 10 11 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;accountService\u0026#34; class=\u0026#34;com.something.DefaultAccountService\u0026#34;/\u0026gt; \u0026lt;!-- the following is equivalent, though redundant (singleton scope is the default) --\u0026gt; \u0026lt;bean id=\u0026#34;accountService\u0026#34; class=\u0026#34;com.something.DefaultAccountService\u0026#34; scope=\u0026#34;singleton\u0026#34;/\u0026gt; \u0026lt;/beans\u0026gt; 要在 Spring Boot 中将一个 bean 定义为 Singleton，你可以按照以下示例定义一个 bean：\njava 1 2 3 4 5 6 7 8 9 import org.springframework.beans.factory.config.ConfigurableBeanFactory; import org.springframework.context.annotation.Scope; import org.springframework.stereotype.Component; @Component @Scope(value = ConfigurableBeanFactory.SCOPE_SINGLETON) public class DefaultAccountService { // some definition } 由于单例作用域是 Spring 默认的作用域，因此，对于作用域需要定义为 Singleton 的 bean，无需添加 @Scope 注解。\nSingleton Scope 最佳实践 在使用 Singleton Scope 时，你应该注意一些最佳实践：\n无状态✅。尽可能使你的 Singleton Bean 无状态。有状态的 Singleton 会导致与共享状态相关的难以调试的问题，尤其是在多线程环境中。 线程安全✅。如果你的 Singleton Bean 有状态，请确保它们是线程安全的，因为 Singleton Bean 是跨多个线程共享的。 延迟初始化✅。如果你的 Singleton Bean 在启动过程中会占用大量资源，请考虑对其使用延迟初始化。这可以通过在 Bean Definition 中添加 @Lazy 注解来实现。 请记住，Singleton Scope 的关键在于了解每个 Spring IoC 容器只有一个实例。因此，与 Singleton Bean 的每次交互都将与相同状态交互，因此应进行相应的设计。\nThe Prototype Scope 非单例的原型（Prototype）作用域的 bean 部署会在每次请求特定 bean 时创建一个新的 bean 示例。换句话说：当将 bean 注入到另一个 bean 中或通过容器的 getBean() 方法调用请求它时，都会创建一个新的实例。\n通常情况下，应该将原型作用域用于所有有状态（stateful）的 bean，而将单例作用域用于无状态（stateless）的 bean。\n下图说明了 Spring 的原型（Prototype）作用域：\nDAO (A data access object) 通常不会配置为原型，因为典型的 DAO 不保存任何会话状态。\n以下示例在 XML 中将一个 bean 定义为原型：\nxml 1 2 3 4 5 6 7 8 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;accountService\u0026#34; class=\u0026#34;com.something.DefaultAccountService\u0026#34; scope=\u0026#34;prototype\u0026#34;/\u0026gt; \u0026lt;/beans\u0026gt; 以下示例在 Spring Boot 中将一个 bean 定义为原型：\njava 1 2 3 4 5 @Component @Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE) public class DefaultAccountService { // some definition } 与其他作用域不同，Spring 不管理原型 bean 的完整生命周期。容器实例化、配置和组装原型对象，并将其交给客户端，不再记录该原型 bean。因此，尽管对所有对象调用初始化生命周期回调方法（无论作用域如何），但对于原型，配置的销毁生命周期回调方法不会被调用。客户端代码必须清理原型作用域对象并释放原型 bean 持有的昂贵资源。\n要让 Spring 容器释放原型作用域 bean 持有的资源，可以尝试使用一个持有需要清理的 bean 引用的自定义 bean 后处理器。\n在某些方面，Spring 容器对于原型作用域 bean 的角色可以看作是 Java 中的 new 操作符的替代品。在那之后所有生命周期管理都必须由客户端处理。（有关 Spring 容器中 bean 生命周期的详细信息，请参阅生命周期回调）\n如果在单例作用域的 bean 中注入一个原型作用域 bean，需要额外的处理，请参考 Singleton Beans with Prototype-bean Dependencies\nPrototype Scope 最佳实践 请记住 Spring 不会管理 Prototype Bean 的整个生命周期：不会调用销毁生命周期回调。客户端代码必须清理 Prototype Scope 对象，并释放 Prototype Bean 持有的资源。 尽量少用 Prototype Scope。每次需要创建一个新的 Bean 实例时，都会耗费大量内存和处理时间，特别是对于重量级的有状态 Bean。 如果你将具有 Prototype Scope 的 Bean 注入到 Singleton Bean 中，则 Prototype Bean 的行为仍与 Singleton Bean 相同。这是因为 Singleton Bean 只创建一次，因此只会注入 Prototype Bean 的一个实例。要解决整个问题，你可以使用 Spring 的方法注入功能。 Web Aware Scopes 在实践中，很少使用这些作用域。\n作用域 request、session、application、websocket 仅在 Web Application Context 中可用（例如，XmlWebApplicationContext），如果你尝试在常规的 Spring IoC 容器（例如，ClassPathXmlApplicationContext ）中使用这些作用域，将会抛出 IllegalStateException 异常，报告未知的 Bean 作用域。注：常规 Spring Boot 工程可用。\n作用域 request 为单个 HTTP 请求创建一个 Bean 实例，而作用域 session 则为 HTTP 会话创建一个 Bean 实例。\n作用域 application 为 ServletContext 的生命周期创建一个 Bean 实例，而作用域 websocket 为特定的 WebScoket 会话创建一个 Bean 实例。\nRequest Scope 可以使用如下方式定义一个作用域 request 的 Bean：\njava 1 2 3 4 5 6 7 8 9 10 import org.springframework.context.annotation.Scope; import org.springframework.context.annotation.ScopedProxyMode; import org.springframework.stereotype.Component; import org.springframework.web.context.WebApplicationContext; @Component @Scope(value = WebApplicationContext.SCOPE_REQUEST, proxyMode = ScopedProxyMode.TARGET_CLASS) public class HelloMessageGenerator { // some definition } proxyMode 属性是必要的，因为在实例化 Web Application Context 时，没有活动的请求。Spring 创建一个代理来作为注入依赖，并在需要时在请求中实例化目标 Bean。\n此外，还可以使用一个组合的注解 @RequestScope 来充当上述定义的快捷方式（推荐）：\njava 1 2 3 4 5 6 7 8 import org.springframework.stereotype.Component; import org.springframework.web.context.annotation.RequestScope; @Component @RequestScope public class HelloMessageGenerator { // some definition } Session Scope 我们也可以用相似的方式定义作用域 session 的 Bean：\njava 1 2 3 4 5 6 7 8 9 10 import org.springframework.context.annotation.Scope; import org.springframework.context.annotation.ScopedProxyMode; import org.springframework.stereotype.Component; import org.springframework.web.context.WebApplicationContext; @Component @Scope(value = WebApplicationContext.SCOPE_SESSION, proxyMode = ScopedProxyMode.TARGET_CLASS) public class HelloMessageGenerator { // some definition } 同样的，也可以用一个组合注解 @SessionScope 来简化定义：\njava 1 2 3 4 5 6 7 8 import org.springframework.stereotype.Component; import org.springframework.web.context.annotation.SessionScope; @Component @SessionScope public class HelloMessageGenerator { // some definition } Application Scope application 作用域为 ServletContext 的生命周期创建一个 Bean 实例。这与 singleton 作用域类似，但是就 Bean 的作用域而言有一个非常重要的区别：\n当 Bean 是 application 作用域时，相同的 Bean 实例在运行在同一个 ServletContext 中的多个基于 Servlet 的应用程序之间共享，而 singleton 作用域的 Bean 仅作用于单个应用程序上下文。\n你可以按如下方式创建 application 作用域的 Bean：\njava 1 2 3 4 5 6 7 8 9 10 import org.springframework.context.annotation.Scope; import org.springframework.context.annotation.ScopedProxyMode; import org.springframework.stereotype.Component; import org.springframework.web.context.WebApplicationContext; @Component @Scope(value = WebApplicationContext.SCOPE_APPLICATION, proxyMode = ScopedProxyMode.TARGET_CLASS) public class HelloMessageGenerator { // some definition } 以简洁的方式（@ApplicationScope) 定义：\njava 1 2 3 4 5 6 7 8 import org.springframework.stereotype.Component; import org.springframework.web.context.annotation.ApplicationScope; @Component @ApplicationScope public class HelloMessageGenerator { // some definition } WebSocket Scope websocket 作用域与 WebSocket 会话的生命周期相关联，并适用于 STOMP over WebSocket 应用程序。详情可参阅 WebSocket Scope。\n定义 websocket 作用域的 Bean：\njava 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 @Component @Scope(scopeName = \u0026#34;websocket\u0026#34;, proxyMode = ScopedProxyMode.TARGET_CLASS) public class MyBean { @PostConstruct public void init() { // Invoked after dependencies injected } // ... @PreDestroy public void destroy() { // Invoked when the WebSocket session ends } } @Controller public class MyController { private final MyBean myBean; @Autowired public MyController(MyBean myBean) { this.myBean = myBean; } @MessageMapping(\u0026#34;/action\u0026#34;) public void handle() { // this.myBean from the current WebSocket session } } Custom Scopes 除了以上 Spring 已经定义好的 Scope 之外，你也可以定义自己的 Scope。如果你有兴趣，请参考官方文档。本文不再赘述。\nFAQ Singleton Beans with Prototype-bean Dependencies 当在单例作用域的 bean 依赖原型作用域的 bean 时，请注意依赖项在实例化时解析。因此，如果你将一个原型作用域的 bean 依赖注入到一个单例作用域的 bean 中，会实例化一个新的原型 bean，然后将其依赖注入到单例 bean 中。这个原型实例是唯一供给这个单例作用域 bean 的实例。\n然而，假设你希望单例作用域的 bean 在运行时重复获取原型作用域 bean 的新实例。你不能将一个原型作用域的 bean 注入到你的单例 bean 中，因为当 Spring 容器实例化单例 bean 并解析和注入其依赖项时，这种注入只发生一次。如果你需要在运行时多次获得原型 bean 的新实例，请参阅方法注入或按下述 SonarLint 提供的方式注入。\nSonarLint 详细内容请参阅：SonarLint Java Rule: RSPEC-6832\n错误示例：\njava 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 @Component @Scope(\u0026#34;prototype\u0026#34;) public class PrototypeBean { public Object execute() { //... } } public class SingletonBean { private PrototypeBean prototypeBean; @Autowired public SingletonBean(PrototypeBean prototypeBean) { // Noncompliant, the same instance of PrototypeBean is used for each bean request. this.prototypeBean = prototypeBean; } public Object process() { return prototypeBean.execute(); } } 正确示例：\njava 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 @Component @Scope(\u0026#34;prototype\u0026#34;) public class PrototypeBean { public Object execute() { //... } } public class SingletonBean implements ApplicationContextAware { private ApplicationContext applicationContext; @Autowired public SingletonBean(ApplicationContext applicationContext) { this.applicationContext = applicationContext; } public Object process() { PrototypeBean prototypeBean = createPrototypeBean(); return prototypeBean.execute(); } protected PrototypeBean createPrototypeBean() { return this.applicationContext.getBean(\u0026#34;prototypeBean\u0026#34;, PrototypeBean.class); } } 如果在单例作用域的 bean 注入 Request 作用域的 bean 方式如下：\n错误示例：\njava 1 2 3 4 5 6 7 8 9 10 11 12 13 14 @Component @Scope(value = WebApplicationContext.SCOPE_REQUEST, proxyMode = ScopedProxyMode.TARGET_CLASS) public class RequestBean { //... } public class SingletonBean { @Autowired private final RequestBean requestBean; // Noncompliant, the same instance of RequestBean is used for each HTTP request. public RequestBean getRequestBean() { return requestBean; } } 正确示例：\njava 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @Component @Scope(value = WebApplicationContext.SCOPE_REQUEST, proxyMode = ScopedProxyMode.TARGET_CLASS) public class RequestBean { //... } public class SingletonBean { private final ObjectFactory\u0026lt;RequestBean\u0026gt; requestBeanFactory; @Autowired public SingletonBean(ObjectFactory\u0026lt;RequestBean\u0026gt; requestBeanFactory) { this.requestBeanFactory = requestBeanFactory; } public RequestBean getRequestBean() { return requestBeanFactory.getObject(); } } References Bean Scopes :: Spring Framework Quick Guide to Spring Bean Scopes | Baeldung Spring Bean Scope 指南 - spring 中文网 (springdoc.cn) ","permalink":"https://tofuwine.github.io/posts/4e4e186a/","summary":"Spring Bean 六种作用域分析","title":"Spring Bean Scope 解析"},{"content":"1994 年，Linux 引入了文件系统层次标准（FHS，Filesystem Hierarchy Standard）。通过实施 FHS 这样的标准，软件可以确保在不同 Linux 发行版中采用一致的布局。不过，并非所有 Linux 发行版都严格遵守这一标准。它们通常会加入自己独特的元素或迎合特定的要求。\n要熟练掌握这一标准，可以从探索开始。使用 cd 等命令进行导航，使用 ls 命令列出目录内容。将文件系统想象成一棵树，从根目录 / 开始。\n目录 介绍 补充 / 根目录 根目录是 Linux 文件系统中的顶级目录。 所有其他目录都是根目录的子目录，使其成为整个文件系统的父目录。 /bin 包含启动系统和执行基本操作所需的基本二进制可执行文件。 这些对所有用户都可用。 /boot 保存启动系统所需的文件。 包括 Linux 内核、初始 RAM 磁盘映像（用于启动时所需的驱动程序）和引导加载程序配置文件（如 GRUB）。 /dev 包含代表硬件组成或其他系统设备的设备文件。 例如，/dev/sda 代表第一个 SATA 驱动器，/dev/tty 代表终端。 /etc 存储系统和应用程序的配置文件。 这些文件通常是可以编辑的文本文件，用于更改系统或应用程序的行为。 /home 包含系统上所有有账户的用户的个人目录，根用户除外。 用户特定的设置和文件存储在此处。 /lib 包含系统和应用程序运行所需的基本共享库和内核模块。 /media /mnt 用于挂载可移动媒体（如 USB 驱动器）和临时挂载的文件系统的目录。 /opt 用于安装附加的应用软件包。 它是安装第三方应用程序的地方，将它们与 /usr 中的系统默认应用程序分开。 /proc 一个虚拟文件系统，为内核向进程发送信息提供了一种机制。 它不包含真实文件，而是运行时系统信息（例如，系统内存、挂载的设备、硬件配置等）。 /sbin 包含基本的系统二进制文件。 类似 /bin，但用于系统管理任务，通常对非特权用户不可访问。 /tmp 一个临时目录，应用程序可以在其中存储临时文件。 它通常在重启或间隔一段时间后被清空。 /usr 承载用户应用程序和大量系统内容。 它包含程序、库、文档等的子目录，这些不是启动或修复系统所必需的。 /var 包含变量数据文件。 这个目录包括系统在操作过程中写入数据的文件，如日志（/var/log）、邮件（/var/mail）和打印队列（/var/spool）等。 ","permalink":"https://tofuwine.github.io/posts/715f7034/","summary":"1994 年，Linux 引入了文件系统层次标准（FHS，Filesystem Hierarchy Standard）。通过实施 FHS 这样的标准，软件可以确保在不同 Linux 发行版中采用一致的布局。不过，并非所有 Linux 发行版都严格遵守这一标准。它们通常会加入自己独特的元素或迎合特定的要求。\n要熟练掌握这一标准，可以从探索开始。使用 cd 等命令进行导航，使用 ls 命令列出目录内容。将文件系统想象成一棵树，从根目录 / 开始。\n目录 介绍 补充 / 根目录 根目录是 Linux 文件系统中的顶级目录。 所有其他目录都是根目录的子目录，使其成为整个文件系统的父目录。 /bin 包含启动系统和执行基本操作所需的基本二进制可执行文件。 这些对所有用户都可用。 /boot 保存启动系统所需的文件。 包括 Linux 内核、初始 RAM 磁盘映像（用于启动时所需的驱动程序）和引导加载程序配置文件（如 GRUB）。 /dev 包含代表硬件组成或其他系统设备的设备文件。 例如，/dev/sda 代表第一个 SATA 驱动器，/dev/tty 代表终端。 /etc 存储系统和应用程序的配置文件。 这些文件通常是可以编辑的文本文件，用于更改系统或应用程序的行为。 /home 包含系统上所有有账户的用户的个人目录，根用户除外。 用户特定的设置和文件存储在此处。 /lib 包含系统和应用程序运行所需的基本共享库和内核模块。 /media /mnt 用于挂载可移动媒体（如 USB 驱动器）和临时挂载的文件系统的目录。 /opt 用于安装附加的应用软件包。 它是安装第三方应用程序的地方，将它们与 /usr 中的系统默认应用程序分开。 /proc 一个虚拟文件系统，为内核向进程发送信息提供了一种机制。 它不包含真实文件，而是运行时系统信息（例如，系统内存、挂载的设备、硬件配置等）。 /sbin 包含基本的系统二进制文件。 类似 /bin，但用于系统管理任务，通常对非特权用户不可访问。 /tmp 一个临时目录，应用程序可以在其中存储临时文件。 它通常在重启或间隔一段时间后被清空。 /usr 承载用户应用程序和大量系统内容。 它包含程序、库、文档等的子目录，这些不是启动或修复系统所必需的。 /var 包含变量数据文件。 这个目录包括系统在操作过程中写入数据的文件，如日志（/var/log）、邮件（/var/mail）和打印队列（/var/spool）等。 ","title":"Linux 文件系统的组成"},{"content":" 每个命令独占一行，一个注释下面两行命令即代表这两个命令为同一作用。\n查看系统相关信息 bash 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 # 显示机器的处理器架构 uname -m # 显示正在使用的内核版本 uname -r # 显示 CPU info 信息 cat /proc/cpuinfo # 显示中断 cat /proc/interrupts # 显示哪些 swap 被使用 cat /proc/swaps # 显示内存使用 cat /proc/meminfo # 显示内核版本 cat /proc/version # 显示网络适配器及统计 cat /proc/net/dev # 显示已加载的文件系统 cat /proc/mounts # 显示系统日期 date # 显示系统运行时间 uptime 关机、注销、重启 bash 1 2 3 4 5 6 7 8 9 # 关机 shutdown -h now # 注销 logout # 重启 shutdown -r now reboot 文件和目录 bash 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 # 进行 `/home` 目录 cd /home # 返回上一级目录 cd .. # 返回上两级目录 cd ../.. # 进入个人的主目录 cd cd ~ # 进入 user1 的主目录 cd ~user1 # 返回上次所在目录 cd - # 显示当前工作目录 pwd # 查看目录中的文件 ls # 查看目录中文件并标记每个项目的类型 ls -F # 递归显示子目录结构 ls -R # 查看文件和目录的详细信息 ls -l # 显示隐藏文件 ls -a # 显示目录和链接信息 ls -ld # 显示包含数字的文件名和目录名 ls *[0-9]* # 创建目录 `dir1` mkdir dir1 # 同时创建目录 `dir1` 和 `dir2` mkdir dir1 dir2 # 创建层级目录 (目录树) mkdir -p /tmp/dir1/dir2 # 删除文件 `file1` rm -f file1 # 删除目录 `dir1` rmdir dir1 # 递归地强制删除 `dir1` 目录 (包括其下所有的文件和子目录) rm -rf dir1 # 同时递归地强制删除 `dir1` 和 `dir2` 两个目录 rm -rf dir1 dir2 # 重命名/移动 一个目录 mv dir1 newdir # 复制一个文件 cp file1 file2 # 复制一个目录下的所有文件到当前工作目录 cp dir/* . # 复制一个目录到当前工作目录 cp -a /tmp/dir1 . # 复制一个目录 cp -a dir2 dir2 # 创建一个指向文件或目录的软链接 ln -s file1 lnk1 # 创建一个指向文件或目录的物理链接 ln file1 lnk1 # 修改一个文件或目录的时间戳 (格式为: YYMMDDhhmm) touch -t 2403081030 file1 文件搜索 bash 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 # 从 `/` 目录搜索名为 file1 的文件和目录 find / -name file1 # 搜索属于用户 `user1` 的文件和目录 find / -user user1 # 在目录 `/home/user1` 中搜索带有 `.bin` 结尾的文件 find /home/user1 -name \\*.bin # 搜索在过去 100 天内未被使用过的执行文件 find /usr/bin -type f -atime +100 # 搜索在 10 天内被创建或修改过的文件 find /usr/bin -type f -mtime -10 # 搜索以 `.rpm` 结尾的文件并定义其权限 find / -name \\*.rpm -exec chmod 755 \u0026#39;{}\u0026#39; \\; # 搜索以 `.rpm` 结尾的文件, 忽略光驱等可移动设备 find / -xdev -name \\*.rpm # 显示一个二进制文件、原码或 man 的位置 whereis halt # 显示一个二进制文件或可执行文件的完整路径 which halt # 寻找以 `.ps` 结尾的文件 (先执行 updatedb 命令) locate \\*.ps 磁盘空间 bash 1 2 3 4 5 6 7 8 9 10 11 # 显示已挂载的分区列表 df -h # 以尺寸大小排列文件和目录 ls -lSr | more # 估算目录 `dir1` 已经使用的磁盘空间 du -sh dir1 # 以容量大小为依据依次显示文件和目录的大小 du -sk * | sort -rn 用户和群组 bash 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 # 创建新用户组 `docker` groupadd docker # 删除用户组 `docker` groupdel docker # 重命名用户组 `docker` 为 `docker0` groupmod -n docker0 docker # 创建新用户 `user1` useradd user1 # 删除用户 `user1` userdel user1 # 创建一个属于 `docker` 用户组的用户 (-c 为用户全名, -d 指定 home 目录, -s 指定登录 shell 为 /bin/bash) useradd -c \u0026#34;Custom user1\u0026#34; -g docker -d /home/user1 -s /bin/bash user # 修改用户属性 usermode -c \u0026#34;User FTP\u0026#34; -g system -d /ftp/user1 -s /bin/nologin user1 # 修改口令 passwd # 修改 `user1` 的口令 (只允许 root 执行) passwd user1 # 设置用户口令失效期限 chage -E 2025-12-31 user1 文件权限 使用 + 设置权限，使用 - 用于取消\nbash 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 # 显示权限 ls -lh # 改变文件 `file1` 的所有人 chown user1 file1 # 改变文件 `file1` 的群组 chgrp group1 file1 # 改变文件 `file1` 的所有人和群组 chown user1:group1 file1 # 改变目录 `dir1` 的所有人属性并同时改变目录下所有文件的属性 chown -R user1 dir1 # 设置目录 `dir1` 的所有人(u)、群组(g) 以及其他人(o) 以读(r)、写(w)和执行(x)的权限 chmod ugo+rwx dir1 # 删除群组(g) 与其他人(o) 对目录的读(r)、写(w)、执行权限(x) chmod go-rwx dir1 # 为所有者、所属组和其他用户添加 `file1` 的执行权限 chmod +x /tmp/file1 # 为所有者、所属组和其他用户删除 `file1` 的执行权限 chmod -x /tmp/file1 # 为所有者添加 `file1` 的执行权限 chmod u+x /tmp/file1 # 为所属组添加 `file1` 的执行权限 chmod g+x /tmp/file1 # 为其他用户添加 `file1` 的执行权限 chmod o+x /tmp/file1 # 为所有者、所属组添加 `file1` 的执行权限 chmod ug+x # 为所有者、所属组和其他用户添加 `file1` 的写、执行权限, 取消读权限 chmod =wx /tmp/file1 # 为所有者、所属组添加 `file1` 的写、执行权限, 取消读权限 chmod ug=wx /tmp/file1 文件特殊属性 使用 + 设置权限，使用 - 用于取消\nbash 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # 只允许以追加方式读写文件 chattr +a file1 # 允许这个文件能被内核自动压缩/解压 chattr +c file1 # 在进行文件系统备份时, dump 程序将忽略该文件 chattr +d file1 # 设置成不可变的文件，不能被删除、修改、重命名或链接 chattr +i file1 # 允许一个文件被安全地删除 chattr +s file1 # 一旦应用程序对这个文件执行了写操作, 使系统立刻把修改结果写道磁盘 chattr +S file1 # 若文件被删除, 系统会允许在以后恢复这个被删除的文件 chattr +u file1 # 显示特殊属性 lsattr 打包和压缩 tar bash 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 # 创建 `archive.tar` 压缩文件, 其中包含了 `file1` tar -cvf archive.tar file1 # 创建 `archive.tar` 压缩文件, 其中包含了 `file1`、`file2`、`dir1` tar -cvf archive.tar file1 file2 dir1 # 显示压缩包 `archive.rar` 中的内容 tar -tf archive.tar # 解压 `archive.tar` tar -xvf archive.tar # 解压 `archive.tar` 到 `/tmp` 目录下 tar -xvf archive.tar -C /tmp # 创建 bzip2 格式的压缩包 tar -cvfj archive.tar.bz2 dir1 # 解压 bzip2 格式的压缩包 tar -xcvfj archive.tar.bz2 # 创建 gzip 格式的压缩包 tar -cvfz archive.tar.gz # 解压 gzip 格式的压缩包 tar -xvfz archive.tar.gz zip bash 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # 创建 zip 格式的压缩包, 包含 file1 zip archive.zip file1 # 创建 zip 格式压缩包, 同时包含 file1、file2、dir1 zip -r archive.zip file1 file2 dir1 # 解压 zip 格式压缩包 unzip archive.zip # 压缩 `file1` 文件 (bzip2 格式) bzip2 file1 # 解压 bzip2 格式文件 bunzip2 file1.bz2 # 压缩 `file1` 文件 (gzip 格式) gzip file1 # 最大程度压缩 gzip -9 file1 # 解压 gzip 格式文件 gunzip file1.gz 查看文件内容 bash 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 从第一个字节开始正向查看文件内容 cat file1 # 从最后一个字节反向查看文件内容 tac file1 # 查看长文件内容 more file1 # 查看文件的前两行 head -2 file1 # 查看文件的最后两行 tail -2 file1 # 实时查看文件内容 tail -f /var/log/info.log 文本处理 bash 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 # 在文件中查找关键字 `Aug` grep Aug /var/log/info.log # 在文件中查找以 `Aug` 开头的单词 grep ^Aug /var/log/info.log # 在文件中查找所有包含数字的行 grep [0-9] /var/log/info.log # 在目录 `/var/log` 及随后的目录中搜索字符串 `Aug` grep Aug -R /var/log/* # 将文本中的 `str1` 替换成 `str2` sed \u0026#39;s/str1/str2/g\u0026#39; test.txt # 删除文件中的空白行 sed \u0026#39;/^$/d\u0026#39; test.txt # 删除文件中所有注释和空白行 sed \u0026#39;/ *#/d; /^$/d\u0026#39; test.txt # 从文件中排除第一行 sed -e \u0026#39;1d\u0026#39; test.txt # 查看只包含 `str1` 的行 sed -n \u0026#39;/str1/p\u0026#39; # 删除每一行最后的空白字符 sed -e \u0026#39;s/ *$//\u0026#39; test.txt # 从文件中删除词汇 `str1` 并保留剩余全部 sed -e \u0026#39;s/str1//g\u0026#39; test.txt # 查看第 1 行到第 5 行内容 sed -n \u0026#39;1,5p;5q\u0026#39; test.txt # 用单个 0 替换多个 0 sed -e \u0026#39;s/00*/0g\u0026#39; test.txt # 标示文件的行数 cat -n file1 # 删除 file.txt 文件中的所有偶数行 cat file.txt | awk \u0026#39;NR%2==1\u0026#39; # 查看合并两个文件的内容 paste file1 file2 # 合并两个文件的内容, 中间用 `+` 区分 paste -d \u0026#39;+\u0026#39; file1 file2 # 排序两个文件的内容 sort file1 file2 # 取出两个文件的并集 (重复的行只保留一份) sort file1 file2 | uniq # 删除交集, 留下其他行 sort file1 file2 | uniq -u # 取出两个文件的交集 (只保留两个文件都有的内容) sort file1 file2 | uniq -d # 比较两个文件的内容, 只删除 `file1` 所包含的内容 comm -1 file1 file2 # 比较两个文件的内容, 只删除 `file2` 所包含的内容 comm -2 file1 file2 # 比较两个文件的内容, 只删除两个文件共有的内容 comm -3 file1 file2 字符设置和文件格式转换 bash 1 2 3 4 5 # 将文件由 MSDOS 转为 UNIX dos2unix filedos.txt fileunix.txt # 将文件由 UNIX 转为 MSDOS unix2dos fileunix.txt filedos.txt 软件包管理 RPM RedHat Package Manager (RedHat 软件包管理工具)。主要应用于 RedHat 系列包括 Fedora 等发行版的 Linux 系统上（redhat、centos、fedora等）\nbash 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # 安装 rpm 包 rpm -ivh package.rpm # 安装 rpm 包, 忽略依赖关系警告 rpm -ivh --nodeeps package.rpm # 更新 rpm 包但不改变其配置文件 rpm -U package.rpm # 更新已经安装的 rpm 包 rpm -F package.rpm # 删除 rpm 包 rpm -e package.rpm # 显示系统中所有已经安装的 rpm 包 rpm -qa # 显示所有名称中包含 `httpd` 的 rpm 包 rpm -qa | grep httpd YUM bash 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 安装 rpm 包 yum install \u0026lt;package\u0026gt; # 更新 rpm 包 yum update \u0026lt;package\u0026gt; # 卸载 rpm 包 yum remove \u0026lt;package\u0026gt; # 升级所有已安装的 rpm 包 yum upgrade # 列出所有安装的 rpm 包 yum list # 清理 YUM 缓存 yum clean \u0026lt;all|packages|headers|metadata|dbcache|plugins|expire-cache\u0026gt; DEB Debian Packager。主要应用于 Debian 系列包括 Ubuntu 等发型版本（debian、ubuntu 等）\nbash 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 安装指定的 DEB 软件包 dpkg -i \u0026lt;package.deb\u0026gt; # 卸载指定的软件包 dpkg -r \u0026lt;package\u0026gt; # 完全移除指定的软件包 (包括配置文件) dpkg -P \u0026lt;package\u0026gt; # 列出所有已安装的软件包 dpkg -l # 重新配置已安装的软件包 dpkg-reconfigure \u0026lt;package\u0026gt; APT Advanced Package Tool\nbash 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # 安装指定的软件包及其依赖 apt-get install \u0026lt;package\u0026gt; # 卸载指定的软件包 apt-get remove \u0026lt;package\u0026gt; # 完全移除指定的软件包 (包括配置文件) apt-get purge \u0026lt;package\u0026gt; # 更新软件包索引列表 apt-get update # 升级所有已安装的软件包 apt-get upgrade # 清理旧版本的软件包 apt-get autoclean # 自动删除不再需要的软件包 apt-get autoremove # 清理缓存 apt-get clean ","permalink":"https://tofuwine.github.io/posts/d45b9098/","summary":"常用 Linux 命令集合","title":"常用 Linux 命令"},{"content":" 温馨提示 本文采用 KaTex 渲染数学公式。 基本语法 Markdown 数学公式：使用 $。\n内联显示将数学公式写在 $...$ 之间。块显示则将数学公式写在 $$...$$ 之间。\n常用符号 上下标 算式 markdown \\$a_0\\$, \\$a_{pre}\\$ a_0, a_{pre} \\$a^0\\$, \\$a^{[0]}\\$ a^0, a^{[0]} 括号 算式 markdown \\$(\\$, \\$)\\$ (, ) \\$[\\$, \\$]\\$ [, ] \\$\\lang\\$, \\$\\rang\\$ \\lang, \\rang 或 \\langle, \\rangle \\$\\lvert\\$, \\$\\rvert\\$ \\lvert, \\rvert \\$\\lVert\\$, \\$\\rVert\\$ \\lVert, \\rVert \\$\\lbrace\\$, \\$\\rbrace\\$ \\lbrace, \\rbrace 或\\{, \\} 增大括号方法 算式 markdown \\$(x)\\$ (x) \\$\\big( x \\big)\\$ \\big( x \\big) \\$\\Big( x \\Big)\\$ \\Big( x \\Big) \\$\\bigg( x \\bigg)\\$ \\bigg( x \\bigg) \\$\\Bigg( x \\Bigg)\\$ \\Bigg( x \\Bigg) 其他的大括号 算式 markdown \\$\\Bigg(\\bigg(\\Big(\\big((x)\\big)\\Big)\\bigg)\\Bigg)\\$ \\Bigg(\\bigg(\\Big(\\big((x)\\big)\\Big)\\bigg)\\Bigg) \\$\\Bigg[\\bigg[\\Big[\\big[[x]\\big]\\Big]\\bigg]\\Bigg]\\$ \\Bigg[\\bigg[\\Big[\\big[[x]\\big]\\Big]\\bigg]\\Bigg] \\$\\Bigg \\langle \\bigg \\langle \\Big \\langle\\big\\langle\\langle x \\rangle \\big \\rangle\\Big\\rangle\\bigg\\rangle\\Bigg\\rangle\\$ \\Bigg \\langle \\bigg \\langle \\Big \\langle\\big\\langle\\langle x \\rangle \\big \\rangle\\Big\\rangle\\bigg\\rangle\\Bigg\\rangle \\$\\Bigg\\lvert\\bigg\\lvert\\Big\\lvert\\big\\lvert\\lvert x \\rvert\\big\\rvert\\Big\\rvert\\bigg\\rvert\\Bigg\\rvert\\$ \\Bigg\\lvert\\bigg\\lvert\\Big\\lvert\\big\\lvert\\lvert x \\rvert\\big\\rvert\\Big\\rvert\\bigg\\rvert\\Bigg\\rvert \\$\\Bigg\\lVert\\bigg\\lVert\\Big\\lVert\\big\\lVert\\lVert x \\rVert\\big\\rVert\\Big\\rVert\\bigg\\rVert\\Bigg\\rVert\\$ \\Bigg\\lVert\\bigg\\lVert\\Big\\lVert\\big\\lVert\\lVert x \\rVert\\big\\rVert\\Big\\rVert\\bigg\\rVert\\Bigg\\rVert 分数 算式 markdown \\$\\frac{a}{b}\\$ \\frac{a}{b} 开方 算式 markdown \\$\\sqrt{a + b}\\$ \\sqrt{a + b} \\$\\sqrt[n]{a + b}\\$ \\sqrt[n]{a + b} 累加/累乘 算式 markdown \\$\\sum_{i = 0}^{n}\\frac{1}{i^2}\\$ \\sum_{i = 0}{n}\\frac{1}{i2} \\$\\prod_{i = 0}^{n}\\frac{1}{x^2}\\$ \\prod_{i = 0}{n}\\frac{1}{x2} 三角函数 算式 markdown \\$\\sin\\$ \\sin \\$\\cos\\$ \\cos \\$\\tan\\$ \\tan \\$\\cot\\$ \\cot \\$\\sec\\$ \\sec \\$\\csc\\$ \\csc \\$\\bot\\$ \\bot \\$\\angle\\$ \\angle \\$40^\\circ\\$ 40^\\circ 对数函数 算式 markdown \\$\\ln{a + b}\\$ \\ln{a + b} \\$\\log_{a}^{b}\\$ \\log_{a}^{b} \\$\\lg{a + b}\\$ \\lg{a + b} 二元运算符 算式 markdown 描述 算式 markdown 描述 \\$\\pm\\$ \\pm 正负号 \\$\\triangleleft\\$ \\triangleleft \\$\\mp\\$ \\mp \\$\\triangleright\\$ \\triangleright \\$\\times\\$ \\times 乘号 \\$\\lhd\\$ \\lhd \\$\\div\\$ \\div 除号 \\$\\rhd\\$ \\rhd \\$\\ast\\$ \\ast \\$\\unlhd\\$ \\unlhd \\$\\star\\$ \\star \\$\\unrhd\\$ \\unrhd \\$\\mid\\$ \\mid \\$\\bigcirc\\$ \\bigcirc \\$\\nmid\\$ \\nmid \\$\\odot\\$ \\odot \\$\\circ\\$ \\circ \\$\\bigodot\\$ \\bigodot \\$\\bullet\\$ \\bullet \\$\\oslash\\$ \\oslash \\$\\cdot\\$ \\cdot \\$\\ominus\\$ \\ominus \\$\\wr\\$ \\wr \\$\\otimes\\$ \\otimes \\$\\diamond\\$ \\diamond \\$\\bigotimes\\$ \\bigotimes \\$\\Diamond\\$ \\Diamond \\$\\oplus\\$ \\oplus \\$\\triangle\\$ \\triangle \\$\\bigoplus\\$ \\bigoplus \\$\\bigtriangleup\\$ \\bigtriangleup \\$\\dagger\\$ \\dagger \\$\\bigtriangledown\\$ \\bigtriangledown \\$\\ddagger\\$ \\ddagger \\$\\amalg\\$ \\amalg 关系符号 算式 markdown 描述 算式 markdown 描述 \\$\\leq\\$ \\leq 小于等于 \\$\\models\\$ \\models \\$\\geq\\$ \\geq 大于等于 \\$\\prec\\$ \\prec \\$\\equiv\\$ \\equiv \\$\\succ\\$ \\succ \\$\\sim\\$ \\sim \\$\\perp\\$ \\perp \\$\\preceq\\$ \\preceq \\$\\succeq\\$ \\succeq \\$\\simeq\\$ \\simeq \\$\\mid\\$ \\mid \\$\\ll\\$ \\ll \\$\\gg\\$ \\gg \\$\\asymp\\$ \\asymp \\$\\parallel\\$ \\parallel \\$\\approx\\$ \\approx 约等于 \\$\\cong\\$ \\cong \\$\\neq\\$ \\neq 不等于 \\$\\doteq\\$ \\doteq \\$\\propto\\$ \\propto \\$\\bowtie\\$ \\bowtie \\$\\Join\\$ \\Join \\$\\smile\\$ \\smile \\$\\frown\\$ \\frown \\$\\vdash\\$ \\vdash \\$\\dashv\\$ \\dashv 极限 算式 markdown \\$\\lim\\$ \\lim \\$\\rightarrow\\$ \\rightarrow 或 \\to \\$\\infty\\$ \\infty \\$\\lim_{n \\to +\\infty}n\\$ \\lim_{n \\to +\\infty}n 向量 算式 markdown \\$\\vec{a}\\$ \\vec{a} 箭头 算式 markdown 描述 算式 markdown 描述 \\$\\uparrow\\$ \\uparrow \\$\\downarrow\\$ \\downarrow \\$\\updownarrow\\$ \\updownarrow \\$\\Uparrow\\$ \\Uparrow \\$\\Downarrow\\$ \\Downarrow \\$\\Updownarrow\\$ \\Updownarrow \\$\\rightarrow\\$ \\rightarrow \\$\\leftarrow\\$ \\leftarrow \\$\\leftrightarrow\\$ \\leftrightarrow \\$\\Rightarrow\\$ \\Rightarrow \\$\\Leftarrow\\$ \\Leftarrow \\$\\Leftrightarrow\\$ \\Leftrightarrow \\$\\longrightarrow\\$ \\longrightarrow \\$\\longleftarrow\\$ \\longleftarrow \\$\\longleftrightarrow\\$ \\longleftrightarrow \\$\\Longrightarrow\\$ \\Longrightarrow \\$\\Longleftarrow\\$ \\Longleftarrow \\$\\Longleftrightarrow\\$ \\Longleftrightarrow \\$\\mapsto\\$ \\mapsto \\$\\longmapsto\\$ \\longmapsto \\$\\hookleftarrow\\$ \\hookleftarrow \\$\\hookrightarrow\\$ \\hookrightarrow \\$\\rightharpoonup\\$ \\rightharpoonup \\$\\leftharpoondown\\$ \\leftharpoondown \\$\\rightleftharpoons\\$ \\rightleftharpoons \\$\\leftharpoonup\\$ \\leftharpoonup \\$\\rightharpoondown\\$ \\rightharpoondown \\$\\leadsto\\$ \\leadsto \\$\\nearrow\\$ \\nearrow \\$\\searrow\\$ \\searrow \\$\\swarrow\\$ \\swarrow \\$\\nwarrow\\$ \\nwarrow 集合 算式 markdown 描述 算式 markdown 描述 \\$\\emptyset\\$ \\emptyset \\$\\in\\$ \\in \\$\\ni\\$ \\ni \\$\\notin\\$ \\notin \\$\\subset\\$ \\subset \\$\\supset\\$ \\supset \\$\\not\\subset\\$ \\not\\subset \\$\\subseteq\\$ \\subseteq \\$\\supseteq\\$ \\supseteq \\$\\cup\\$ \\cup \\$\\bigcup\\$ \\bigcup \\$\\cap\\$ \\cap \\$\\bigcap\\$ \\bigcap \\$\\uplus\\$ \\uplus \\$\\biguplus\\$ \\biguplus \\$\\sqsubset\\$ \\sqsubset \\$\\sqsupset\\$ \\sqsupset \\$\\sqcap\\$ \\sqcap \\$\\sqsubseteq\\$ \\sqsubseteq \\$\\sqsupseteq\\$ \\sqsupseteq \\$\\vee\\$ \\vee \\$\\wedge\\$ \\wedge \\$\\setminus\\$ \\setminus 微积分 算式 markdown \\$\\prime\\$ \\prime \\$\\int\\$ \\int \\$\\iint\\$ \\iint \\$\\iiint\\$ \\iiint \\$\\oint\\$ \\oint \\$\\nabla\\$ \\nabla \\$\\int_0^2 x^2 dx\\$ \\int_0^2 x^2 dx 逻辑运算 算式 markdown \\$\\because\\$ \\because \\$\\therefore\\$ \\therefore \\$\\forall\\$ \\forall \\$\\exist\\$ \\exist \\$\\vee\\$ \\vee \\$\\wedge\\$ \\wedge \\$\\bigvee\\$ \\bigvee \\$\\bigwedge\\$ \\bigwedge 上下标符号 算式 markdown \\$\\bar{a}\\$ \\bar{a} \\$\\acute{a}\\$ \\acute{a} \\$\\breve{a}\\$ \\breve{a} \\$\\grave{a}\\$ \\grave{a} \\$\\dot{a}\\$ \\dot{a} \\$\\ddot{a}\\$ \\ddot{a} \\$\\hat{a}\\$ \\hat{a} \\$\\check{a}\\$ \\check{a} \\$\\breve{a}\\$ \\breve{a} \\$\\tilde{a}\\$ \\tilde{a} \\$\\vec{a}\\$ \\vec{a} \\$\\overline{a + b + c + d}\\$ \\overline{a + b + c + d} \\$\\underline{a + b + c + d}\\$ \\underline{a + b + c + d} \\$\\overbrace{a + b + c + d}\\$ \\overbrace{a + b + c + d} \\$\\underbrace{a + b + c + d}\\$ \\underbrace{a + b + c + d} \\$\\overbrace{a + \\underbrace{b + c}_{1.0} + d}^{2.0}\\$ \\overbrace{a + \\underbrace{b + c}_{1.0} + d}^{2.0} 希腊字母 大写 markdown 小写 markdown \\$\\Alpha\\$ \\Alpha \\$\\alpha\\$ \\alpha \\$\\Beta\\$ \\Beta \\$\\beta\\$ \\beta \\$\\Gamma\\$ \\Gamma \\$\\gamma\\$ \\gamma \\$\\Delta\\$ \\Delta \\$\\delta\\$ \\delta \\$\\Epsilon\\$ \\Epsilon \\$\\epsilon\\$ \\epsilon \\$\\varepsilon\\$ \\varepsilon \\$\\Zeta\\$ \\Zeta \\$\\zeta\\$ \\zeta \\$\\Eta\\$ \\Eta \\$\\eta\\$ \\eta \\$\\Theta\\$ \\Theta \\$\\theta\\$ \\theta \\$\\Iota\\$ \\Iota \\$\\iota\\$ \\iota \\$\\Kappa\\$ \\Kappa \\$\\kappa\\$ \\kappa \\$\\Lambda\\$ \\Lambda \\$\\lambda\\$ \\lambda \\$\\Mu\\$ \\Mu \\$\\mu\\$ \\mu \\$\\Nu\\$ \\Nu \\$\\nu\\$ \\nu \\$\\Xi\\$ \\Xi \\$\\xi\\$ \\xi \\$\\Omicron\\$ \\Omicron \\$\\omicron\\$ \\omicron \\$\\Pi\\$ \\Pi \\$\\pi\\$ \\pi \\$\\Rho\\$ \\Rho \\$\\rho\\$ \\rho \\$\\Sigma\\$ \\Sigma \\$\\sigma\\$ \\sigma \\$\\Tau\\$ \\Tau \\$\\tau\\$ \\tau \\$\\Upsilon\\$ \\Upsilon \\$\\upsilon\\$ \\upsilon \\$\\Phi\\$ \\Phi \\$\\phi\\$ \\phi \\$\\varphi\\$ \\varphi \\$\\Chi\\$ \\Chi \\$\\chi\\$ \\chi \\$\\Psi\\$ \\Psi \\$\\psi\\$ \\psi \\$\\Omega\\$ \\Omega \\$\\omega\\$ \\omega 省略号 算式 markdown \\$\\dots\\$ \\dots \\$\\ldots\\$ \\ldots \\$\\cdots\\$ \\cdots \\$\\vdots\\$ \\vdots \\$\\ddots\\$ \\ddots 例子如下：\nmarkdown 1 2 3 $$ x_1, x_2, \\dots, x_n \\quad \\quad 1, 2, \\cdots, n \\quad \\quad \\vdots \\quad \\quad \\ddots $$ $$ x_1, x_2, \\dots, x_n \\quad \\quad 1, 2, \\cdots, n \\quad \\quad \\vdots \\quad \\quad \\ddots $$ 空格 算式 markdown 描述 \\$123\\!123\\$ 123\\!123 空格距离：-3/18 em \\$123\\,123\\$ 123\\,123 空格距离：3/18 em \\$123\\:123\\$ 123\\:123 空格距离：4/18 em \\$123\\ 123\\$ 123\\;123 or 123\\ 123 空格距离：5/18 em \\$123\\quad123\\$ 123\\quad123 空格距离：1 em \\$123\\qquad123\\$ 123\\qquad123 空格距离：2 em 上表中的 em 是指当前文本中文本的字体尺寸\n其他符号 算式 markdown 算式 markdown 算式 markdown \\$\\aleph\\$ \\aleph \\$\\hbar\\$ \\hbar \\$\\imath\\$ \\imath \\$\\jmath\\$ \\jmath \\$\\ell\\$ \\ell \\$\\wp\\$ \\wp \\$\\Re\\$ \\Re \\$\\Im\\$ \\Im \\$\\mho\\$ \\mho \\$\\nabla\\$ \\nabla \\$\\surd\\$ \\surd \\$\\top\\$ \\top \\$\\bot\\$ \\bot \\$\\neg\\$ \\neg \\$\\flat\\$ \\flat \\$\\natural\\$ \\natural \\$\\sharp\\$ \\sharp \\$\\backslash\\$ \\backslash \\$\\partial\\$ \\partial \\$\\Box\\$ \\Box \\$\\clubsuit\\$ \\clubsuit \\$\\diamondsuit\\$ \\diamondsuit \\$\\heartsuit\\$ \\heartsuit \\$\\spadesuit\\$ \\spadesuit \\$\\lceil\\$ \\lceil \\$\\rceil\\$ \\rceil \\$\\lfloor\\$ \\lfloor \\$\\rfloor\\$ \\rfloor 公式 分支公式 markdown 1 2 3 4 5 6 7 8 $$ y= \\begin{cases} -x,\\quad x\\leq 0\\\\ x, \\quad x\u0026gt;0 \\end{cases} \\tag{1} $$ $$ y= \\begin{cases} -x,\\quad x\\leq 0\\\\ x, \\quad x\u003e0 \\end{cases} \\tag{1} $$ 矩阵 不带括号 markdown 1 2 3 4 5 6 7 8 $$ \\begin{matrix} 1 \u0026amp; 2 \u0026amp; 3 \\\\ 4 \u0026amp; 5 \u0026amp; 6 \\\\ 7 \u0026amp; 8 \u0026amp; 9 \\end{matrix} \\tag{1} $$ $$ \\begin{matrix} 1 \u0026 2 \u0026 3 \\\\ 4 \u0026 5 \u0026 6 \\\\ 7 \u0026 8 \u0026 9 \\end{matrix} \\tag{1} $$ 括号 markdown 1 2 3 4 5 6 7 8 9 10 $$ \\left( \\begin{matrix} 1 \u0026amp; 2 \u0026amp; 3 \\\\ 4 \u0026amp; 5 \u0026amp; 6 \\\\ 7 \u0026amp; 8 \u0026amp; 9 \\end{matrix} \\right) \\tag{2} $$ $$ \\left( \\begin{matrix} 1 \u0026 2 \u0026 3 \\\\ 4 \u0026 5 \u0026 6 \\\\ 7 \u0026 8 \u0026 9 \\end{matrix} \\right) \\tag{2} $$ 中括号 markdown 1 2 3 4 5 6 7 8 9 10 $$ \\left[ \\begin{matrix} 1 \u0026amp; 2 \u0026amp; 3 \\\\ 4 \u0026amp; 5 \u0026amp; 6 \\\\ 7 \u0026amp; 8 \u0026amp; 9 \\end{matrix} \\right] \\tag{3} $$ $$ \\left[ \\begin{matrix} 1 \u0026 2 \u0026 3 \\\\ 4 \u0026 5 \u0026 6 \\\\ 7 \u0026 8 \u0026 9 \\end{matrix} \\right] \\tag{3} $$ 大括号 markdown 1 2 3 4 5 6 7 8 9 10 $$ \\left\\{ \\begin{matrix} 1 \u0026amp; 2 \u0026amp; 3 \\\\ 4 \u0026amp; 5 \u0026amp; 6 \\\\ 7 \u0026amp; 8 \u0026amp; 9 \\end{matrix} \\right\\} \\tag{4} $$ $$ \\left\\{ \\begin{matrix} 1 \u0026 2 \u0026 3\\\\ 4 \u0026 5 \u0026 6 \\\\ 7 \u0026 8 \u0026 9 \\end{matrix} \\right\\} \\tag{4} $$ 带省略号 markdown 1 2 3 4 5 6 7 8 9 10 11 $$ \\left\\{ \\begin{matrix} a \u0026amp; a \u0026amp; \\cdots \u0026amp; a \\\\ b \u0026amp; b \u0026amp; \\cdots \u0026amp; b \\\\ \\vdots \u0026amp; \\vdots \u0026amp; \\ddots \u0026amp; \\vdots \\\\ c \u0026amp; c \u0026amp; \\cdots \u0026amp; c \\end{matrix} \\right\\} \\tag{5} $$ $$ \\left\\{ \\begin{matrix} a \u0026 a \u0026 \\cdots \u0026 a\\\\ b \u0026 b \u0026 \\cdots \u0026 b \\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\vdots \\\\ c \u0026 c \u0026 \\cdots \u0026 c \\end{matrix} \\right\\} \\tag{5} $$ 带竖线分割的矩阵 markdown 1 2 3 4 5 6 7 8 9 10 $$ \\left[ \\begin{array}{c|cc} 1 \u0026amp; 2 \u0026amp; 3 \\\\ 4 \u0026amp; 5 \u0026amp; 6 \\\\ 7 \u0026amp; 8 \u0026amp; 9 \\end{array} \\right] \\tag{7} $$ $$ \\left[ \\begin{array}{c|cc} 1 \u0026 2 \u0026 3 \\\\ 4 \u0026 5 \u0026 6 \\\\ 7 \u0026 8 \u0026 9 \\end{array} \\right] \\tag{6} $$ 带横线分割的矩阵 markdown 1 2 3 4 5 6 7 8 9 10 $$ \\left[ \\begin{matrix} 1 \u0026amp; 2 \u0026amp; 3 \\\\ \\hline 4 \u0026amp; 5 \u0026amp; 6 \\\\ 7 \u0026amp; 8 \u0026amp; 9 \\end{matrix} \\right] \\tag{7} $$ $$ \\left[ \\begin{matrix} 1 \u0026 2 \u0026 3 \\\\ \\hline 4 \u0026 5 \u0026 6 \\\\ 7 \u0026 8 \u0026 9 \\end{matrix} \\right] \\tag{7} $$ 同时带横线和竖线的矩阵 markdown 1 2 3 4 5 6 7 8 9 10 $$ \\left[ \\begin{array}{c|cc} 1 \u0026amp; 2 \u0026amp; 3 \\\\ \\hline 4 \u0026amp; 5 \u0026amp; 6 \\\\ 7 \u0026amp; 8 \u0026amp; 9 \\end{array} \\right] \\tag{8} $$ $$ \\left[ \\begin{array}{c|cc} 1 \u0026 2 \u0026 3 \\\\ \\hline 4 \u0026 5 \u0026 6 \\\\ 7 \u0026 8 \u0026 9 \\end{array} \\right] \\tag{8} $$ 字符的大小、位置和颜色 调整大小 调整大小时，只需在公式之前添加相应的标识，如 \\Large：\nmarkdown 1 2 3 $$ \\Large E=mc^2 $$ $$ \\Large E=mc^2 $$ 示例 标识 \\$\\Huge E=mc^2\\$ \\Huge \\$\\huge E=mc^2\\$ \\huge \\$\\LARGE E=mc^2\\$ \\LARGE \\$\\Large E=mc^2\\$ \\Large \\$\\large E=mc^2\\$ \\large \\$\\normalsize E=mc^2\\$ \\normalsize (default) \\$\\small E=mc^2\\$ \\small \\$\\footnotesize E=mc^2\\$ \\footnotesize \\$\\scriptsize E=mc^2\\$ \\scriptsize \\$\\tiny E=mc^2\\$ \\tiny 粗体斜体 编码 字体 效果 \\rm 罗马体 \\$\\rm E=mc^2\\$ \\it 意大利体(默认) \\$\\it E=mc^2\\$ \\bf 粗体 \\$\\bf E=mc^2\\$ \\boldsymbol 黑体 \\$\\boldsymbol E=mc^2\\$ \\Bbb 黑板粗体 \\$\\Bbb E=mc^2\\$ 换行 居中 使用 \\\\，对齐使用 align\nmarkdown 1 2 3 4 5 6 7 $$ \\begin{align} x^2-8 \u0026amp; = 2x \\\\ x^2-2x+1 \u0026amp; = 9 \\\\ (x-1)^2 \u0026amp; = (\\pm3)^2 \\end{align} $$ $$ \\begin{align} x^2-8 \u0026 = 2x \\\\ x^2-2x+1 \u0026 = 9 \\\\ (x-1)^2 \u0026 = (\\pm3)^2 \\end{align} $$ 若提示 KaTeX parse error: No such environment: align at position .... 错误，可尝试使用 aligned。\n其他环境：\n环境名称 描述 align 最基本的对齐环境 multline 非对齐环境 gather 无对齐的连续方程 修改颜色 markdown 1 2 3 $$ P\\left(x_{l} \\mid y_{l}\\right) = \\frac{P(x_l,y_l)}{P(y_l)}=\\frac{\\textcolor{#FF0000}{P(y_l\\mid x_l)}P(x_l)}{P(y_l)} $$ $$ P\\left(x_{l} \\mid y_{l}\\right) = \\frac{P(x_l,y_l)}{P(y_l)}=\\frac{\\textcolor{#FF0000}{P(y_l\\mid x_l)}P(x_l)}{P(y_l)} $$ 常用颜色：\nred：红色 green：绿色 blue：蓝色 yellow：黄色 花体字母 编码如下：\nmarkdown 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 $\\mathbb{A B C D E F G H I J K L M N O P Q R S T U V W X Y Z}$ $\\mathcal{A B C D E F G H I J K L M N O P Q R S T U V W X Y Z}$ $\\mathscr{A B C D E F G H I J K L M N O P Q R S T U V W X Y Z}$ $\\mathrm{A B C D E F G H I J K L M N O P Q R S T U V W X Y Z}$ $\\mathbf{A B C D E F G H I J K L M N O P Q R S T U V W X Y Z}$ $\\mathit{A B C D E F G H I J K L M N O P Q R S T U V W X Y Z}$ $\\mathsf{A B C D E F G H I J K L M N O P Q R S T U V W X Y Z}$ $\\mathtt{A B C D E F G H I J K L M N O P Q R S T U V W X Y Z}$ $\\mathfrak{A B C D E F G H I J K L M N O P Q R S T U V W X Y Z}$ 效果依次如下：\n\\$\\mathbb{A B C D E F G H I J K L M N O P Q R S T U V W X Y Z}\\$\n\\$\\mathcal{A B C D E F G H I J K L M N O P Q R S T U V W X Y Z}\\$\n\\$\\mathscr{A B C D E F G H I J K L M N O P Q R S T U V W X Y Z}\\$\n\\$\\mathrm{A B C D E F G H I J K L M N O P Q R S T U V W X Y Z}\\$\n\\$\\mathbf{A B C D E F G H I J K L M N O P Q R S T U V W X Y Z}\\$\n\\$\\mathit{A B C D E F G H I J K L M N O P Q R S T U V W X Y Z}\\$\n\\$\\mathsf{A B C D E F G H I J K L M N O P Q R S T U V W X Y Z}\\$\n\\$\\mathtt{A B C D E F G H I J K L M N O P Q R S T U V W X Y Z}\\$\n\\$\\mathfrak{A B C D E F G H I J K L M N O P Q R S T U V W X Y Z}\\$\n参考 https://www.latex-project.org/help/documentation/amsldoc.pdf https://blog.csdn.net/Liu_PiPiPi/article/details/121613743 https://blog.51cto.com/u_15917702/5953725 ","permalink":"https://tofuwine.github.io/posts/2ebecd7d/","summary":"Markdown 数学公式 KaTex 渲染语法","title":"Markdown 数学公式"},{"content":" 文中代码基于 Java 17\nSpring 拦截器与 Servlet Filter 的异同 Spring 的拦截器（Interceptor）与 Servlet 的 Filter 有相似之处，比如二者都是 AOP 编程思想的体现，都能实现权限检查、日志记录等。\n不同的是：\n使用范围不同：Filter 是 Servlet 规范规定的，只能用于 Web 程序中。而拦截器既可以用于 Web 程序，也可以用于 Application、Swing 等程序中。 规范不同：Filter 是 Servlet 规范中定义的，是 Servlet 容器支持的。而拦截器是在 Spring 容器内的，是 Spring 框架支持的。 使用资源不同：同其他代码块一样，Interceptor 也是一个 Spring 的组件，归 Spring 管理，配置在 Spring 文件中，因此能使用 Spring 里的任何资源、对象，例如 Service 对象、数据源、事务管理等，通过 IoC 注入拦截器即可。而 Filter 则不能。 深度不同：Filter 只在 Servlet 前后起作用。而拦截器能够深入到方法前后、异常抛出前后等。因此拦截器的使用具有更大的弹性。所以在 Spring 架构的程序中，要优先使用拦截器。 对于一个请求，拦截器、过滤器执行流程如下：\nflowchart LR A((request)) B(Filter) C(Servlet) D(Interceptor) E(Controller) F((doService)) A --\u003e B --\u003e C --\u003e D --\u003e E --\u003e F 何时使用 Filter、Interceptor？ 如果是非 Spring 项目，那么拦截器不能用，只能使用过滤器。 如果是处理 Controller 前后，既可以使用拦截器也可以使用过滤器。 如果是处理 DispatcherServlet 前后，只能使用过滤器。 Spring Boot 使用 Filter Spring Boot 使用 Filter 有两种方式：\n使用 Spring Boot 提供的 FilterRegistrationBean 注册 Filter 使用原生 Servlet 注解 @WebFilter 定义 Filter 使用 FilterRegistrationBean 注册 Filter 自定义 Filter 并实现 jakarta.servlet.Filter 。（低版本 JDK 请使用 javax.servlet.Filter） java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 import jakarta.servlet.Filter; import jakarta.servlet.FilterChain; import jakarta.servlet.ServletException; import jakarta.servlet.ServletRequest; import jakarta.servlet.ServletResponse; import java.io.IOException; public class MyFilter implements Filter { @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { // your code } } 自定义配置类配置 Filter java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import org.springframework.boot.web.servlet.FilterRegistrationBean; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class WebConfig { @Bean public FilterRegistrationBean\u0026lt;MyFilter\u0026gt; myFilterFilterRegistration() { FilterRegistrationBean\u0026lt;MyFilter\u0026gt; registrationBean = new FilterRegistrationBean\u0026lt;\u0026gt;(); MyFilter myFilter = new MyFilter(); registrationBean.setFilter(myFilter); return registrationBean; } } 使用原生 Servlet 注解 @WebFilter 定义 Filter 自定义 Filter 并实现 jakarta.servlet.Filter （低版本 JDK 请使用 javax.servlet.Filter），同时添加 @WebFilter 注解。 java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import jakarta.servlet.Filter; import jakarta.servlet.FilterChain; import jakarta.servlet.ServletException; import jakarta.servlet.ServletRequest; import jakarta.servlet.ServletResponse; import jakarta.servlet.annotation.WebFilter; import java.io.IOException; @WebFilter public class MyFilter implements Filter { @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { // your code } } 在启动类上添加 @ServletComponentScan 注解 java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.boot.web.servlet.ServletComponentScan; @SpringBootApplication @ServletComponentScan public class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); } } 自定义过滤器执行顺序 使用自定义配置类配置过滤器时，可通过 setOrder() 方法设置过滤器执行顺序。如不设置，则按照 Spring Boot Bean 加载顺序。\n使用 Servlet 原生注解 @WebFilter 时，只能通过限定 Filter 类型（按字母表 A - Z 的顺序）。注意：此方式使用 @Order 注解无效。\nSpring Boot 使用 Interceptor 当请求来到 DispatcherServlet 时，它会根据 HandlerMapping 的机制找到处理器，这样就会返回一个 HandlerExecutionChain 对象。这个对象包含处理器和拦截器。这里的拦截器会对处理器进行拦截，这样通过拦截器就可以增强处理器的功能。 ——《深入浅出 Spring Boot 2.X》- 杨开振\n拦截器的设计（Interceptor 接口） 所有的拦截器都需要实现 HandlerInterceptor 接口。该接口主要定义如下：\njava 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import jakarta.servlet.http.HttpServletRequest; import jakarta.servlet.http.HttpServletResponse; import org.springframework.lang.Nullable; public interface HandlerInterceptor { default boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { return true; } default void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable ModelAndView modelAndView) throws Exception { } default void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable Exception ex) throws Exception { } } 这些方法的执行流程如下：\n执行 preHandler() 方法。该方法会返回一个布尔值。如果为 false ，则结束所有流程；如果为 true ，则执行下一步 执行处理器逻辑。它包含控制器的功能。 执行 postHandle() 方法。 执行视图解析和视图渲染。 执行 afterCompletion() 方法。 开发拦截器 定义简单拦截器 实现 HandlerInterceptor 接口，并实现其方法：\njava 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import jakarta.servlet.http.HttpServletRequest; import jakarta.servlet.http.HttpServletResponse; import org.springframework.web.servlet.HandlerInterceptor; import org.springframework.web.servlet.ModelAndView; public class MyInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { System.out.println(\u0026#34;处理器执行前方法\u0026#34;); return true; } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { System.out.println(\u0026#34;处理器执行后方法\u0026#34;); } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { System.out.println(\u0026#34;处理器完成方法\u0026#34;); } } 注册拦截器 新建配置类并实现 WebMvcConfigurer 接口，重写 addInterceptors(InterceptorRegistry registry) 方法：\njava 1 2 3 4 5 6 7 8 9 10 11 12 13 import org.springframework.context.annotation.Configuration; import org.springframework.web.servlet.config.annotation.InterceptorRegistry; import org.springframework.web.servlet.config.annotation.WebMvcConfigurer; @Configuration public class WebConfig implements WebMvcConfigurer { @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(new MyInterceptor()) .addPathPatterns(\u0026#34;/test/*\u0026#34;); } } 多个拦截器顺序 多个拦截器拦截同一路径时，采用责任链模式的规则，对于处理器前方法采用先注册先执行，而处理后方法和完成方法则是先注册后执行的规则。\n当多个拦截器中某一个处理前（preHandle()）方法为 false 时，则后续拦截器、处理器和所有拦截器的处理器后（ postHandle() ）方法都不会执行。完成方法（ afterCompletion() ）则不一样，它只会执行返回 true 的拦截器的完成方法，而且顺序是先注册后执行。\n","permalink":"https://tofuwine.github.io/posts/68cf2484/","summary":"Spring Interceptor 与 Servlet Filter 区别与使用示例","title":"Spring 拦截器与 Servlet Filter 的区别与使用"},{"content":" 免责声明 本文内容仅限学习和研究目的，禁止商业用途。请在下载后务必于 24 小时内删除！ 本文内容来源于网络分享，请自行甄别，谨防上当受骗！ 本文内容不提供任何技术支持，请自行研究学习！ 若资金允许，请购买正版，谢谢合作！ Introduction 本文主要分享以下两种方式：\nHEU KMS Activator Microsoft Activation Scripts（MAS） 请自行选择合适的方式使用。\nHEU KMS Activator 前往 Github 下载。图形化界面，操作简单，在 GitHub 上有说明文档可供参考。\nMicrosoft Activation Scripts（MAS） Method 1 - PowerShell (Recommended)\nRight-click on the Windows start menu and select PowerShell or Terminal (Not CMD). Copy and paste the code below and press enter powershell 1 irm https://massgrave.dev/get | iex You will see the activation options. Follow the on-screen instructions. That’s all. Method 2 - Traditional Download the file from GitHub or Bitbucket Right-click on the downloaded zip file and extract In the extracted folder, find the folder named All-In-One-Version Run the file named MAS_AIO.cmd You will see the activation options, follow the on-screen instructions. That’s all. To run the scripts in unattended mode, check here.\n","permalink":"https://tofuwine.github.io/posts/4ee6297b/","summary":"Windows \u0026amp; Office Activation","title":"Microsoft Activation"},{"content":"准备 EasyRSA 下载 EasyRSA （本文以 EasyRSA-3.1.7.tgz 为例）\n签署证书 本文演示 CA、服务器端、客户端均在同一设备下生成，若在不同设备下请参考官方文档。\n解压 EasyRSA Windows 使用压缩软件解压下载好的 EasyRSA 压缩包 进入 EasyRSA 文件目录，运行 EasyRSA-Start.bat Linux bash 1 2 tar -zxf EasyRSA-3.1.7.tgz cd EasyRSA-3.1.7/ 配置 vars 在 EasyRSA 目录下有名为 vars.example 的文件，复制该文件名并命名为 vars（即去掉后缀 .example） 打开文件，在文件末尾添加如下内容并保存（变量值自行修改）： text 1 2 3 4 5 6 set_var EASYRSA_REQ_COUNTRY\t\u0026#34;US\u0026#34; set_var EASYRSA_REQ_PROVINCE\t\u0026#34;California\u0026#34; set_var EASYRSA_REQ_CITY\t\u0026#34;San Francisco\u0026#34; set_var EASYRSA_REQ_ORG\t\u0026#34;Copyleft Certificate Co\u0026#34; set_var EASYRSA_REQ_EMAIL\t\u0026#34;me@example.net\u0026#34; set_var EASYRSA_REQ_OU\t\u0026#34;My Organizational Unit\u0026#34; 创建 CA（证书颁发机构） 在 EasyRSA 目录下执行如下命令：\npowershell 1 2 ./easyrsa init-pki ./easyrsa build-ca 说明：\ninit-pki 会生成一个 pki 文件夹 build-ca 命令会自动使用目录下的 vars 文件 build-ca 命令需要输入 CA Key Passphrase（请保存好，后续会使用） build-ca 命令需要输入 Common Name（默认 Easy-RSA CA），直接回车即可。 最终会在 pki 目录下生成 ca.crt 签署服务端证书 生成 keypair/request powershell 1 ./easyrsa gen-req ovpn-server 说明：\novpn-server 可以改成任意名称，仅用于命名请求文件。 此命令会需要输入 PEM pass phrase（请保存好）。如果不需要加密密钥，请在上述命令追加 nopass 同样需要输入 Common Name（默认 ovpn-server），直接回车即可 最终会生成两个文件 pki/reqs/ovpn-server.req 和 pki/private/ovpn-server.key 签署证书 powershell 1 ./easyrsa sign-req server ovpn-server 说明：\n如果你在 生成 keypair/request 时不是使用的 ovpn-server，请替换为你所输入的内容 会提示你确认信息，输入 yes 需要输入 ca.key 即创建 CA 时所输入的 CA Key Passphrase 最终会生成 pki/issued/ovpn-server.crt 签署客户端证书 生成 keypair/request powershell 1 ./easyrsa gen-req ovpn-client 说明：\novpn-client 可以改成任意名称，仅用于命名请求文件。 此命令会需要输入 PEM pass phrase（请保存好）。如果不需要加密密钥，请在上述命令追加 nopass 同样需要输入 Common Name（默认 ovpn-client），直接回车即可 最终会生成两个文件 pki/reqs/ovpn-client.req 和 pki/private/ovpn-client.key 签署证书 powershell 1 ./easyrsa sign-req client ovpn-client 说明：\n如果你在 生成 keypair/request 时不是使用的 ovpn-client，请替换为你所输入的内容 会提示你确认信息，输入 yes 需要输入 ca.key 即创建 CA 时所输入的 CA Key Passphrase 最终会生成 pki/issued/ovpn-client.crt 生成密钥交换文件 powershell 1 ./easyrsa gen-dh 说明：\n最终会生成 pki/dh.pem 总结 Conclusion\n最终我们可以获得以下相关文件：\nca.crt ovpn-server.key ovpn-server.crt ovpn-client.key ovpn-client.crt db.pem 参考 OpenVPN/easy-rsa: easy-rsa – Simple shell based CA utility (github.com) https://www.bilibili.com/video/BV18V411U7iW/ ","permalink":"https://tofuwine.github.io/posts/2b596b1f/","summary":"使用 EasyRSA 构建 CA 并签署证书（包括服务端和客户端）","title":"EasyRSA 构建 CA 并签署证书（服务端 \u0026 客户端）"},{"content":"配置相关 如何修改项目的 git 用户名 / 邮箱 方式一：\n修改 .git 文件夹中的 config 文件：\nconfig 1 2 3 [user] name = yourname email = email@example.com 方式二：\n通过命令行执行以下命令修改：\nshell 1 2 3 4 5 6 7 8 # 修改当前项目的 git 用户名 git config user.name \u0026#34;yourname\u0026#34; # 修改当前项目的 git 邮箱 git config user.email \u0026#34;email@example.com\u0026#34; # 或者你也可以修改全局配置 git config --global user.name \u0026#34;yourname\u0026#34; git config --global user.email \u0026#34;email@example.com\u0026#34; 禁用 SSL 校验 执行以下命令禁用 SSL 校验。\nshell 1 git config --global http.sslVerify false 功能相关 修改 .gitignore 文件后使其生效 思路：清除全局缓存后再添加所有文件\nshell 1 2 3 4 5 6 # 1. 清除缓存 (别忘了 \u0026#34;.\u0026#34;) git rm -r --cached . # 2. 添加所有文件 (别忘了 \u0026#34;.\u0026#34;) git add . # 3. 提交 [可选] git commit -m \u0026#34;update .gitingore\u0026#34; 生成密钥 执行以下命令生成密钥：\nshell 1 ssh-keygen -t ed25519 -C \u0026#34;email@example.com\u0026#34; 更新远程分支列表 执行以下命令更新远程分支列表：\nshell 1 git remote update origin --prune 必须带 --prune ，否则效果和 git fetch 一样，即新增加的分支能 fetch 下来，但是被删掉的分支却不能同步删掉本地的 origin 的。\n修改远程仓库地址后提示 401 错误描述：\ntext 1 error: RPC failed; HTTP 401 curl 22 The requested URL returned error: 401 解决方式：\nshell 1 git remote set-url origin \u0026lt;new-url\u0026gt; 然后重新 push 就会提示输入账号 / 密码。\n修改提交时间 使用如下代码，可以提交到指定的时间：\nshell 1 git commit --date=\u0026#34;Sep 30 15:05:20 2022 +0800\u0026#34; -am \u0026#34;提交内容\u0026#34; 月份可参考 附录：月份对照表\n附录 月份对照表 月份 英文 缩写 1 月 January Jan 2 月 February Feb 3 月 March Mar 4 月 April Apr 5 月 May May 6 月 June Jun 7 月 July Jul 8 月 August Aug 9 月 September Sep 10 月 October Oct 11 月 November Nov 12 月 December Dec ","permalink":"https://tofuwine.github.io/posts/10a5c8d8/","summary":"Git 常见问题汇总","title":"Git FAQs"},{"content":"软件风险包含两个特性：不确定性和损失。不确定性是指风险可能发生也可能不发生；损失是指如果风险发生，就会产生恶性后果。风险管理的过程：风险识别、风险预测、风险评估、风险控制。\n风险显露度（Risk Exposure，RE）可由下面的关系确定：\\$RE=py*C\\$，其中，py 是风险发生的概率，C 是风险发生时带来的项目成本。通过该公式判断风险的优先级。\n软件配置管理（Software Configure Management，SCM）用于整个软件工程过程。其主要目标是标识变更；控制变更；确保变更正确地实现；报告有关变更。SCM 是一组管理整个软件生存周期中各阶段变更的活动。配置管理的主要内容包括版本管理、配置支持、变更支持、过程支持、团队支持、变化报告和审计支持等。\nCOCOMO 模型是一种精确的、易于使用的成本估算模型。COCOMO 模型按其详细程度分为基本 COCOMO 模型、中级 COCOMO 模型和详细 COCOMO 模型。\n基本 COCOMO 模型是一个静态单变量模型，用于对整个软件系统进行估算。其可通过估算代码行的值，然后计算开发工作量和开发时间的估算值。 中级 COCOMO 模型是一个静态多变量模型，它将软件系统模型分为系统和部件两个层次，系统由部件构成，它把软件开发所需的人力（成本）看做是程序大小和一系列“成本驱动属性”的函数。 详细 COCOMO 模型，它将软件系统模型分为系统、子系统和模块 3 个层次，除包括中级模型所考虑的因素外，还考虑了在需求分析、软件设计等每一步的成本驱动属性的影响。 COCOMOII 也是一种层次结构的估算模型，被分为 3 个阶段性模型。COCOMOII 模型也需要使用规模估算信息，在模型层次结构中有 3 种不同的规模估算选择：对象点、功能点和代码行。\nPutnam 模型是一种动态多变量模型，它是假设在软件开发的整个生存周期中工作量有特定的分布。根据一些大型软件项目（30 人年以上）的工作量分布情况，推导出软件项目在软件生存周期各阶段的工作量分布。\n","permalink":"https://tofuwine.github.io/posts/d95669d1/","summary":"【软件设计师】第十四章 补充知识","title":"第十四章 补充知识"},{"content":"知识产权 知识产权客体 知识产权类型 保护期限 公民作品 署名权、修改权、保护作品完整权 没有限制 发表权、使用权、获得报酬权 作者终生及其死亡后的第 50 年的 12 月 31 日 单位作品 发表权、使用权、获得报酬权 首次发表后的第 50 年的 12 月 31 日，若未发表则不受保护 公民软件作品 署名权、修改权 没有限制 发表权、复制权、发行权、出租权、信息网络传播权、翻译权、使用许可权、获得报酬权、转让权 作者终生及其死亡后的第 50 年的 12 月 31 日。\n合作开发以最后死亡作者为准 单位软件作品 发表权、复制权、发行权、出租权、信息网络传播权、翻译权、使用许可权、获得报酬权、转让权 首次发表后的第 50 年的 12 月 31 日，若未发表则不受保护 发明专利权 20 年（申请日开始计算） 实用新型与外观设计专利权 10 年（申请日开始计算） 商标权 10 年，期满可续注 商业秘密权 没有限制 作品相关 客体类型 说明 归属 作品 职务作品 利用单位的物质技术条件创作，并由单位承担责任的 除署名权外其他著作权归单位 合同约定 除署名权外其他著作权归单位 其他 作者拥有著作权，单位有权在业务范围内优先使用 软件 职务作品 属于本职工作中明确规定的开发目标 单位享有著作权 属于从事本职工作活动的结果 单位享有著作权 使用了单位资金、专用设备、未公开的信息等物质、技术条件，并由单位或组织承担责任的软件 单位享有著作权 专利权 职务作品 本职工作中做出的发明创造 单位享有专利 履行本单位交付的本职工作之外的任务所作出的发明创造 单位享有专利 离职、退休或调动工作后 1 年内，与原单位工作相关 单位享有专利 委托 客体类型 说明 归属 软件作品 委托创作 合同约定，著作权归委托方 委托方 合同中未约定著作权归属 创作方 合作开发 只进行组织、提供咨询意见、物质条件或者进行其他辅助工作 不享有著作权 共同创作的 共同享有著作权、按人头比例成果可分割的，可分开申请 商标 谁先申请谁拥有（除知名商标的非法抢注）\n同时申请，谁先使用谁拥有（需提供证据）\n无法提供证据，可协商，协商不成的抽签决定 专利 谁先申请谁拥有\n同时申请，协商归属 计算机保护条例 第二条 本条例所称计算机软件（以下简称软件），是指计算机程序及其有关文档。 第三条 本条例下列用语的含义： （一）计算机程序，是指为了得到某种结果而可以由计算机等具有信息处理能力的装置执行的代码化指令序列，或者可以被自动转换成代码化指令序列的符号化指令序列或者符号化语句序列。同一计算机程序的源程序和目标程序为同一作品。 （二）文档，是指用来描述程序的内容、组成、设计、功能规格、开发情况、测试结果及使用方法的文字资料和图表等，如程序设计说明书、流程图、用户手册等。 （三）软件开发者，是指实际组织开发、直接进行开发，并对开发完成的软件承担责任的法人或者其他组织；或者依靠自己具有的条件独立完成软件开发，并对软件承担责任的自然人。 （四）软件著作权人，是指依照本条例的规定，对软件享有著作权的自然人、法人或者其他组织。 第四条 受本条例保护的软件必须由开发者独立开发，并已固定在某种有形物体上。 第五条 中国公民、法人或者其他组织对其所开发的软件，不论是否发表，依照本条例享有著作权。 第六条 本条例对软件著作权的保护不延及开发软件所用的思想、处理过程、操作方法或者数学概念等。 第十一条 接受他人委托开发的软件，其著作权的归属由委托人与受委托人签订书面合同约定；无书面合同或者合同未作明确约定的，其著作权由受托人享有。 第十三条 自然人在法人或者其他组织中任职期间开发的软件有下列情形之一的，该软件著作权由该法人或者其他组织享有，该法人或者其他组织可以对开发软件的自然人进行奖励： （一）针对本职工作中明确指定的开发目标所开发的软件 （二）开发的软件是从事本职工作活动所预见的结果或者自然的结果 （三）主要使用了法人或者其他组织的资金、专用设备、未公开的专门信息等物质技术条件所开发并由法人或者其他组织承担责任的软件。 第十四条 软件著作权自软件开发完成之日起产生。 自然人的软件著作权，保护期为自然人终生及其死亡后 50 年，截止于自然人死亡后第 50 年的 12 月 31 日；软件是合作开发的，截止于最后死亡的自然人死亡后第 50 年的 12 月 31 日。 法人或者其他组织的软件著作权，保护期为 50 年，截止于软件首次发表后第 50 年的 12 月 31 日，但软件自开发完成之日起 50 年内未发表的，本条例不再保护。 第十七条 为了学习和研究软件内含的设计思想和原理，通过安装、显示、传输或者存储软件等方式使用软件的，可以不经软件著作权人许可，不向其支付报酬。 第二十八条 软件复制品的出版者、制作者不能证明其出版、制作有合法授权的，或者软件复制品的发行者、出租者不能证明其发行、出租的复制品有合法来源的，应当承担法律责任。 第三十条 软件的复制品持有人不知道也没有合理理由应当知道该软件是侵权复制品的，不承担赔偿责任；但是，应当停止使用、销毁该侵权复制品。如果停止使用并销毁该侵权复制品将给复制品使用人造成重大损失的，复制品使用人可以向软件著作权人支付合理费用后继续使用。 真题及答案 真题示例 - 1：\n以下说法中，错误的是（）。\nA. 张某和王某合作完成一款软件，他们可以约定申请专利的权利只属于张某\nB. 张某和王某共同完成了一项发明创造，在没有约定的情况下，如果张某要对其单独申请专利就必须征得王某的统一\nC. 张某临时借调到某软件公司工作，在执行该公司交付的任务的过程中，张某完成的发明创造属于职务发明\nD. 甲委托乙开发了款软件，在没有约定的情况下，由于甲提供了全部的资金和设备，因此该软件著作权属于甲\n真题示例 - 2：\n根据《计算机软件保护条例》的规定，当软件（）后，其软件著作权才能得到保护。\nA. 作品发表\nB. 作品创作完成并固定在某种有形物体上\nC. 作品创作完成\nD. 作品上加注版权标记\n真题示例 - 3：\n甲程序员为乙软件设计师开发的应用软件编写了操作说明书，并已交付用户使用，（）享有该应用软件的软件著作权。\nA. 甲程序员\nB. 甲程序员和乙软件设计师共同\nC. 乙软件设计师\nD. 甲程序员和乙软件设计师都不\n真题答案 题号 答案 1 D 2 C 3 C ","permalink":"https://tofuwine.github.io/posts/dfc7dc80/","summary":"【软件设计师】第十三章 知识产权","title":"第十三章 知识产权"},{"content":"一 章节知识点架构图 二 网络互联模型 层的名称 主要功能 详细说明 应用层 处理网络应用 直接为端用户服务，提供各类应用过程的接口和用户接口。例如 HTTP、Tenlent、FTP、SMTP、NFS 等 表示层 数据表示 使应用层可以根据其服务解释数据的涵义。通常包括数据编码的约定、本地句法的转换。例如 JPEG、ASCII、GIF、DES、MPEG 等 会话层 互连主机通信 负责管理远程用户或进程间的通信，通常包括通信控制、检查点设置、重建中断的传输链路、名字查找和安全验证服务。例如：RPC、SQL 等。 传输层 端到端连接 实现发送端和接收端的端到端的数据分组发送，负责保证实现数据包无差错、按顺序、无丢失和无冗余的传输。其服务访问点为端口。代表性协议有 TCP、UDP、SPX 等。 网络层 分组传输和路由选择 通过网络连接交换传输层实体发出的数据，解决路由器选择、网络拥塞、异构网络互联的问题。服务访问点为逻辑地址（网络地址）。代表性协议有 IP、IPX 等。 数据链路层 传输以帧为单位的信息 建立、维持和释放网络实体之间的数据链路，把流量控制合并在一起。为 MAC（媒介访问层）和 LLC（逻辑链路层）两个子层。服务访问点为物理地址（MAC 地址）。代表性协议有 IEEE802.3/.2、HDLC、PPP、ATM 等 物理层 二进制为传输 通过一系列协议定义了通行设备的机械的、电气的、功能的、规程的特征。代表性协议有 RS232、V.35、RJ-45、FDDI 等。 三 常见的网络协议 3.1 应用层协议 在应用层中，定义了很多面向应用的协议，应用程序通过本层协议利用网络完成数据交互的任务。这些协议主要有 FTP、TFTP、HTTP、SMTP、DHCP、Telnet、DNS 和 SNMP 等。\nFTP（File TransportProtocol，文件传输协议）是网络上两台计算机传送文件的协议，运行在 TCP 之上，是通过 Internet 将文件从一台计算机传输到另一台计算机的一种途径。FTP 的传输模式包括 Bin（二进制）和 ASCII（文本文件）两种，除了文本文件之外，都应该使用二进制模式传输。FTP 在客户机和服务器之间需要建立两条 TCP 连接，一条用于传送控制信息（使用 21 号端口），另一条用于传送文件内容（使用 20 号端口）\nTFTP（Trivial FileTransfer Protocol，简单文件传输协议）是用来在客户机与服务器之间进行简单文件传输的西医，提供不复杂、开销不大的文件传输协议。TFTP 建立在 UDP（User Datagram Protocol，用户数据报协议）之上，提供不可靠的数据流传输服务，不提供存取授权与认证机制，使用超时重传方式来保证数据的到达。\nHTTP（Hypertext TransferProtocol，超文本传输协议）是用于从 WWW 服务器传输超文本到本地浏览器的传送协议。它可以使浏览器更加高效，使网络传输减少。HTTP 建立在 TCP 之上，它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分内容首先显示等。\n协议 描述 文件传输协议 FTP 两条 TCP 连接，传送控制信息（21 号端口），传送数据内容（20 号端口）。数据端口有两种模式：主动模式（服务器向客户端的连接端口为 20）、被动模式（客户机向服务器端的连接端口为 1025 - 65535 之间） 简单文件传输协议 TFTP UDP 协议，端口号 69 超文本传输协议 HTTP TCP 协议，端口号 80。HTTPS（HTTP + SSL）端口号 443 简单邮件传输协议 SMTP 邮件的发送。TCP 协议，端口号 25 邮局协议 POP3 邮件的收取。TCP 协议，端口号 110 动态主机配置协议 DHCP UDP 协议，端口号 67。租约默认为 8 天，租约过半需续约。 远程登录协议 Telnet TCP 协议，端口号 23 域名系统 DNS UDP 协议，较少情况下使用 TCP 协议，端口号均为 53 简单网络管理协议 SNMP UDP 协议，端口号为 161 3.2 传输层协议 传输层主要有两个传输协议，分别是 TCP 和 UDP（User Datagram Protocol，用户数据报协议），这些协议负责提供流量控制、错误校验和排序服务。\nTCP 是整个 TCP/IP 协议族中最重要的协议之一，它在 IP 协议提供的不可靠数据服务的基础上，采用了重发技术，为应用程序提供了一个可靠的、面向连接的、全双工的数据传输服务。TCP 协议一般用于传输数据量比较少，且对可靠性要求高的场合。\nUDP 是一种不可靠的、无连接的协议，可以保证应用程序进程间的通信，与 TCP 相比，UDP 是一种无连接的协议，它的错误检测功能要弱的多。可以这样说，TCP 有助于提供可靠性，而 UDP 则有助于提高传输速率。UDP 协议一般用于传输数据量大，对可靠性要求不是很高，但要求速度快的场合。\n3.3 网络层协议 网络层中的协议主要有 IP、ICMP（Internet Control Message Protocol，网际控制报文协议）、IGMP（Internet Group Management Protocol，网际组管理协议）、ARP（Address Resolution Protocol，地址解析协议）和 RARP（Reverse Address Resolution Protocol，反向地址解析协议）等，这些协议处理信息的路由和主机地址解析。\nIP 所提供的服务通常被认为是无连接的和不可靠的，它将差错检测和流量控制之类的服务授权给了其他的各层协议，这正是 TCP/IP 能够高效率工作的一个重要保证。网络层的功能主要由 IP 来提供，除了提供端到端的分组分发功能外，IP 还提供很多扩充功能。例如，为了克服数据链路层对帧大小的限制，网络层提供了数据分块和重组功能，这使得很大的 IP 数据包能以较小的分组在网络上传输。\n真题示例 - 3.1：\n（）是接收电子邮件的协议。\nA. SMTP B. HTTP C. POP3 D. TCP\n真题示例 - 3.2：\nHTTP 协议的默认端口号是（）。\nA. 23 B. 25 C. 80 D. 110\n四 网络安全控制技术 4.1 防火墙 建立在内外网络边界上的过滤封锁机制，它认为内部网络是安全和可信赖的，而外部网络是不安全和不可信赖的。\n类型 特征 包过滤防火墙 在网络层根据访问控制列表对数据包检查，来确定是否允许数据包通过 应用代理网关防火墙 在应用层，通过代理软件对数据和协议进行过滤 状态检测防火墙 在网络层将数据当成会话，利用状态表跟踪每一个会话的状态。 4.2 加密技术 类型 特征 算法 对称加密 又叫私钥加密算法，加密与解密密钥相同。适合大数据量（明文）加密。加密速度快。 DES、3DES、AES、IDEA、RC4 非对称加密 又叫公钥加密算法，加密与解密密钥不同。适合少数据量加密。加密速度慢。身份认证抗抵赖性好。 RSA、ECC椭圆曲线 4.3 消息摘要与数字签名与数字证书 类型 特征 消息摘要 使用单向哈希函数生成摘要发送给接收方。常用算法 MD5（密文长度 128 位）、SHA-256 安全散列算法。 数字签名 利用公钥加密对消息摘要签名。其中发送方私钥用于签名而发送方公钥用于验证 数字证书 用电子手段来证实一个用户的身份和对网络资源的访问权限 。由数字证书认证机构 CA 和签发和管理。CA 可以证明数字证书的持有者合法拥有证书中列出的公开密钥 4.4 数字信封 数字信封是将对称密钥通过非对称加密（即：有公钥和私钥两个）的结果分发对称密钥的方法。数字信封是实现完整性验证的技术。数字信封是一种综合利用了对称加密技术和非对称加密技术两者的优点进行信息安全传输的一种技术。数字信封既发挥了对称加密算法速度快、安全性好的优点，又发挥了非对称加密算法密钥管理方便的优点。数字信封以发送方向接收方传递一段交易信息（如电子合同、支付通知单等）为例，发送方先在本地用对称密钥对交易信息进行加密，形成密文，再用接收方的公钥将用于加密交易信息的对称密钥加密，并将加密后的对称密钥信息和密文一同传递给接收方。接收方接收信息后，先用自己的私钥解密加密的对称密钥信息，得到用于加密交易信息的对称密钥，再用其解密密文得到交易信息原文。由于在传递过程中，加密的对称密钥就像是封装在一个“信封”里传递一样，因此被称为数字信封。\n真题示例 - 4.1：\n数字信封技术能够（）。\nA. 保证数据在传输过程中的安全性\nB. 隐藏发送者真实身份\nC. 对发送者和接收者的身份进行认证\nD. 防止交易中的抵赖发生\n4.5 数字信封与数字签名 真题答案 题号 答案 3.1 C 3.2 C 4.1 A ","permalink":"https://tofuwine.github.io/posts/eadbd2eb/","summary":"【软件设计师】第十二章 计算机网络与信息安全","title":"第十二章 计算机网络与信息安全"},{"content":"Java 程序设计 定义类：\n接口类、抽象类。接口类中的函数定义可以通过代码判断。\n设计类：\n填写函数体，通常以调用形式出现。可通过程序或说明或类图中找到。\n接口 interface 用 implements 实现；抽象类用 abstract class 用 extends 继承。 抽象类中可以有普通方法（有函数体），也可以有抽象方法（无函数体，方法前要加关键字 abstract），接口中的方法默认为抽象方法，因此无需加关键标识。 this 用来指代当前对象，一般有两个重名变量的赋值时会使用到，如在构造函数中，局部变量和成员变量相同都为 name，就要使用 this.name = name 调用父类的方法用 super 认真看类图，类图中可以看到类之间的关系以及类中的方法。 真题示例 1：\n某图书管理系统中管理着两种类型的文献：图书和论文。现在要求统计所有馆藏文献的总页码（假设图书馆中有一本 540 页的图书和两篇各 25 页的论文，那么馆藏文献的总页码就是 590 页）。采用 Visitor（访问者）模式实现该要求，得到如图 6-1 所示的类图。\n【Java 代码】\njava 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 import java.util.*; interface LibraryVisitor { ____(1)______; ____(2)______; void printSum(); } class LibrarySumPrintVisitor implements LibraryVisitor { // 打印总页数 private int sum = 0; public void visit(Book p_book) { sum = sum + p_book.getNumberOfPages(); } public void visit(Article p_article) { sum = sum + p_article.getNumberOfPages(); } public void printSum() { System.out.println(\u0026#34;SUM=\u0026#34; + sum); } } interface LibraryItemInterface { ____(3)______; } class Article implements LibraryItemInterface { private String m_title; // 论文名 private String m_author; // 论文作者 private int m_start_page; private int m_end_page; public Article(String p_author, String p_title, int p_start_page, int p_end_page) { m_title = p_title; m_author = p_author; m_start_page = p_start_page; m_end_page = p_end_page; } public int getNumberOfPages() { return m_end_page - m_start_page; } public void accept(LibraryVisitor visitor) { ____(4)______; } } class Book implements LibraryItemInterface { private String m_title; // 书名 private String m_author; // 书作者 private int m_pages; // 页数 public Book(String p_author, String p_title, int p_pages) { m_title = p_title; m_author = p_author; m_pages = p_pages; } public int getNumberOfPages() { return m_pages; } public void accept(LibraryVisitor visitor) { ____(5)______; } } 真题示例 - 2：\n试题五（共 15 分）\n阅读下列说明和 Java 代码，将应填入（n）处的字句写在答题纸的对应栏内。\n【说明】\n享元（flyweight）模式主要用于减少创建对象的数量，以降低内存占用，提高性能。现要开发一个网络围棋程序，允许多个玩家联机下棋。由于只有一台服务器，为节省内存空间，采用享元模式实现该程序，得到如图 6-1 所示的类图。\n【Java 代码】\njava 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 import java.util.*; enum PieceColor { BLACK, WHITE } // 棋子颜色 class PiecePos {\t// 棋子位置 private int x; private int y; public PiecePos(int a, int b) { x = a; y = b; } public int getX() { return x; } public int getY() { return y; } } abstract class Piece { // 棋子定义 protected PieceColor m_color;\t// 颜色 protected Piecemopos m_pos; // 位置 public Piece(PieceColor color, PiecePos pos) { m_color = color; m_pos = pos; } ______(1)______; } class BlackPiece extends Piece { public BlackPiece(PieceColor color, PiecePos pos) { super(color, pos); } public void draw() { System.out.println(\u0026#34;draw a black piece\u0026#34;); } } class WhitePiece extends Piece { public WhitePiece(PieceColor color, PiecePos pos) { super(color, pos); } public void draw() { System.out.println(\u0026#34;draw a black piece\u0026#34;); } } class PieceBoard {\t// 棋盘上已有的棋子 private static final ArrayList\u0026lt;___(2)____\u0026gt; m_arrayPiece = new ArrayList\u0026lt;\u0026gt;(); private String m_blackName; // 黑方名称 private String m_whiteName; // 白方名称 public PieceBoard(String black, String white) { m_blackName = black; m_whiteName = white; } } // 一步棋，在期盼上放一颗棋子 public void SetPiece(PieceColor color, PiecePos pos) { ____(3)____ piece = null; if (color == PieceColor.BLACK) {\t// 放黑子 piece = new BlackPiece(color, pos);\t// 获取一颗黑子 System.out.println(m_blackName + \u0026#34;在位置(\u0026#34; + \u0026#34;pos.getX()\u0026#34; + \u0026#34;,\u0026#34; + \u0026#34;pos.getY()\u0026#34; + \u0026#34;)\u0026#34;); _____(4)_____; } else { // 放白子 piece = new WhitePiece(color, pos); // 获取一颗白子 System.out.println(m_whiteName + \u0026#34;在位置(\u0026#34; + \u0026#34;pos.getX()\u0026#34; + \u0026#34;,\u0026#34; + \u0026#34;pos.getY()\u0026#34; + \u0026#34;)\u0026#34;); _____(5)_____; } m_arrayPiece.add(piece); } 真题答案 真题示例 1：\n（1）void visit(Book p_book);\n（2）void visit(Article p_article);\n（3）int getNumberOfPages();\n（4）visitor.visit(this);\n（5）visitor.visit(this);\n真题示例 2：\n（1）public abstract void draw();\n（2）Piece\n（3）Piece\n（4）piece.draw()\n（5）piece.draw()\n","permalink":"https://tofuwine.github.io/posts/88dad734/","summary":"【软件设计师】第十一章 系统分析与设计","title":"第十一章 系统分析与设计"},{"content":"一 分治 对于一个规模为 n 的问题将其分解为 k 个规模较小的子问题，这些子问题互相独立且与原问题形式相同，递归地解这些子问题，然后将各子问题的解合并得到原问题的解。\n分治法所能解决的问题一般具有以下几个特征：\n该问题的规模缩小到一定的程度就可以容易地解决。 该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质。 利用该问题分解出的子问题的解可以合并为该问题的解。 该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子问题。 二 动态规划 动态规划法与分治法类似，也是将要求解的问题一层一层地分解成一级一级、规模逐步缩小的子问题，直到可以直接求出其解的子问题为止。\n与分治法不同的是动态规划法对于重复出现的子问题，只在第一次遇到时加以求解，并把答案保存起来，让以后再遇到时直接引用，不必重复求解。\n动态规划算法的特征：\n最优子结构。问题的最优子结构性质使我们能够以自底向上的方式递归地从子问题的最优解构造出整个问题的最优解。 重叠子问题。在用递归算法自顶向下解问题时，有些子问题被反复计算多次，动态规划法对每个子问题只解一次，而后将其解保存在一个表格中，当再次需要解此问题时，可以直接查看结果。 三 贪心法 总是做出在当前来说是最好的选择，而并不从整体上加以考虑，它所做的每步选择只是当前步骤的局部最优选择，但从整体来说不一定是最优的选择。\n贪心法的特征：\n不追求最优解，只求可行解。 每一步都按贪心准则找一个解，故到 n 步后（n 为问题的规模）得到问题的所有解。如找不到所有解，则修改贪心准则，放宽贪心条件或修改算法某些细节，重新从头开始找解。 每一步所找到的解是这一步中的最优解（按贪心准则来说），但每步最优解所形成的整体解并不一定最优。 四 回溯法 称为试探法，按选优条件向前探索，以达到目标。担当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择。回溯法把问题的解空间转化成了图或者树的结构表示，然后使用深度优先搜索策略进行遍历，遍历的过程中记录和寻找所有可行解或者最优解。 基本思想类同于：\n图的深度优先搜索 二叉树的后序遍历 真题示例\n试题四（共 15 分）\n阅读下列说明和 C 代码，回答问题 1 至问题 3，将解答写答题纸的对应栏内。\n【说明】\n生物学上通常采用编辑距离来定义两个物种 DNA 序列的相似性，从而刻画物种之间的进化关系。具体来说，编辑距离是指将一个字符串变换为另一个字符所需要的最小操作次数。操作有三种，分别是：插入一个字符、删除一个字符以及将一个字符修改为另一个字符。 用字符数组 str1 和 str2 分别表示长度分别为 len1 和 len2 的字符串，定义二维数组 d 记录求解编辑距离的子问题最优解，则该二维数组可以递归定义为：\n$$ d[i][j]= \\begin{cases} i，若 len2=0 \\\\ j，若 len1=0 \\\\ d[i-1][j-1]，若 str[i-1]=str2[j-1] \\\\ min\\{d[i-1][j]+1，d[i][j-1]+1，d[i-1][j-1]+1\\}，若 str[i-1] \\neq str2[j-1] \\end{cases} $$ 【C 代码】\n下面是算法的 C 语言实现。\n（1）常量和变量说明\ntext 1 2 3 4 A，B：两个字符数组 d：二维数组 i，j：循环变量 temp：临时变量 （2）C 程序\nC 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include\u0026lt;stdio.h\u0026gt; #define N 100 char A[N]=\u0026#34;CTGA\u0026#34;; char B[N]=\u0026#34;ACGCTA\u0026#34;; int d[N][N]; int min(int a, int b) { return a \u0026lt; b ? a : b; } int editdistance(char *str1, int len1, char *str2, int len2) { int i,j; int diff; int temp; for (i=0; i\u0026lt;=len1; i++) { d[i][0]=i; } for (j=0; j\u0026lt;=len2; j++) { ____(1)_____; } for (i=1; i\u0026lt;=len1; i++) { for (j=1; j\u0026lt;=len2; j++) { if (___(2)___) { d[i][j] = d[i-1][j-1]; } else { temp = min(d[i-1][j]+1, d[i][j-1]+1); d[i][j] = min(temp, ___(3)____); } } } return ____(4)_____; } 【问题 1】（8 分）\n根据说明和 C 代码，填充 C 代码中的空（1）~（4）\n【问题 2】（4 分）\n根据说明和 C 代码，算法采用了（5）设计策略，时间复杂度为（6）（用 O 符号表示，两个字符串长度分别用 m 和 n 表示）。\n【问题 3】（3 分）\n已知两个字符串 A=\u0026ldquo;CTGA\u0026rdquo; 和 B=\u0026ldquo;ACGCTA\u0026rdquo;，根据说明和 C 代码，可得出这两个字符串的编辑距离为（7）。\n真题答案 【问题 1】\n（1）d[0][j] = j\n（2）str1[i-1] == str2[j-1]\n（3）d[i-1][j-1]+1\n（4）d[len1][len2]\n【问题 2】\n动态规划，\\$O(m*n)\\$\n【问题 3】\n4\n","permalink":"https://tofuwine.github.io/posts/523cd929/","summary":"【软件设计师】第十章 算法设计与分析","title":"第十章 算法设计与分析"},{"content":"一 章节知识架构图 二 线性结构 2.1 线性表 存储类型 特点 顺序存储 可以随机存取表中元素。插入和删除操作需要移动元素。移动元素的期望值：插入元素 n/2 个；删除元素 (n-1)/2 个 链式存储 链式存储结构有单链表、循环链表（循环单链表、循环双链表）等，其中单链表只能从头结点开始往后顺序遍历整个链表，而循环单链表可以从表中的任一结点开始遍历整个链表 真题示例 - 2.1\n设有一个包含 n 个元素的有序线性表。在等概率情况下删除其中一个元素，若采用顺序存储结构，则平均需要移动（）个元素；若采用单链表存储，则平均需要移动（）个元素。\nA. 1 B. (n-1)/2 C. Logn D. n\nA. 0 B. 1 C. (n-1)/2 D. n/2\n2.2 栈与队列 2.2.1 栈 栈的应用：表达式求值、括号匹配、递归\n1）表达式求值：\n2）括号匹配：()、[]、{}\n当扫描到左括号时，则将其压入栈中； 当扫描到右括号时，从栈顶取出一个左括号。 如果能匹配，比如(跟)匹配，[跟]匹配，{跟}匹配，则继续扫描剩下字符串。 如果扫描的过程中，遇到不能配对的右括号，或者栈中没有数据，则说明为非法格式。 当所有的括号都扫描完成之后，如果栈为空，则说明字符串为合法格式；否则说明有未匹配的左括号，为非法格式。 3）递归：\n\\$4!=4 \\times 3! = 3 \\times 2! = 2 \\times 1! = 1 \\times 0! = 1 \\times 1\\$\n2.2.1.1 顺序存储结构 预先申请栈空间，栈满则元素不能入栈。\n2.2.1.2 链式存储结构 用链表表示栈，用链表实现的栈称为链栈。由于栈中元素的插入和删除仅在栈顶一端进行，因此不必另外设置头指针，链表的头指针就是栈顶指针。\n真题示例 - 2.2\n栈的特点是后进先出，若用单链表作为栈的存储结构，并用头指针作为栈顶指针，则（）。\nA. 入栈和出栈操作都不需要遍历链表\nB. 入栈和出栈操作都需要遍历链表\nC. 入栈操作需要遍历链表而出栈操作不需要\nD. 入栈操作不需要遍历链表而出栈操作需要\n2.2.2 队列 队列的应用：打印队列。\n2.2.2.1 顺序存储 用顺序存储线性表来表示队列，为了指明当前执行出队运算的队首位置，需要一个指针变量 head（称为头指针）。为了指明当前执行进队运算的队尾位置，也需要一个指针变量 tail（称为尾指针）。\n缺点：会造成空间的浪费。\n2.2.2.2 链式存储 用链接存储线性表来实现队列，用链表实现的队列称为链接队列。\n2.2.2.3 循环队列 循环队列解决顺序存储造成空间浪费的缺点。但是会存在无法判断空队列与队列满的情况（因为此时 front 和 rear 指针都指向相同位置）。解决办法：牺牲一个元素空间，空队列时 front = rear，队列满时 front = rear + 1.\n真题示例 - 2.3\n某循环队列 Q 的定义中用 front 和 rear 两个整型域变量表示队列状态，其中 front 指示队头元素的位置，rear 指示队尾元素之后的位置（如下图所示，front 的值为 5、rear 的值为 1）。若队列容量 M （下面图中 M = 6），则计算队列长度的通式为（）。\nA. \\$\\bf (Q.front - Q.rear)\\$\nB. \\$\\bf (Q.front - Q.rear + M) \\% M\\$\nC. \\$\\bf (Q.rear - Q.front)\\$\nD. \\$\\bf (Q.rear - Q.front + M) \\% M\\$\n真题示例 - 2.4\n对于一个长度为 n(n\u0026gt;1) 且元素互异的序列，令其所有元素依次通过一个初始为空的栈后，再通过一个初始为空的队列。假设队列和栈的容量都足够大，且只要栈非空就可以进行出栈操作，只要队列非空就可以进行出队操作，那么一下叙述中，正确的是（）。\nA. 出队序列和出栈序列一定互为逆序\nB. 出队序列和出栈序列一定相同\nC. 入栈序列和入队序列一定相同\nD. 入栈序列与入队序列一定互为逆序\n2.2.2.4 双端队列 某双端队列如下图所示，要求元素进出队列必须在同一端口，即从 A 端进入的元素必须从 A 端出、从 B 端进入的元素必须从 B 端出。\n真题示例 - 2.5\n双端队列是指在队列的两个端口都可以加入和删除元素，如下图所示，现在要求元素进队列和出队列必须在同一端口。即从 a 端进队的元素必须从 a 端出，从 b 端进队的元素必须从 b 端出。则对于四个元素的序列 a、b、c、d，若要求前两个元素 a、b 从 a 端口按次序全部进入队列。后两个元素 c、d 从 b 端口按次序全部进入队列，则不可能得到的出队序列是（）。\nA. d、a、b、c\nB. d、c、b、a\nC. b、a、d、c\nD. b、d、c、a\n2.3 串 串是仅由字符构成的有限序列，是一种线性表。一般记为 \\$s='a1a2 \\cdots an'(n\u003e0)\\$，其中 s 是串的名称，用单引号括起来的是字符序列是串值。串的基本概念：\n空串：长度为零的串称为空串，空串不包含任何字符。 空格串：由一个或多个空格组成的串 子串：由串种任意长度的连续字符构成的序列称为子串。含有子串的串称为主串。空串是任意串的子串。 真题示例 - 2.6\n设 S 是一个长度为 n 的非空字符串，其中的字符各不相同，则其互异的非平凡子串（非空且不同于 S 本身）个数为（）。\nA. \\$2n-1\\$ B. \\$n^2\\$ C. \\$n(n+1)/2\\$ D. \\$(n+2)(n-1)/2\\$\n三 非线性结构 3.1 二维数组 $$ A_{m \\times n}= \\left[ \\begin{matrix} a_{11} \u0026 a_{12} \u0026 a_{13} \u0026 \\cdots \u0026 a_{1n} \\\\ a_{21} \u0026 a_{22} \u0026 a_{23} \u0026 \\cdots \u0026 a_{2n} \\\\ \\vdots \u0026 \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\vdots \\\\ a_{m1} \u0026 a_{m2} \u0026 a_{m3} \u0026 \\cdots \u0026 a_{mn} \\end{matrix} \\right] $$ 按行存储：\n$$A_{m,n}=\\big[[a_{11}a_{12} \\cdots a_{1n}],[a_{21}a_{22} \\cdots a_{2n}], \\cdots,[a_{m1}a_{m2} \\cdots a_{mn}]\\big]$$ 按列存储：\n$$A_{m,n}=\\big[[a_{11}a_{21} \\cdots a_{m1}],[a_{12}a_{22} \\cdots a_{m2}], \\cdots,[a_{1n}a_{2n} \\cdots a_{mn}]\\big]$$ 真题示例 - 3.1\n某 n 阶矩阵 A 如下图所示，按行将元素存储在一堆数组 M 中，设 \\$a_{1,1}\\$ 存储在 M[1]，那么 \\$a_{i,j}\\$(1 \u0026lt;= i, j \u0026lt;= n且 \\$a_{i,j}\\$ 位于三条对角线中），存储在 M（）。\nA. \\$i+2j\\$ B. \\$2i+j\\$ C. \\$i+2j-2\\$ D. \\$2i+j-2\\$\n3.2 树 考试只考二叉树\n父亲、孩子和兄弟 结点的度 叶子结点 内部结点 层次 树的高度 树的三种形式：\n3.2.1 二叉树 在二叉树的第 i 层最多有 \\$2^{i-1}\\$ 个结点（\\$i \\geq 1\\$） 深度为 k 的二叉树最多有 \\$2^k-1\\$ 个结点（\\$k \\geq 1\\$） 对于任何一棵二叉树，如果其叶子结点数为 \\$N_0\\$，度为 2 的结点数为 \\$N_2\\$，则 \\$N_0=N_2+1\\$ 具有 n 个结点的完全二叉树的深度为 \\$\\lfloor \\log_2n \\rfloor +1\\$\n如果 \\$i=1\\$，则结点 \\$i\\$ 无父结点，是二叉树的根\n如果 \\$i\u003e1\\$，则父结点是 \\$\\lfloor i/2 \\rfloor\\$\n如果 \\$2i\u003en\\$，则结点 \\$i\\$ 为叶子结点，无左子结点，否则其左子结点是 \\$2i\\$\n如果 \\$2i+1\u003en\\$，则结点 \\$i\\$ 无右子结点，否则，其右子结点是 \\$2i+1\\$ 3.2.2 二叉树的遍历 遍历方式 结果 层次遍历 1、2、3、4、5、6、7、8 前序遍历 （根、左、右） 1、2、4、5、7、8、3、6 中序遍历 （左、根、右） 4、2、7、8、5、1、3、6 后序遍历 （左、右、根） 4、8、7、5、2、6、3、1 真题示例 - 3.2\n某二叉树的中序，先序遍历序列分别为 {20，30，10，50，40}，{10，20，30，40，50} 则该二叉树的后序遍历序列为（）。\nA. 50，40，30，20，10\nB. 30，20，10，50，40\nC. 30，20，50，40，10\nD. 20，30，10，40，50\n真题示例 - 3.3\n二叉树的高度是指其层数，空二叉树的高度为 0，仅有根结点的二叉树高度为 1。若某二叉树中共有 1024 个结点，则该二叉树的高度是整数区间的（）中的任一值。\nA. (10, 1024) B. [10, 1024]\nC. (11, 1024) B. [11, 1024]\n3.2.3 二叉树的存储 3.2.3.1 顺序存储 真题示例 - 3.4\n对下面的二叉树进行顺序存储（用数组 MEM 表示），已知结点 A、B、C 在 MEM 中对应元素的下标分别为 1、2、3，那么结点 D、E、F 对应的数组元素下标为（）。\nA. 4、5、6 B. 4、7、10 C. 6、7、8 D. 6、7、14\n3.2.3.2 链式存储 3.2.4 二叉查找树 二叉排序树又称为二叉查找树，其定义为二叉排序树或者是一棵空二叉树，或者是具有如下性质的二叉树：\n（1）若它的左子树非空，则左子树上所有结点的值均小于根结点。\n（2）若它的右子树非空，则右子树上所有结点的值均大于根结点。\n（3）左、右子树本身右各是一个二叉排序树。\n如果中序遍历二叉排序树，就能得到一个排好序的结点序列。\n3.2.5 哈夫曼树 给定 N 个权值作为 N 个叶子结点，构造一棵二叉树，若该树的带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树（Huffman Tree）。哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近。\n真题示例 - 3.5\n已知一个文件中出现的各字符及其对应的频率如下表所示。采用 Huffman 编码，则该文件中字符 a 和 c 的码长分别为（）。若采用 Huffman 编码，则字符序列 110001001101 的编码应为（）。\n字符 a b c d e f 频率 (%) 45 13 12 16 9 5 A. 1 和 3 B. 1 和 4 C. 3 和 3 D. 3 和 4\nA. face B. bace C. acde D. fade\n3.3 图 图 G 由两个集合 V 和 E 组成，记为 \\$G = (V,E)\\$，其中 V 是顶点的有穷非空集合，E 是 V 中顶点偶对（称为边）的有穷集合。通常，也将图 G 的顶点集和边集分别记为 V(G) 和 E(G)。E(G) 可以是空集。若 E(G) 为空，则图 G 只有顶点而没有边。\n3.3.1 完全图 若一个无向图具有 n 个顶点，而每个顶点与其他 n-1 个顶点之间都有边，则称为无向完全图。无向完全图共有 \\$\\bf \\frac{n(n-1)}{2}\\$ 条边。\n有 n 个顶点的有向完全图中弧的数目为 \\$n(n-1)\\$，即任意两个不同顶点之间都有方向相反的两个弧存在。\n3.3.2 连通图 在无向图 G 中，若从顶点 \\$V_i\\$ 到顶点 \\$V_j\\$ 有路径，则称顶点 \\$V_i\\$ 和顶点 \\$V_j\\$ 是连通的。如果无向图 G 中任意两个顶点都是连通的，则称其为连通图。\n3.3.3 强连通图 有向图中，若任意两个顶点 \\$V_i\\$ 和 \\$V_j\\$，满足从 \\$V_i\\$ 到 \\$V_j\\$ 以及从 \\$V_j\\$ 到 \\$V_i\\$ 都连通，也就是都含有至少一条通路，则称为强连通图。有向图中的极大连通图子图称为有向图的强连通分量。\n3.3.4 图的存储结构 3.3.4.1 邻接矩阵 有向图的邻接矩阵不一定对称。\n无向图的邻接矩阵是对称的。\n3.3.4.2 邻接表 在图的邻接表中，为图的每个顶点建立一个链表，且第 i 个链表中的结点代表与顶点 i 相关联的一条边或由顶点 i 出发的一条弧。有 n 个顶点的图，需要用 n 个链表表示，这 n 个链表的头指针通常由顺序线性表存储。\n3.3.5 图的遍历 图的遍历是指从某个顶点出发，沿着某条搜索路径对图中的所有顶点进行访问且只访问一次的过程。\n方法 示例 特征 深度优先 DFS V1,V2 V4,V8 V5,V3 V6,V7 相当于树的前序遍历。邻接矩阵表示的时间复杂度 \\$O(n^2)\\$，邻接表表示的实际复杂度是 \\$O(n+e)\\$ 广度优先 BFS V1,V2 V3,V4 V5,V6 V7,V8 相当于树的层次遍历。时间复杂度同上 真题示例 - 3.6\n图 G 的邻接矩阵如下图所示（顶点依次表示为 v0, v1, v2, v3, v4, v5），G 是（）。对 G 进行广度优先遍历（从 v0 开始），可能的遍历序列为（）。\n$$ \\left[ \\begin{matrix} \\infty \u0026 18 \u0026 17 \u0026 \\infty \u0026 \\infty \u0026 \\infty \\\\ \\infty \u0026 \\infty \u0026 \\infty \u0026 20 \u0026 16 \u0026 \\infty \\\\ \\infty \u0026 19 \u0026 \\infty \u0026 23 \u0026 \\infty \u0026 \\infty \\\\ \\infty \u0026 \\infty \u0026 \\infty \u0026 \\infty \u0026 \\infty \u0026 15 \\\\ \\infty \u0026 \\infty \u0026 \\infty \u0026 \\infty \u0026 \\infty \u0026 12 \\\\ \\infty \u0026 \\infty \u0026 \\infty \u0026 \\infty \u0026 \\infty \u0026 \\infty \\\\ \\end{matrix} \\right] $$ A. 无向图 B. 有向图 C. 完全图 D. 强连通图\nA. v0、v1、v2、v3、v4、v5\nB. v0、v2、v4、v5、v1、v3\nC. v0、v1、v3、v5、v2、v4\nD. v0、v2、v4、v3、v5、v1\n真题示例 - 3.7\n对于如下所示的有向图，其邻接矩阵是一个（）的矩阵，采用邻接链表存储时顶点的表结点个数为 2，顶点 5 的表结点个数为 0，顶点 2 和 3 的表结点个数分别为（）。\nA. 5*5 B. 5*7 C. 7*5 D. 7*7\nA. 2.1 B. 2.2 C. 3.4 D. 4.3\n四 数据运算 4.1 时间复杂度 4.1.1 \\$O(1)\\$ c 1 2 3 Temp=i; i=j; j=temp; 以上三条单个语句的频度均为 1，是一个常数阶，记作 \\$T(n)=O(1)\\$。此算法的执行时间不随着问题规模 n 的增加而增长，即使算法中有上千条语句，其执行时间也不过是一个较大的常数。此算法的时间复杂度是 \\$O(1)\\$。\n4.1.2 \\$O(n)\\$ c 1 2 3 4 5 int sum = 0; for (int i = 0; i \u0026lt;= n; ++i) { sum += i; } 一共算了 n 次加法，那么就说这个时间复杂度是 \\$O(n)\\$。比如，某个计算共计算了 \\$2n+1\\$ 次，那么这个时间复杂度也是 \\$O(n)\\$\n4.1.3 \\$O(n^2)\\$ c 1 2 3 4 5 6 7 8 int sum=0; for (int i = 0; i \u0026lt;= n; ++i) { for (int j = 0; j \u0026lt;= n; ++j) { sum += (i + j) } } 4.1.4 \\$\\log_2(n)\\$ 二分查找每次排除掉一半不适合值，所以对于 n 个元素的情况：\n一次二分剩下：\\$n/2\\$ 两次二分剩下：\\$n/2/2 = n/4\\$ 三次二分剩下：\\$n/4/2 = n/8\\$ m 次二分剩下：\\$n/(2^m)\\$ 在最坏情况下是在排除到只剩下最后一个值之后得到结果，所以为 \\$\\frac{n}{(2^m)}=1 \\Rightarrow n=2^m\\$，所以时间复杂度为 \\$\\log_2(n)\\$\n4.2 查找算法 4.2.1 顺序查找 将待查的元素从头到尾与表中元素进行比较，如果存在，则返回成功；否则，查找失败。此方法效率不高，平均查找长度 \\$\\textcolor{red}{(n+1)/2}\\$（设置监视哨）\n4.2.2 二分查找 【例题】请给出在含有 12 个元素的有序表 {1，4，10，16，17，18，23，29，33，40，50，51} 中二分查找关键字 17 的过程。\n4.2.3 哈希查找 哈希表 hashtable 通过一个已记录的关键字为自变量的函数（哈希函数）得到该记录的存储地址，所以在哈希表中进行查找操作时，需用同一个哈希函数计算得到待查记录的存储地址，然后到相应的存储单元去获取有关信息再判定查找是否成功。\n冲突的解决方式：随机探测再散列、线性探测。\n【例题】设关键码序列为”47，34，13，12，52，38，33，27，3”，哈希表表长为 11，哈希函数为 Hash(key)=key mod 11，则\nHash(47) = 47 MOD 11 = 3, Hash(34) = 34 MOD 11 = 1,\nHash(13) = 13 MOD 11 = 2, Hash(12) = 12 MOD 11 = 1,\nHash(52) = 52 MOD 11 = 8, Hash(38) = 38 MOD 11 = 5,\nHash(33) = 33 MOD 11 = 0, Hash(27) = 27 MOD 11 = 5,\nHash(3) = 3 MOD 11 = 3\n使用线性探测法解决冲突构造的哈希表如下：\n哈希地址 0 1 2 3 4 5 6 7 8 9 10 关键字 33 34 13 47 12 38 27 3 52 使用链地址法构造的哈希表如图所示：\n上图所示的哈希表中进行成功查找的平均查找长度 ASL 为 $6 \\times 1 + 3 \\times 2)/9 \\approx 1.34$\n真题示例 - 4.1\n设散列函数为 $H（key）= key \\mod 11$ 对于关键字序列（23，40，91，17，19，10，31，65，26），用线性探测法解决冲突构造的哈希表为（）。\n4.3 排序算法 排序方法 时间复杂度\n最好 时间复杂度\n最坏 时间复杂度\n平均 稳定性 直接插入 \\$O(n) \\$ \\$O(n^2) \\$ \\$O(n^2) \\$ 稳定 简单选择 \\$O(n^2) \\$ \\$O(n^2) \\$ \\$O(n^2) \\$ 不稳定 冒泡排序 \\$O(n) \\$ \\$O(n^2) \\$ \\$O(n^2) \\$ 稳定 希尔排序 \\$O(n) \\$ \\$O(n^{1.3}) \\$ \\$O(n^{1.3}) \\$ 不稳定 快速排序 \\$O(n^2) \\$ \\$O(n\\log_2{n}) \\$ \\$O(n\\log_2{n}) \\$ 不稳定 堆排序 \\$O(n\\log_2{n}) \\$ \\$O(n\\log_2{n}) \\$ \\$O(n\\log_2{n}) \\$ 不稳定 归并排序 \\$O(n\\log_2{n}) \\$ \\$O(n\\log_2{n}) \\$ \\$O(n\\log_2{n}) \\$ 稳定 4.3.1 直接插入排序 抱歉，此节笔记缺失 4.3.2 冒泡排序 【例题】排序数组：int[] arr = {6,3,8,2,9,1}\n第一趟排序：\n第一次排序：6 和 3 比较，6 大于 3，交换位置：3 6 8 2 9 1 第二次排序，6 和 8 比较，6 小于 8，不交换位置：3 6 8 2 9 1 第三次排序：8 和 2 比较，8 大于 2，交换位置：3 6 2 8 9 1 第四次排序：8 和 9 比较，8 小于 9，不交换位置：3 6 2 8 9 1 第五次排序：9 和 1 比较，9 大于 1，交换位置：3 6 3 8 1 9 第一趟总共进行了 5 次比较，排序结果：3 6 2 8 1 9\n第二趟排序：\n第一次排序：3 和 6 比较，3 小于 6，不交换位置：3 6 2 8 1 9 第二次排序：6 和 2 比较，6 大于 2，交换位置：3 2 6 8 1 9 第三次排序：6 和 8 比较，6 大于 8，不交换位置：3 2 6 8 1 9 第四次排序：8 和 1 比较，8 大于 1，交换位置：3 2 6 1 8 9 第二趟总共进行了 4 次比较，排序结果：3 2 6 1 8 9\n第三趟排序：\n第一次排序：3 和 2 比较，3 大于 2，交换位置：2 3 6 1 8 9 第二次排序：3 和 6 比较，3 小于 6，不交换位置：2 3 6 1 8 9 第三次排序：6 和 1 比较，6 大于 1，交换位置：2 3 1 6 8 9 第三趟总共进行了 3 次排序，排序结果：2 3 1 6 8 9\n第四趟排序：\n第一次排序：2 和 3 比较，2 小于 3，不交换位置：2 3 1 6 8 9 第二次排序：3 和 1 比较，3 大于 1，交换位置：2 1 3 6 8 9 第四趟总共进行了 2 次排序，排序结果：2 1 3 6 8 9\n第五趟排序：\n第一次排序：2 和 1 比较，2 大于 1，交换位置：1 2 3 6 8 9 第五趟总共进行了 1 次排序，排序结果：1 2 3 6 8 9\n最终结果：1 2 3 6 8 9\n4.3.3 简单选择排序 初始关键字：【8，5，2，6，9，3，1，4，0，7】\n第一趟排序后：0，【5，2，6，9，3，1，4，8，7】\n第二趟排序后：0，1，【2，6，9，3，5，4，8，7】\n第三趟排序后：0，1，2，【6，9，3，5，4，8，7】\n第四趟排序后：0，1，2，3，【9，6，5，4，8，7】\n第五趟排序后：0，1，2，3，4，【6，5，9，8，7】\n第六躺排序后：0，1，2，3，4，5，【6，9，8，7】\n第七趟排序后：0，1，2，3，4，5，6，【9，8，7】\n第八趟排序后：0，1，2，3，4，5，6，7，【8，9】\n第九趟排序后：0，1，2，3，4，5，6，7，8，【9】\n结果：【0，1，2，3，4，5，6，7，8，9】\n4.3.4 希尔排序 先将整个待排元素序列分割成若干个子序列（由相隔某个“增量”的元素组成的）分别进行直接插入排序，然后依次缩减增量再进行排序，待整个序列中的元素基本有序（增量足够小）时，再对全体元素进行一次直接插入排序。因为直接插入排序再元素基本有序的情况下（接近最好情况），效率是最高的。\n先取一个小于 n 的整数 d1，作为第一个增量，把文件的全部记录分成 d1 个组，即将所有距离为 d1 倍数序号的记录放在同一个组中，在组内进行直接插入排序；然后取第二个增量 d2 \u0026lt; d1，重复上述步骤，依次类推，直到所取的增量 di = 1，即将所有记录放在同一组进行直接插入排序。\n4.3.5 快速排序 初始状态：46 30 82 90 56 17 95 15\n4.3.6 堆排序 对于 n 个元素的关键字序列 \\$\\{K_1,K_2, \\cdots, K_n\\}\\$，当且仅当满足下列关系时称其为堆，其中 \\$2i\\$ 和 \\$2i+1\\$ 应不大于 n。 $$ \\begin{cases} K_i \\leq K_{2i} \\\\ K_i \\leq K_{2i+1} \\end{cases} 或 \\begin{cases} K_i \\geq K_{2i} \\\\ K_i \\geq K_{2i+1} \\end{cases} $$ 为序列（55，60，40，10，80，65，15，5，75）建立初始大根堆的过程如图 3-56 所示，调整为新堆的过程如图 3-57 所示。\n4.3.7 归并排序 （1）分解。将 n 个元素分层各含 n/2 个元素的子序列。\n（2）求解。用归并排序对两个子序列递归地排序。\n（3）合并。合并两个已经排好序的子序列以得到排序结果。\n真题答案 题号 答案 2.1 B、A 2.2 A 2.3 D 2.4 B 2.5 A 2.6 D 3.1 D 3.2 C 3.3 D 3.4 D 3.5 A、A 3.6 B、A 3.7 A、B 4.1 B ","permalink":"https://tofuwine.github.io/posts/1ed9ada6/","summary":"【软件设计师】第九章 数据结构","title":"第九章 数据结构"},{"content":"一 章节知识架构图 二 软件测试 2.1 静态测试 指被测试程序不在机器上运行，而采用人工检测和计算机辅助静态分析的手段对程序进行监测。静态测试包括对文档的静态测试和对代码的静态测试。对文档的静态测试主要以检查单的形式进行，而对代码的静态测试一般采用桌前检查、代码审查和代码走查。 在静态测试中，主要是对程序代码进行静态分析，包括控制流分析、数据流分析、接口分析和表达式分析。\n2.2 动态测试 2.2.1 白盒测试 白盒测试也称为结构测试，主要用于软件单元测试阶段。包括控制流测试（各类覆盖测试）、数据流测试、程序变异测试。\n2.2.1.1 语句覆盖 语句覆盖是指选择足够多的测试用例，使得运行这些测试用例时，被测程序的每个语句至少执行一次。很显然，语句覆盖是一种很弱的覆盖标准。\n2.2.1.2 判定（分支）覆盖 判定覆盖也称为分支覆盖，它是指不仅每个语句至少执行一次，而且每个判定的每种可能得结果（分支）都至少执行一次。判定覆盖比语句覆盖强，但对程序逻辑的覆盖程序仍然不高。\n2.2.1.3 条件覆盖 条件覆盖是指不仅每个语句至少执行一次，而且判定式中的每个条件都取得各种可能得结果。条件覆盖不一定包含判定覆盖，判定覆盖也不一定包含条件覆盖。判定覆盖只关心判定表达式的值（真/假），而条件覆盖涉及到判定表达式的每个条件的值（真/假）\n2.2.1.4 路径覆盖 路径覆盖是指选取足够的测试用例，使得程序的每条可能执行到的路径都至少经过一次（如果程序中有环路，则要求每条环路路径至少经过一次）。路径覆盖实际上考虑了程序中各种判定结果的所有可能组合，因此是一种较强的覆盖标准。\n真题示例 - 2.1\n下图是用白盒测试方法进行测试，图中有（）条路径。采用 McCabe 度量计算该程序图的环路复杂性为（）。 A. 3 B. 4 C. 5 D. 6\nA. 3 B. 4 C. 5 D. 6\nMcCabe 计算公式：圈数 + 1 真题示例 - 2.2\n系统交付用户使用了一段时间后发现，系统的某个功能响应非常慢。修改了某模块的一个算法，使其运行速度得到了提升。则该行为属于（）维护。\nA. 改正性 B. 适应性 C. 改善型 D. 预防性\n2.2.2 黑盒测试 黑盒测试也称为功能测试，主要用于集成测试、确认测试和系统测试阶段。黑盒测试根据 SRS 所规定的功能来设计测试用例，一般包括功能分解、等价类划分、边界值分析、判定表、因果图、状态图、随机测试、错误推测和正交实验法等。\n真题答案 题号 答案 2.1 B、B 2.2 C ","permalink":"https://tofuwine.github.io/posts/dc8a547c/","summary":"【软件设计师】第八章 软件测试与维护","title":"第八章 软件测试与维护"},{"content":"一 章节知识架构图 二 UML 图 UML 图 描述 用例图 由参与者（Actor）、用例（Use Case），边界以及它们之间的关系构成的用于描述系统功能的视图 类图 展现了一组对象、接口、协作和它们之间的关系。类之间的关系有关联、依赖、实现、泛化 对象图 描述一组对象它们之间的关系。对象图描述了在类图中所建立的事物实例的静态快照 构件图 描述一个封装的类和它的接口、端口，以及由内嵌的构件和连接件构成的内部结构 组合结构图 用于画出结构化类的内部内容 顺序图\n(序列图) 由一组对象或参与者以及它们之间可能发送的消息构成。强调消息的时间次序的交互图。 通信图 强调收发消息的对象或参与者的结构组织。强调的是对象之间的组织结构（关系） 定时图 强调消息跨越不同对象或参与者的实际时间，而不仅仅只是关心消息的相对顺序 状态图 用来描述一个特定的对象所有可能得状态，以及由于各种事件的发生而引起的状态之间的转移和变化 活动图 将进程或其他计算的结构展示为计算内部一步步的控制流和数据流 部署图 软件和硬件组件之间的物理关系以及处理节点的组件分布情况 制品图 描述计算机中一个系统的物理结构通常与部署图一起使用 包图 描述由模型本身分解而成的组织单元，以及它们之间的依赖关系 交互概览图 是活动图和顺序图的混合物 2.1 用例图 定义：用例图是指由参与者（Actor）、用例（Use Case），边界以及它们之间的关系构成的用于描述系统功能的视图。\n用例图（User Case）是外部用户（被称为参与者）所能观察到的系统功能的模型图。用例图是系统的蓝图，用于需求分析阶段。\n包含关系\n基用例 \u0026mdash;\u0026mdash;\u0026gt; 子用例\n扩展关系\n基用例 \u0026lt;\u0026mdash;\u0026ndash; 子用例\n泛化关系\n2.2 类和对象图 2.2.1 类的分类： （1）实体类：实体类对应系统需求中的每一个实体，它们通常需要保存在永久存储体中，一般使用数据库表或文件来记录，实体类既包括存储和传递数据的类，还包括操作数据的类。实体类来源于需求说明中的名词，如学生、商品等。\n（2）控制类：控制类用于体现应用程序的执行逻辑，提供相应的业务操作，将控制类抽象出来可以降低界面和数据库之间的耦合度。控制类用于对一个或几个用例所特有的控制行为进行建模。控制对象（控制类的实例）通常控制其他对象，因此它们的行为具有协调性质。控制类将用例的特有行为进行封装。\n（3）接口类（边界类）：边界类用于对外部用户与系统之间的交互对象进行抽象，主要包括界面类，如对话框、窗口、菜单等。\n历年真题 - 2.1\n在某销售系统中，客户采用扫描二维码进行支付。若采用面向对象方法开发该销售系统，则客户类属于（）类，二维码类属于（）类。\nA. 接口 B. 实体 C. 控制 D. 状态\nA. 接口 B. 实体 C. 控制 D. 状态\n2.2.2 类之间的关系 关联关系\n是一种拥有关系，关联提供了不同类的对象之间的结构关系，它在一段时间内将多个类的实例连接在一起。\n聚合关系\n共享聚集关系通常简称为聚合关系，表示类之间的整体与部分的关系。其含义是“部分”可能同时属于多个“整体”，“部分”与“整体”的生命周期可以不相同。\n组合关系\n简称为组合关系，它也是表示类之间的整体与部分的关系。与集合关系的区别在于，组合关系中的“部分”只能属于一个“整体”，“部分”与“整体”的生命周期相同，“部分”随着“整体”的创建而创建，也随着“整体”的消亡而消亡。\n依赖关系\n是一种使用的关系，即一个类的实现需要另一个类的协助，所以要尽量不使用双向的互相依赖。可以简单的理解，就是一个类 A 使用到了另一个类 B。依赖可以由各种原因引起，如，一个类向另一个类发送消息，一个类是另一个类的数据成员、一个类是另一个类的某个操作参数等。\n实现关系\n实现关系将说明和实现联系起来。一个或多个类可以实现一个接口，而每个类分别实现接口中的操作。\n2.3 状态图 2.4 活动图 状态图 活动图 用来描述一个特定的对象所有可能得状态，以及由于各种事件的发生而引起的状态之间的转移和变化 将进程或其他计算的结构展示为计算内部一步步的控制流和数据流，主要用来描述系统的动态视图 状态图主要描述行为的结果 活动图主要描述行为的动作 用于对系统的动态方面建模 用于对系统的动态方面建模 2.5 序列图 （顺序图） 2.6 协作图（通信图） 序列图 协作图 序列图主要用来更直观的表现各个对象交互的时间顺序，将体现的重点放在以时间为参照，各个对象发送、接收消息，处理消息，返回消息的时间流程顺序，也称为时序图 协作图是一种类图，强调参与交互的各个对象的结构信息和组织 共同点：时序图与协作图均显示了对象间的交互。\n不同点：时序图强调交互的时间次序，协作图强调交互的空间结构。\n2.7 构件图（组件图） 构件图描述了软件的各种构件和他们之间的依赖关系。构件图由源文件代码、二进制代码、可执行文件或动态链接库（DLL）等构件组成，并通过依赖关系相连接。\n使用构件图的思想是复用。就像我们盖房子，当房子的大体框架建好之后，剩下的门和窗户家具之类的直接拿来安装上即可，不需要再重新制作，直接拿来复用的思想。这些门和窗户就相当于一个个的构件。\n2.8 部署图 用来显示系统中软件和硬件的物理架构。从部署图中，可以了解到软件和硬件组件之间的物理关系以及处理节点的组件分布情况。使用部署图可以显示运行时系统的结构，同时还传达构成应用程序的硬件和软件元素的配置和部署方式。\n2.9 包图 包被描述成文件夹，可以用于 UML 任何一种的图上。它是一种维护和描述系统总体结构的模型的重要建模工具，通过对包中各个包以及包之间关系的描述，展示出系统的模块与模块之间的依赖关系。\n包图可以描述需求，设计的高阶概况；包图通过合理规划自身功能反应系统的高层架构，在逻辑上将系统进行模块化分解；包图最终是组织源码的方式。\n一个包图可以由任何一种 UML 图组成，通常是 UML 用例图或者 UML 类图。包图只是把某些类放在一个包中，因此可以看做是类图的一种。\n2.10 其他 组合结构图 定时图 制品图 交互概览图 描述结构化类（例如，构建或类）的内部结构，包括结构化类与系统其余部分的交互点。组合结构图用于画出结构化类的内部内容 也称计时图，定时图也是一种交互图，它强调消息跨越不同对象或参与者的实际时间，而不仅仅只是关系消息的相对顺序 描述计算机中一个系统的物理结构。制品包括文件、数据库和类似的物理比特集合。制品图通常与部署图一起使用。制品也给出了它们实现的类和构建。 是活动图和顺序图的混合物 真题示例 - 2.2\n在 UML 图中，（）图用于展示所交付系统中软件和硬件之间的物理关系。\nA. 类 B. 组件 C. 通信 D. 部署\n真题示例 - 2.3\n如图所示的 UML 类图中，Shop 和 Magazine 之间为（）关系，Magazine 和 Page 之间为（）关系。UML 类图通常不用于对（）进行建模。 （1）A. 关联 B. 依赖 C. 组合 D. 继承\n（2）A. 关联 B. 依赖 C. 组合 D. 继承\n（3）A. 系统的词汇 B. 简单的协作 C. 逻辑数据库模式 D. 对象快照\n三 面向对象设计原则 原则 描述 单一职责原则 设计目的单一的类 开放-封闭原则 对扩展开放，对修改封闭 里氏替换原则 子类可以替换父类 依赖倒置原则 要依赖于抽象，不是具体实践。对接口进行编程，不要对实现编程。 接口隔离原则 使用多个专门的接口比使用单一的总接口好 组合重用原则 尽量使用组合而不是继承达到重用的目的 迪米特原则\n(最少知识) 一个对象应当对其他对象有尽可能少的了解 真题示例 - 3.1\n在面向对象设计的原则中，（）原则是指抽象不应该依赖于细节，细节应该依赖于抽象，即应针对接口编程，而不是针对实现编程\nA. 开闭 B. 里氏替换 C. 最少知识 D. 依赖倒置\n四 设计模式 类型 描述 说明 创建型模式 用于创建对象 工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。共五种。口诀：单抽元件（建）厂 结构性模式 处理类或对象的组合 适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。共七种。口诀：外侨（桥）组员（元）戴（代）配饰 行为型模式 描述类于对象怎样交互、怎样分配职责 策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。共十一种。口诀：观摩（模）对（迭）策，责令解放（访），戒（介）忘台（态） 二十三种设计模式特点如下：\n目的 设计模式 简要说明 特征 创建型 Abstract Factory\n抽象工厂 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类 抽象接口 Builder\n建造者 将一个复杂的对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示 类与构造分离 Factory Method\n工厂方法 定义一个用于创建对象的接口，让子类决定将哪一个类实例化。使一个类的实例化延迟到其子类 子类实例化对象 Prototype\n原型 用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象 复用、拷贝原型 Singleton\n单例 保证一个类仅有一个实例，并提供一个访问它的全局访问点 唯一实例 结构型 Adapter\n适配器 将一个类的接口转换成客户希望的另外一个接口。Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作 接口转换、兼容 Bridge\n桥接 将抽象部分与它的实际部分分离，使它们都可以独立地变化 抽象实现分离 Composite\n组合模式 将对象组合成树形结构以表示“部分-整体”的层次结构。Composite 使得客户对单个对象和复合对象的使用具有一致性 整体-部分\n树形结构 Decorator\n装饰模式 动态地给一个对象添加一些额外的职责。就扩展功能而言，Decorator 模式比生成子类方式更为灵活 附加职责 Facade\n外观模式 为子系统中的一组接口提供一个一致的界面，外观模式通过提供一个高层接口，隔离了外部系统与子系统间复杂的交互过程，使得复杂系统的子系统更易使用 对外统一接口 Flyweight\n享元模式 运用共享技术有效地支持大量细粒度的对象 细粒度复用、共享 Proxy\n代理模式 为其他对象提供一种代理以控制对这个对象的访问。代理模式使用代理对象完成用户请求，屏蔽用户对真实对象的访问 代理控制 行为型 Chain of Responsibility\n责任链模式 避免请求发送者与请求接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止 传递请求、职责、链接 Iterator\n迭代器模式 提供一种方法顺序访问一个聚合对象中各个元素，而又无需暴露该对象的内部表示 顺序访问 Mediator\n中介者模式 用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互 不直接引用 Memento\n备忘录模式 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样就可以将该对象恢复到原先保存的状态 保存、恢复 Observer\n观察者模式 观察者模式定义了对象间一种一对多依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新 通知、自动更新 State\n状态模式 允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类 状态变成类 Strategy\n策略模式 策略模式定义了一系列算法，并将每一个算法封装起来，而且使它们还可以相互替换。策略模式让算法独立于使用它的客户而独立变化 算法替换 Command\n命令模式 将一个请求封装成一个对象，从而使得用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作 参数化、日志记录 Interpreter\n解释器模式 给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子 文法、解释 Template Method\n模板方法 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤 算法结构不变，子类定义步骤 Visitor\n访问者模式 表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。即对于某个对象或一组对象，不同的访问者，产生的结果不同，执行操作也不同 类不变、新操作 真题示例 - 4.1\n以下设计模式中，（）模式使多个对象都有机会处理请求。将这些对象连成一条链。并沿着这条链传递该请求。直到有一个对象处理为止。从而避免请求的发送者和接收者之间的耦合关系。（）模式提供了一种方法顺序访问一个聚合对象中的各个元素。且不需要暴露该对象的内部表示。这两个模式均为（）。\nA. 责任链（Chain of Responsibility） B.解释器（Interpreter） C. 命令（Command） D.迭代器（Iterator）\nA. 责任链（Chain of Responsibility） B.解释器（Interpreter） C. 命令（Command） D.迭代器（Iterator）\nA. 创建型对象模式 B. 结构型对象模式 C. 行为型对象模式 D. 行为型类模式\n真题示例 - 4.2\n观察者（Observer）模式适用于（）。\nA. 访问一个聚合对象的内容，而无需暴露它的内部表示\nB. 减少多个对象或类之间的通信复杂性\nC. 将对象的状态恢复到先前的状态\nD. 一个多对象依赖关系。当一个对象修改后，依赖他的对象都自动得到通知。\n案例分析 【说明】\n某图书公司欲开发一个基于 Web 的书籍销售系统，为顾客（Customer）提供在线购买书籍（Books）的功能，同时对公司书籍的库存及销售情况进行管理。系统的主要功能描述如下：\n首次使用系统时，顾客需要在系统中注册（Register detail）。顾客填写注册信息表要求的信息，包括姓名（name）、收货地址（address）、电子邮箱（email）等，系统将为其生成一个注册码。 注册成功的顾客可以登录系统在线购买书籍（Buy books）。购买时可以浏览书籍信息，包括书名（title）、作者（author）、内容间接（introduction）等。如果某种书籍的库存量为 0，那么顾客无法查询到该书籍的信息。顾客选择所需购买的书籍及购买数量（quantities），若购买数量超过库存量，提示库存不足；若购买数量小于库存量，系统将显示验证界面，要求顾客输入注册码。注册码验证正确后，自动生成订单（Order），否则，提示验证错误。如果顾客需要，可以选择打印订单（Printorder）。 派送人员（Dispatcher）每天早晨从系统中获取当日的派送列表信息（Produce picklist），按照收货地址派送顾客订购的书籍。 用于销售的书籍由公司的采购人员（Buyer）进行采购（Reorderbooks）。采购人员每天从系统中获取库存量低于再次订购量的书籍信息，对这些书籍进行再次购买，以保证充足的库存量。新书籍到货时，采购人员向在线销售目录（Catalog）中添加新的书籍信息（Addbooks）。 采购人员根据书籍的销售情况，对销量较低的书籍设置折扣或促销活动（Promote books）。 当新书籍到货时，仓库管理员（Warehouseman）接收书籍，更新库存（Update stock）。 现采用面向对象方法开发书籍销售系统，得到如图 3-1 所示的用例图和图 3-2 所示的初始类图（部分）。\n【问题 1】（6 分）\n根据说明中的描述，给出图 3-1 中 A1-A3 所对应的参与者名称和 U1-U3 处所对应的用例名称。\n【问题 2】（6 分）\n根据说明中的描述，给出图 3-1 中用例 U3 的用例描述。（用例描述中必须包括基本事件流和所有的备选事件流）\n【问题 3】（3 分）\n根据说明中的描述，给出图 3-2 中 C1-C3 所对应的类名。\n真题答案 题号 答案 2.1 B、A 2.2 D 2.3 A、C、D 3.1 D 4.1 A、D、C 4.2 D 案例分析\n【问题 1】\nA1：Buyer\nA2：Warehouseman\nA3：Dispatcher\nU1：Register detail\nU2：Printorder\nU3：Buy books\n【问题 2】\n【问题 3】\nC1：Customer\nC2：Order\nC3：Books\n","permalink":"https://tofuwine.github.io/posts/ca1c0cac/","summary":"【软件设计师】第七章 面向对象技术","title":"第七章 面向对象技术"},{"content":"一 章节知识架构图 二 结构化方法 结构化方法也称为生命周期法，由结构化分析、结构化设计和结构化程序设计三部分组成。\n优点：开发目标清晰化、开发工作阶段化、开发文档规范化、设计方法结构化。\n缺点：开发周期长、难以适应需求变化、很少考虑数据结构。\n三 结构化分析 结构化分析：自顶向下，逐层分解、模块化、面向数据流。DFD 数据流图、E-R 图\n面向对象分析：复用性好。用例与用例图\n3.1 数据流图 顶层数据流图：展示系统大概得功能\n0 层数据流图\n3.1.1 数据流图说明 3.1.2 数据流图注意事项 名称 注意事项 数据流 数据流的流向：\n① 从一个加工流向另一个加工 ② 从加工流向数据存储（写）\n③ 从数据存储流向加工（读）\n④ 从外部实体流向加工（输入）\n⑤ 从加工流向外部实体（输出） 加工 加工要有输入输出：\n① 有输入没有输出 —— 黑洞 ② 有输出没有输入 —— 奇迹 ③ 输入不足以产生输出 —— 灰洞 外部实体 外部实体可以是人、物品、其他系统 3.2 数据字典 数据字典有以下 4 类条目：数据流、数据项、数据存储和基本加工。\n客户基本信息=客户编号+客户姓名+身份证号码+手机+地址\n查询要求=[航班号 | 起降地]\n四 结构化设计 4.1 概要设计 确定每个模块的功能和调用关系，形成软件的模块结构图，即SC 系统结构图。\n文档：概要设计说明书、数据库设计说明书、用户手册、修订测试计划。\n4.2 详细设计 为每个具体任务选择适当的技术手段和处理方法的过程。强调模块内的设计。\n真题示例 - 4.1\n判定表和判定树常用于描述数据流图的（）。\nA. 数据存储 B. 外部实体 C. 加工逻辑 D. 循环操作\n五 内聚与耦合 5.1 内聚 模块的内聚类型通常可以分七种，根据内聚度从低到高排序。\n内聚类型 描述 偶然（巧合）内聚） 指一个模块内的各处理元素之间没有任何联系。例如：三条不相关的语句（move ) to R，read file F，move S to T），模块 B 和 C 需要都使用这三条语句。于是将这三条语句提取出来形成模块 A。模块 A 的语句就是偶然内聚。 逻辑内聚 指模块内执行若干个逻辑上相似的功能，通过参数确定该模块完成哪一个功能。例如：将功能上相似的模块 B、C、D，放在一个模块中，模块 A 需要用不同的参数去调用具体的模块去完成相应的功能。相当于进行次判断。 时间内聚 把需要同时执行的动作组合在一起形成的模块称为时间内聚模块。例如：初始化 过程内聚 指一个模块完成多个任务，这些任务必须按指定的过程执行。例如：先写姓名 -\u0026gt; 电话 -\u0026gt; 家庭住址，先后顺序符合客户需求 通信内聚 指模块内的所有元素都在同一数据结构上操作，或者各处理使用相同的输入数据或者产生相同的输出数据。例如：一个模块根据员工生日计算员工年龄和退休时间 顺序内聚 指一个模块中的各个处理元素都密切相关于同一功能且必须顺序执行，前一功能元素的输出就是下一功能元素的输入。例如：先计算员工的年龄再计算退休时间 功能内聚 这是最强的内聚，指模块内的所有元素共同完成一个功能，缺一不可 5.2 耦合 模块的耦合类型通常也分为七种，根据耦合度从低到高排序。\n耦合类型 描述 无直接耦合 指两个模块之间没有直接的关系，它们从属于不同模块的控制与调用，它们之间不传递任何信息。因此，模块间耦合性最弱 数据耦合 指两个模块之间有调用关系，传递的是最简单的数据值，相当于高级语言中的值传递 标记耦合 指两个模块之间传递的是数据结构。相当于传址过程。 控制耦合 指一个模块调用另一个模块时，传递的是控制变量，被调用模块通过该控制变量的值有选择地执行模块内的某一功能。因此，被调用模块应具有多个功能，哪个功能起作用受调用模块控制。 外部耦合 模块间通过软件之外的环境联结（如 I/O 将模块耦合到特定的设备、格式、通信协议上）时称为外部耦合 公共耦合 指通过一个公共数据环境相互作用的那些模块间的耦合。公共数据环境可以是全局数据结构、共享的通信区、内存的公共覆盖区等。 内容耦合 当一个模块直接使用另一个模块的内部数据，或通过非正常入口转入另一个模块内部，这种模块之间的耦合称为内容耦合。例如：将模块 A 的输入放到模块 B 中，将模块 B 的输入放到模块 A 中。 真题示例 - 5.1\n一组无逻辑关系的语句在程序中多处出现，为了节省存储空间，把这些语句放在一个模块中，该模块的内聚是（）。\nA. 逻辑内聚 B. 偶然内聚 C. 过程内聚 D. 通信内聚\n真题示例 - 5.2\n某医院预约系统的部分需求为：患者可以查看医院发布的专家特长介绍及其就诊时间；系统记录患者信息，患者预约特定时间就诊。用 DFD 对其进行功能建模时，患者是（）；用 ERD 对其进行数据建模时，患者是（）。\nA. 外部实体 B. 加工 C. 数据流 D. 数据存储\nA. 实体 B. 属性 C. 联系 D. 弱实体\n案例分析 问题 1：【外部实体】使用说明中的词语，给出图中的实体名称\n问题 2：【数据存储】使用说明中的词语，给出图中的数据存储的名称\n问题 3：【数据流】根据说明和图中词语，补充图中缺失的数据流及其起点和终点\n问题 4：【其他】增加/拆分某个加工，或考察基础和知识点。\n真题示例\n试题一（共 15 分）\n阅读下列说明和图，回答问题 1 至问题 4，将解答填入答题纸的对应栏内。\n【说明】某现代农业种植基地为进一步提升农作物种植过程的智能化，欲开发智慧农业平台，集管理和销售于一体，该平台的主要功能有：\n信息维护。农业专家对农作物、环境等监测数据的监控处理规则进行维护。 数据采集。获取传感器上传的农作物长势、土壤详情、气候等连续监测数据，解析后将监测信息进行数据处理、可视化和存储等操作。 数据处理。对实时监测信息根据监控处理规则进行监测分析，将分析结果进行可视化并进行存储、远程控制；对历史监测信息进行综合统计和预测，将预测信息进行可视化和存储。 远程过程。根据监控处理规则对分析结果进行判定，依据判定结果自动对控制器进行远程控制。平台也可以根据农业人员提供的控制信息对控制器进行远程控制。 可视化。实时向农业人员展示监测信息；实时给农业专家展示统计分析结果和预测信息或根据农业专家请求展示。 现在采用结构化方法对智慧农业平台进行分析与设计，获得如图 1-1 所示的上下文数据流图和图 1-2 所示的 0 层数据流图。\n【问题 1】（4 分）\n使用说明中的词语，给出图 1-1 中的实体 E1 ~ E4 的名称。\n【问题 2】（4 分）\n使用说明中的词语，给出图 1-2 中的数据存储 D1 ~ D4 的名称。\n【问题 3】（4 分）\n根据说明和图中术语，补充图 1-2 中缺失的数据流及其起点和终点。\n【问题 4】（3 分）\n根据说明，“数据处理” 可以分解为哪些子加工？进一步进行分解时，需要注意哪三种常见的错误？\n真题答案 题号 答案 4.1 C 5.1 B 5.2 A、A 案例分析\n【问题 1】\nE1：传感器 E2：农业专家 E3：农业人员 E4：控制器\n【问题 2】\nD1：监控处理规则表 D2：监测信息表 D3：分析结果表 D4：预测信息表\n【问题 3】\n起点 D1，终点 P4，监测规则\n起点 E2，终点 P5，请求\n起点 D3，终点 P5，分析结果\n起点 D4，终点 P5，预测信息\n【问题 4】\n数据处理加工分为数据分析，可视化与存储\n黑洞、奇迹、灰洞\n","permalink":"https://tofuwine.github.io/posts/ce06d36b/","summary":"【软件设计师】第六章 结构化开发方法","title":"第六章 结构化开发方法"},{"content":"一 章节知识架构图 二 软件生命周期 1. 可研计划 （非考点） 确定软件的开发目标及其可行性\n可研报告、项目开发计划\n2. 需求分析 确定系统功能、性能、数据和界面要求\n软件需求说明书\n3. 系统设计 将需求转换为模块组成的体系架构（概要设计）\n模块的具体功能（详细设计）\n概要设计说明书、详细设计文档\n4. 编码 模块的功能转换成代码\n源程序清单\n5. 测试 对软件组成部分测试。\n软件测试计划、测试用例、软件测试报告\n6. 维护 投入使用后进行更正，适应、完善和预防的工作\n三 开发模型 类型 特征 方法 瀑布模型 开发阶段性、需求明确、文档齐全、风险控制弱 结构化方法 原型模型 分为原先开发与目标软件开发。需求不明确 原型法 增量模型 瀑布模型的变体。第一个增量是核心 螺旋模型 瀑布与原型（演化）模型结合体。适用于大型、复杂、风险项目 喷泉模型 复用好、开发过程无间隙、节约时间 面向对象开发方法 快速应用开发 RAD 基于构件的开发方法。用户参与、开发或复用构件、模块化要求高，不适用新技术 RUP/UP 用例驱动、架构为中心、迭代、增量 真题示例 - 3.1\n以下关于系统原型的叙述中，不正确的是（）。\nA. 可以帮助导出系统需求，并验证需求的有效性\nB. 可以用来探索特殊的软件解决方案\nC. 可以用来指导代码优化\nD. 可以用来支持用户界面设计\n真题示例 - 3.2\n某企业拟开发一个企业信息管理系统，系统功能与多个部门的业务相关。现希望该系统能够尽快投入使用，系统功能可以在使用过程中不断完善。最适宜采用的软件过程模型为（）。\nA. 瀑布模型 B. 原型模型 C. 演化(迭代)模型 D. 螺旋模型\n真题示例 - 3.3\n某开发小组欲为一个公司开发一个产品控制软件，监控产品的生产和销售过程，从购买各种材料开始，到产品的加工和销售进行全程跟踪。购买材料的流程、产品的加工过程以及销售过程可能会发生变化。该软件的开发最不适宜采用（）模型，主要是因为这种模型（）。\nA. 瀑布 B. 原型 C. 增量 D. 喷泉\nA. 不能解决风险 B. 不能快速提交软件\nC. 难以适应变化的需求 D. 不能理解用户的需求\n四 敏捷开发 以人为本，与用户紧密协作，面对面沟通，尽早发布增量，小而自主的开发团队。适用于规模小的项目。\n敏捷是开发方法。\n01 XP 极限编程\n高效、低风险、测试先行（先写测试代码，再编写程序） 实践类型 内容 计划游戏 快速制定计划、随着细节的不断变化而完善 小型发布 系统的设计要能够尽可能早地交付 隐喻 找到合适的比喻传达信息 简单设计 只处理当前需求，使设计保持简单 测试先行 先写测试代码，然后再编写程序 重构 重新审视需求和设计，重新明确地描述它们以符合新的和现有的需求 结对编程 两个程序员在一个计算机上共同工作。一个人输入代码，而另一个人审查 集体代码所有制 开发人员轮换完成系统不同领域中不同模块的不同任务。每个人都对程序负责 持续集成 可以按日甚至按小时为客户提供可运行版本 每周工作 40 个小时 保证工作质量 现场客户 系统用户代表全程配合 XP 团队 编码标准 规范代码的编写 02 Cockburn 水晶方法\n不同项目，不同策略 03 SCRUM 并列争求法\n迭代。30 天为一个迭代周期，按照需求优先级实现。 04 ASD 自适应方法\n预测 —— 协作 —— 学习 05 开放式源码\n虚拟团队，开发成员分布各地 06 敏捷统一过程 AUP\n大型上连续，小型上迭代 真题示例 - 4.1\n以下关于敏捷统一过程（AUP）的叙述中，不正确的是（）。\nA. 在大型任务上连续\nB. 在小型任务上迭代\nC. 在每一个不同的系统都需要一套不同的策略、约定和方法论\nD. 采用经典的 UP 阶段性活动，即初始、精化、构建和转换\n真题答案 题号 答案 3.1 C 3.2 C 3.3 A、C 4.1 C ","permalink":"https://tofuwine.github.io/posts/05a45eeb/","summary":"【软件设计师】第五章 软件工程","title":"第五章 软件工程"},{"content":"一 章节知识架构图 二 数据库系统的结构 2.1 概念模式 概念模式是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。一个数据库只有一个概念模式。\n2.2 外模式 外模式（子模式、用户模式）用以描述用户看到或使用的那部分数据的逻辑结构，用户根据外模式用数据操作语句或应用程序去操作数据库中的数据。\n2.3 内模式 内模式定义的是存储记录的类型、存储域的表示以及存储记录的物理顺序，指引元、索引和存储路径等数据的存储组织。一个数据库只有一个内模式。\n2.4 逻辑独立性与物理独立性 逻辑独立性：外模式和概念模式之间的映射。应用程序与数据库中的逻辑结构独立，当数据的逻辑结构改变时，应用程序不变。\n物理独立性：概念模式和内模式之间的映射。应用程序与磁盘中的数据互相独立。当数据的物理存储改变时，应用程序不变。\n真题示例 - 2.1：\n在数据库系统中，视图是一个（）。\nA. 真实存在的表，并保存了待查询的数据\nB. 真实存在的表，只有部分数据来源于基本表\nC. 虚拟表，查询时只能从一个基本表中导出\nD. 虚拟表，查询时可以从一个或者多个基本表或视图中导出\n真题示例 - 2.2：\n在采用三级模式结构的数据库系统中，如果对数据库中的表 Emp 创建聚簇索引，那么改变的是数据库的（）。\nA. 模式 B. 内模式 C. 外模式 D. 用户模式\n三 数据模型 数据模型主要有两大类，分别是概念数据模型（实体 - 联系模型）和基本数据模型（结构数据模型）。\n3.1 概念数据模型 概念数据模型是按照用户的观点来对数据和信息建模，主要用于数据库设计。概念模型主要用实体 - 联系方法（Entity-Relationship Approach）表示，所以也成为 E-R 模型。\n3.2 基本数据模型 基本数据模型是按照计算机系统的观点来对数据和信息建模，主要用于 DBMS 的实现。基本数据模型是数据库系统的核心和基础。常用的基本数据模型有层次模型、网状模型、关系模型和面向对象模型。\n3.3 数据的约束条件 1）实体完整性\n实体完整性是指实体的主属性不能取空值。\n2）参照完整性\n在关系数据库中主要是值的外键参照的完整性。若 A 关系中的某个或者某些属性参照 B 或其他几个关系中的属性，那么在关系 A 中该属性要么为空，要么必须出现 B 或者其他的关系的对应属性中。\n3）用户定义完整性\n用户定义完整性反映的某一个具体应用对应的数据必须满足一定的约束条件。\n四 关系型数据库 关系\n可以理解为一张二维表，每个关系都具有一个关系名，就是通常说的表名。\n元组\n可以理解为二维表中的一行，在数据库中经常被称为记录。\n属性\n可以理解为二维表中的一列，在数据库中经常被称为字段。\n域\n属性的取值范围，也就是数据库中某一列的取值限制。\n关键字\n一组可以唯一标识元组的属性，数据库中常称为主键，由一个或多个列组成。\n关系模式\n指关系的描述。其格式为：关系名（属性 1，属性 2，\u0026hellip;，属性 N），在数据库中称为表结构。\n五 关系代数 5.1 集合运算符 运算符 含义 名词解释 \\$\\cup \\$ 并 关系 R 与 S 的并是由属于 R 或属于 S 的元组构成的集合 \\$- \\$ 差 关系 R 与 S 的差是由属于 R 但不属于 S 的元组构成的集合 \\$\\cap \\$ 交 关系 R 与 S 的交是由属于 R 同时又属于 S 的元组构成的集合 \\$\\textcolor{red}{\\times} \\$ 笛卡尔积 两个元组分别为 n 目和 m 目的关系 R 和 S 的笛卡尔积是一个 \\$(n+m) \\$列的元组的集合。元组的前 n 列是关系 R 的一个元组，后 m 列是关系 S 的一个元组。 示例：\nR\nA B C a1 b1 c1 a1 b2 c2 a2 b2 c1 S\nA B C a1 b2 c2 a1 b3 c2 a2 b2 c1 \\$\\bf R \\times S\\$\nR.A R.B R.C S.A S.B S.C a1 b1 c1 a1 b2 c2 a1 b1 c1 a1 b3 c2 a1 b1 c1 a2 b2 c1 a1 b2 c2 a1 b2 c2 a1 b2 c2 a1 b3 c2 a1 b2 c2 a2 b2 c1 a2 b2 c1 a1 b2 c2 a2 b2 c1 a1 b3 c2 a2 b2 c1 a2 b2 c1 5.2 专门的关系运算符 运算符 含义 名词解释 \\$\\sigma \\$ 选择 取得关系 R 中符合条件的行 \\$\\pi \\$ 投影 取得关系 R 中符合条件的列 \\$\\Join \\$ 连接 等值连接：关系 R、S 取两者笛卡尔积中属性值相等的元组。\n自然连接：一种特殊的等值连接，它要求比较的属性列必须是相同的属性组，并且把结果中重复属性去掉。注意与笛卡尔积的区别。 示例 1： 查询年龄小于 20 岁的学生 \\$\\sigma_{Sage} \u003c 20(student) \\$\nSno Sname Ssex Sage Sdept 202015001 李阳 女 18 计算机 202015113 王明 男 18 信息安全 202015254 刘立 男 19 计算机 示例 2： 查询学生的姓名和所在系 \\$\\pi_{Sname,Sdept}(Student)\\$\nSname Sdept 李阳 计算机 王明 信息安全 刘立 计算机 示例 3：\nR\nA B C a1 b1 5 a1 b2 6 a2 b3 8 a2 b4 12 S\nB E b1 3 b2 7 b3 10 b3 2 b5 2 \\$\\begin{matrix} \\bf{R \\Join S}\\\\\\scriptsize{R.B=S.B} \\end{matrix}\\$ (等值连接)\nA R.B C S.B E a1 b1 5 b1 3 a1 b2 6 b2 7 a2 b3 8 b3 10 a2 b3 8 b3 2 \\$\\bf R \\Join S\\$ (自然连接)\nA B C E a1 b1 5 3 a1 b2 6 7 a2 b3 8 10 a2 b3 8 2 真题示例 - 5.1: 给定关系 R(A,B,C,D,E) 与 S(A,B,CF,G)，那么与关系式 \\$\\pi_{1,2,4,6,7}(\\sigma_{1\u003c6}(R \\Join S))\\$ 等价的 SQL 语句如下：select () from R,S where ();\nA. R.A, R.B, R.E, S.C, G\nB. R.A, R.B, D, F, G\nC. R.A, R.B, R.D, S.C, F\nD. R.A, R.B, R.D, S.C, G\nA. R.A=S.A OR R.B=S.B OR R.C=S.C OR R.A\u0026lt;S.F\nB. R.A=S.A OR R.B=S.B OR R.C=S.C OR R.A\u0026lt;S.B\nC. R.A=S.A AND R.B=S.B AND R.C=S.C AND R.A\u0026lt;S.F\nD. R.A=S.A AND R.B=S.B AND R.C=S.C AND R.A\u0026lt;S.B\n六 函数依赖 \\$X \\rightarrow Y \\$, \\$Y \\not\\subseteq X \\$, 则称 \\$X \\rightarrow Y \\$ 是非平凡的函数依赖。\n\\$X \\rightarrow Y \\$, 但 \\$Y \\subseteq X \\$, 则称 \\$X \\rightarrow Y \\$ 是平凡的函数依赖。\n例如：关系式 Student (Sno, Sdept, Mname, Cno, Grade)\n名称 定义 完全函数依赖 \\$(Sno, Cno) \\rightarrow Grade \\$ 是完全函数依赖 部分函数依赖 \\$(Sno, Cno) \\rightarrow Sdept \\$ 是不分函数依赖 传递依赖 \\$Sno \\rightarrow Sdept \\$, \\$Sdept \\rightarrow Mname \\$，则称 Mname 传递依赖于 Sno 6.1 Armstrong 公理 Armstrong 公理：从已知的一些函数依赖，可以推导出另外一些函数依赖，这就需要一系列推理规则，这些规则常被称作 ”Armstrong“ 公理。\n设关系式 R(U, F)，U 是关系模式 R 的属性集，F 是 U 上一组函数依赖，则有以下三条推理规则：\nA1 自反律：若 \\$Y \\subseteq X \\subseteq U \\$，则 \\$X \\rightarrow Y \\$ 为 F 所蕴含。 A2 增广律：若 \\$X \\rightarrow Y \\$ 为 F 所蕴含，且 \\$Z \\subseteq U \\$，则 \\$XZ \\rightarrow YZ \\$ 为 F 所蕴含。 A3 传递律：若 \\$X \\rightarrow Y \\$, \\$Y \\rightarrow Z \\$ 为 F 所蕴含，则 \\$X \\rightarrow Z \\$ 为 F 所蕴含。 根据上面三条推理规则，又可推出下面三条推理规则：\n合并规则：若 \\$X \\rightarrow Y \\$, \\$X \\rightarrow Z \\$，则 \\$X \\rightarrow YZ \\$ 为 F 所蕴含。 伪传递规则：若 \\$X \\rightarrow Y \\$, \\$WY \\rightarrow Z \\$，则 \\$XW \\rightarrow Z \\$ 为 F 所蕴含。 分解规则：若 \\$X \\rightarrow Y \\$, \\$Z \\subseteq Y \\$，则 \\$X \\rightarrow Z \\$ 为 F 所蕴含。 例 1：\n关系式 \\$S1 (\\underline{Sno}, Sdept, Sage) \\$\n超键：Sno、(Sno，Sdept)、(Sno，Sage)、(Sno，Sdept，Sage) 是超键。\n主键： \\$Sno \\to Sdept \\$， \\$Sno \\to Sage \\$，Sno 是主键（码）\n若有关系式 \\$SC (Sno, Cno, Grade) \\$ 中，（Sno, Cno) 是主键\n例 2：\n关系式 \\$S2 (\\underline{Sno, Sname}, Sdept, Sage) \\$\n候选键：Sno、Sname 是候选键，选择 Sno 为主键。不含多余属性的超键称为候选键。\n超键：在关系中能唯一标识元组的属性集称为关系模式的超键。\n候选键：不含有多余属性的超键称为候选键。\n主键：用户挑选出来做元组标识的一个候选键称为主键。\n外键：如果关系模式 R 中的某些属性集不是 R 的主键，而是关系模式 S 的主键，则这个属性集对模式 R 而言是外键。\n例如：关系式 \\$SC (\\underline{Sno, Cno}, Grade) \\$ 中，Sno 不是主键，但它是 \\$S (\\underline{Sno}，Sdept，Sage) \\$ 的主键，则 Sno 是关系模式 SC 的外键。\n主属性与非主属性：包含在任何一个主键中的属性，称为主属性，否则为非主属性。\n例如： \\$S (\\underline{Sno}，Sdept，Sage) \\$，Sno 是主键，也是主属性，Sdept、Sage 是非主属性。\n全码（All-key）\n例如：关系模式 \\$R(P, W, A) \\$ 中，P 是演奏者，W 是作品，A 是听众，该关系模式只有一个包含了全部属性的主键，是全码。\n七 规范化 7.1 第一范式（1NF） 若关系模式 R 的每一个分量是不可再分的数据项，则关系模式 R 属于第一范式。如下图不属于第一范式。\n例如：关系式 \\$S (name, address (street, city))\\$ \\$\\Longrightarrow\\$ 关系式 \\$S (name, address)\\$ 或者 关系式 \\$S (name, street, city)\\$\n7.2 第二范式（2NF） 若关系模式 \\$\\small R \\in 1NF\\$，且每一个非主属性完全依赖主键时，则关系式 R 是 2NF。\n例如：\\$\\small R (学号，姓名，班级，课程，成绩)\\$\n函数依赖：\\$\\small \\{学号 \\to 姓名，学号 \\to 班级，(学号，课程) \\to 成绩\\}\\$ 主键：（学号，课程号） 这里姓名，班级部分依赖于主键，不属于 2NF，需将其分解为： R1（学号，姓名，班级） R2（学号，课程，成绩）\n7.3 第三范式（3NF） 即当 2NF 消除了非主属性对码的传递函数依赖，则称为 3NF。\n7.4 不满足范式要求 会出现以下问题：\n① 冗余较大 ② 修改异常 ③ 插入异常 ④ 删除异常\n真题示例 - 7.1：\n给定关系模式 \\$\\small R(U, F) \\$，其中：属性集 \\$\\small U=\\{A1, A2, A3, A4, A5, A6\\} \\$，函数依赖集 \\$\\small F=\\{A1 \\to A2, A1 \\to A3, A3 \\to A4, A1A5 \\to A6\\} \\$。关系模式 R 的候选码为（）。\nA. A1A3 B. A1A4 C. A1A5 D. A1A6\n快速解题思路：观察选项哪个只在函数依赖集左边出现过。\n真题示例 - 7.2：\n给定关系 \\$\\small R(U, Fr) \\$ 其中属性集 \\$\\small U=\\{A,B,C,D\\} \\$，函数依赖集 \\$\\small Fr=\\{A \\to BC, B \\to D \\} \\$，给定关系 \\$\\small S(U, Fs) \\$，其中属性集 \\$\\small U=\\{ACE\\} \\$，函数依赖集 \\$\\small Fs=\\{A \\to C, C \\to E \\} \\$ R 和 S 的主键分别为（）。\nA. A 和 A B. AB 和 A C. A 和 AC D. AB 和 AC\n真题示例 - 7.3：\n给定关系 \\$\\small R(U, Fr) \\$ 其中属性集 \\$\\small U=\\{A, B, C, D\\} \\$，函数依赖集 \\$\\small Fr=\\{A \\to BC, B \\to D\\} \\$，关系 \\$\\small S (U, Fs) \\$，其中属性集 \\$\\small U=\\{ACE\\} \\$，函数依赖集 \\$\\small Fs=\\{A \\to C,C \\to E\\} \\$。关于 Fr 和 Fs 的叙述，正确的是（）。\nA. Fr 蕴含 \\$\\small A \\to B \\$， \\$\\small A \\to C \\$，但 Fr 不存在传递依赖\nB. Fs 蕴含 \\$\\small A \\to E \\$，Fs 存在传递依赖，但 Fr 不存在传递依赖\nC. Fr，Fs 分别蕴含 \\$\\small A \\to D \\$， \\$\\small A \\to E \\$，故 Fr，Fs 都存在传递依赖\nD. Fr 蕴含 \\$\\small A \\to D \\$，Fr 存在传递依赖，但是 Fs 不存在传递依赖\n真题示例 - 7.4：\n给定关系模式 \\$\\small R(U, F) \\$，其中：属性集 \\$\\small U=\\{A1, A2, A3, A4, A5, A6\\} \\$，函数依赖集 \\$\\small F=\\{A1 \\to A2, A1 \\to A3, A3 \\to A4, A1A5 \\to A6\\} \\$。由于 R 存在非主属性对码的部分函数依赖，所以 R 属于（）。\nA. 1NF B. 2NF C. 3NF D. BCNF\n八 数据库设计 设计阶段 成果 需求分析 需求规格说明书、数据字典 概念设计 概念模型，E-R 图 逻辑设计 逻辑模型，关系模式 物理设计 （非考点） 物理模型 8.1 概念设计 冲突类型 属性冲突\n属性域冲突：不同学校编码方式不同\n属性值冲突：重量采用千克、磅\n结构冲突\n同一对象在不同应用中的抽象不同：职工在某一应用中是实体，在另一应用中是属性。\n同一实体在不同 E-R 图中属性个数和排列次序不同\n命名冲突\n同名异义\n异名同义\n8.2 逻辑设计 逻辑设计也称为逻辑结构设计，其任务是将概念模型转化为其特定的 DBMS 上的逻辑模型（层次模型、网状模型、关系模型）。\nE-R 图向关系模式转换规则：\nE-R 图的实体转换为关系 E-R 的属性转换为关系的属性 E-R 图的关键字转换为关系的关键字 复合属性的转换：\n将每个分量属性作为复合属性所在实体的属性或将复合属性本身作为所在实体的属性。\n多值属性的转换：\n将多值属性与所在实体的主键一起组成一个新的关系 将多值属性提升为一个实体，通常为弱实体 派生属性：\n因为派生属性可由其他属性计算得到，因此，在转化成关系模式时，通常不转换派生属性。\n例如：“学生”实体中有“生日”和“年龄”等属性，从“生日”可以计算出“年龄”属性的值，“年龄”属性就是派生属性。\nBLOB 型属性：\n典型的 BLOB 是一张图片或一个声音文件，由于它们的容量比较大，必须使用特殊的方式来处理。处理 BLOB 的主要思想就是让文件处理器（例如，数据库管理器）不去理会文件是什么，而是关心如何去处理它。因此，从优化的角度考虑，应采用的设计方案是将 BLOB 属性与关系的主键独立为一个关系模式。\n联系的属性，1:1 的联系：\n一个 1:1 联系可以转换为一个独立的关系模式。\n例如：管理（职工号，班级号，\u0026hellip;）\n或者也可以与任意一端对应的关系模式合并。\n例如：班级（班级号，学生人数，职工号, \u0026hellip;）或教师（职工号，姓名，性别，职称，班级号，\u0026hellip;）\n联系的属性，1:n 的联系：\n一个 1:n 的联系可以转换为一个独立的关系模式。\n例如：组成（学号，班级号，\u0026hellip;） 与 n 端对应的关系模式合并。\n例如：学生（学号，姓名，出生日期，所在系，班级号\u0026hellip;） 联系的属性，n:m 的联系：\n一个 n:m 的联系可以转换为一个独立的关系模式。\n例如：选修（学号，课程号，成绩\u0026hellip;），其中学号和课程号为关系模式的组合（联合）主键\n联系的属性，多元的联系：\n一个多元联系可以转换为一个独立的关系模式。\n例如：讲授（职工号，课程号，书号\u0026hellip;），其中课程号、职工号、书号为关系模式的组合（联合）主键。\n真题示例 - 8.1：\n描述企业应用中的实体及其联系，属于数据库设计的（）阶段。\nA. 需求分析 B. 概念设计 C. 逻辑设计 D. 物理设计\n九 事务管理 数据库系统运行的基本工作单位是事务，事务相当于操作系统中的进程，是用户定义的一个数据库操作序列，这些操作序列要么全做要么全不做，是一个不可分割的工作单位。\n事务特性（ACID）：\n原子性（Atomicity）\n操作。操作序列要么全做要么全不做 一致性（Consistency）\n数据。数据从一个一致性状态变到另一个一致性状态 隔离性（Isolation）\n执行。不能被其他事务干扰。 持续性（Durability）\n变化。一旦提交，改变就是永久的。 十 并发控制 处理并发控制的主要方法是采用封锁技术。它有两种类型：排他型封锁（X 封锁）和共享型封锁（S 封锁）：\n10.1 排他型封锁（简称 X 封锁）（写锁） 如果事务 T 对数据 A（可以是数据项、记录、数据集，乃至整个数据库）实现了 X 封锁，那么只允许事务 T 读取和修改数据 A，其他事务要等事务 T 解除 X 封锁以后，才能对数据 A 实现任何类型的封锁。\n10.2 共享型封锁（简称 S 封锁）（读锁） 如果事务 T 对数据 A 实现了 S 封锁，那么允许事务 T 读取数据 A，但不能修改数据 A，在所有 S 封锁解除之前不允许任何事物对数据 A 实现 X 封锁。\n真题示例 - 10.1：\n若事务 T1 对数据 D1 加了共享锁，事务 T2、T3 分别对数据 D2、D3 加了排它锁，则事物 T1 对数据（）；事务 T2 对数据（）。\nA. D2、D3 加排它锁都成功\nB. D2、D3 加共享锁都成功\nC. D2 加共享锁成功，D3 加排它锁失败\nD. D2、D3 加排它锁和共享锁都失败\nA. D1、D3 加共享锁都失败\nB. D1、D3 加共享锁都成功\nC. D1 加共享锁成功，D3 加排它锁失败\nD. D1 加排它锁成功，D3 加共享锁失败\n案例分析 案例分析一般出题形式如下：\n实体联系\n根据题干补充 ER 图缺失的实体及其联系 关系模式\n根据题干补充 ER 图缺失的关系 主键外键\n找出题干关系模式的主键、外键 其他\n数据库基础知识或修改/增加关系模式 真题示例 试题二\n回答问题 1 至问题 4，将解答填入答题纸的对应栏内\n【说明】\n某汽车维修公司为了便于管理车辆的维修情况，拟开发一套汽车维修管理系统，请根据下述需求描述完成该系统的数据库设计。\n【需求描述】\n（1）客户信息包括：客户号、客户名、客户性质、折扣率、联系人、联系电话。客户性质有个人或单位。客户号唯一标识客户关系中的每一个元组。\n（2）车辆信息包括：车牌号、车型、颜色和车辆类别。一个客户至少有一辆车，一辆车只属于一个客户。\n（3）员工信息包括：员工号、员工名、岗位、电话、家庭住址。其中员工号唯一标识员工关系中的每一个元组。岗位有业务员、维修工、主管。业务员根据车辆的故障情况填写维修单。\n（4）部门信息包括：部门号、名称、主管和电话，其中部门号唯一确定部门关系的每一个元组。每个部门只有一名主管，但每个部门有多个员工，每名员工只属于一个部门。\n（5）维修单信息包括：维修单号、车牌号、维修内容、工时。维修单号唯一标识维修单关系中的每一个元组。一个维修供可接多张维修单，但一张维修单只对应一个维修工。\n【概念模型设计】\n根据需求阶段收集的信息，设计的实体联系图（不完整）如图 2-1 所示。\n【逻辑结构设计】\n根据概念模型设计阶段完成的实体联系图，得出如下关系模式（不完整）：\n客户（客户号，客户名，(a)，折扣率，联系人，联系电话）\n车辆（车牌号，(b)，车型，颜色，车辆类别）\n员工（员工号，员工名，岗位，(c)，电话，家庭住址）\n部门（部门号，名称，主管，电话）\n维修单（维修单号，(d)，维修内容，工时）\n【问题 1】（6 分）\n根据问题描述，补充 3 个联系，完善图 2-1 的实体联系图。联系名可用联系 1、联系 2 和联系 3 代替，联系的类型为 1:1、1:n 和 m:n (或 1:1、1:* 和 *:* )\n【问题 2】（4 分）\n根据题意，将关系模式中的空 (a) ~ (d) 的属性补充完整，并填入答题纸对应的位置上。\n【问题 3】（2 分）\n分别给出车辆关系和维修单关系的主键与外键。\n【问题 4】（3 分）\n如果一张维修单涉及多项维修内容，需要多个维修工来处理，那么哪个联系类型会发生何种变化？你认为应该如何解决这一问题？\n真题答案 题号 答案 2.1 D 2.2 B 5.1 B、C 7.1 C 7.2 A 7.3 C 7.4 A 8.1 B 10.1 D、C 案例分析\n【问题 1】\n客户和车辆的联系类型为 1:n\n部门和员工的联系类型为 1:n\n维修工和维修单的联系类型为 1:n\n【问题 2】\n(a) 客户性质 (b)客户号 (c) 部门号 (d) 车牌号,员工号\n【问题 3】\n车辆关系：主键：车牌号；外键：客户号\n维修单关系：主键：维修单号；外键：车牌号，员工号\n【问题 4】\n维修单与维修工的联系将从 1:n 变成 m:n。\n将维修单号，员工号，维修内容独立出来形成一张表。删除维修单中的员工号，维修内容。\n","permalink":"https://tofuwine.github.io/posts/6734b29c/","summary":"【软件设计师】第四章 数据库基础","title":"第四章 数据库基础"},{"content":"一 章节知识架构图 二 进程 进程通常由程序、数据集合、进程控制块 PCB 组成。PCB 是一种数据结构，是进程存在的唯一标识。PCB 的组织方式有线性、链接和索引方式。\n三 PV 操作 P 操作：\n① 将信号量 S 的值减一，即 \\$S=S-1\\$\n② 如果 \\$S \\geq 0\\$，则该进程继续执行；否则该进程置为等待状态。\nV 操作：\n① 将信号量 S 的值加一，即 \\$S=S+1\\$\n② 如果 \\$S \u003e 0\\$ 该进程继续执行；否则说明等待队列中有等待进程，需要唤醒等待进程。\n真题示例 - 3.1：\n假设系统中有 n 个进程共享 3 台打印机，任一进程最多只能使用 1 台打印机。若用 PV 操作控制 n 个进程使用打印机，则相应信号量 S 的取值范围为（）；若信号量 S 的值为 -3，则系统中有（）个进程等待使用打印机。\nA. \\$0,-1, \\cdots, -(n-1)\\$\nB. \\$3,2,1,0,-1, \\cdots, -(n-3)\\$\nC. \\$1,0,-1, \\cdots, -(n-1)\\$\nD. \\$2,1,0,-1, \\cdots, -(n-2)\\$\nA. 0 B. 1 C. 2 D. 3\n真题示例 - 3.2：\n进程 P1、P2、P3 和 P4 的前驱图如下所示：\n若用 PV 操作控制进程 P1~ P4 并发执行的过程，则需要设置 5 个信号量 S1、S2、S3、S4 和 S5，且信号量 S1 ~ S5 的初值都等于 0。下图中 a、b 和 c 处应分别填写（）；d、e 和 f 处应分别填写（）。\nA. V(S1)V(S2)、P(S1)V(S3)和V(S4)\nB. P(S1)V(S2)、P(S1)V(S2)和V(S1)\nC. V(S1)V(S2)、P(S1)P(S3)和V(S4)\nD. P(S1)P(S2)、V(S1)P(S3)和V(S2)\nA. P(S2)、V(S3)V(S5)和P(S4)P(S5)\nB. V(S2)、P(S3)V(S5)和V(S4)P(S5)\nC. P(S2)、V(S3)P(S5)和P(S4)V(S5)\nD. V(S2)、V(S3)P(S5)和P(S4)V(S5)\n四 存储管理 当内存不太不够用时，用辅存来支援内存。 暂时不运行的模块换出到辅存上，必要时再换入内存。\n4.1 地址重定位 地址重定位是指将程序中的地址虚拟地址（逻辑地址）变换成内存的真实地址（物理地址）的过程。\n逻辑地址：\n相对地址。CPU 所生成的地址。逻辑地址是内部和编程使用的、并不唯一。\n物理地址：\n绝对地址。加载到内存地址寄存器中的地址，内存单元的真正地址。\n4.2 分页存储管理 分页存储管理：将一个进程的地址空间划分成若干个大小相等的区域，称为页。相应地，将主存空间划分成与页相同大小的若干个物理块，称为块或页框。\n真题示例 - 4.1：\n进程 P 有 8 个页面，页号分别为 0~7，页面大小为 4K，假设系统给进程 P 分配了 4 个存储块，进程 P 的页面变换表如下所示。表中状态位等于 1 和 0 分别表示页面在内存和不在内存。若进程 P 要访问的逻辑地址为十六进制 5148H，则该地址经过变换后，其物理地址应为十六进制（）；如果进程 P 要访问的页面 6 不在内存，那么应该淘汰页号为（）的页面。\nA. 3148H B. 5148H C.7148H D.9148H\nA. 1 B. 2 C. 5 D. 9\n4.3 分段管理 分段式存储管理系统中，为每个段分配一个连续的分区，而进程中的各个段可以离散地分配到主存的不同分区中。在系统中为每个进程简历一张段映射表，简称为“段表”。每个段在表中占有一个表项，在其中记录了该段在主存中的起始地址（又称为“基址”）和段的长度。进程在执行时，通过查段表来找到每个段所对应的主存区。\n4.4 段页式管理 段页式系统的基本原理是先将整个主存划分成大小相等的存储块（页框），将用户程序按照程序的逻辑关系分为若干个段，再将每个段划分成若干页，以页框为单位离散分配。在段页式系统中，其地址结构由段号、段内页号和页内地址三部分组成。\n五 设备管理 5.1 程序控制 无条件传送：\nI/O 端口总是准备好，CPU 在需要时，随时直接利用访问相应的 I/O 端口。\n程序查询：\nCPU 必须不停地测试 I/O 设备的状态端口。CPU 与 I/O 设备是串行工作的。\n5.2 中断 某个进程要启动某个设备时，CPU 就向相应的设备控制器发出一条设备 I/O 启动指令，然后 CPU 又返回做原来的工作。CPU 与 I/O 设备可以并行工作。\n5.3 DMA（Direct Memory Access，直接主存存取） 通过DMA 控制器直接进行批量数据交换，除了在数据传输开始和结束时，整个过程无须 CPU 的干预。\n真题示例 - 5.1：\nDMA（直接存储器访问）工作方式是在（）之间建立起直接的数据通道。\nA. CPU 与 外设 B. CPU 与 主存 C. 主存 与 外存 D. 外设 与 外设\n六 文件存储管理 真题示例 - 6.1：\n某文件系统文件存储采用文件索引节点法。假设文件索引节点中有 8 个地址项 iaddr[0] ~ iaddr[7]，每个地址项大小为 4 字节，其中地址项 iaddr[0] ~ iaddr[5] 为直接地址索引，iaddr[6] 是一级间接地址索引，iaddr[7] 是二级间接地址索引，磁盘索引块和磁盘数据块大小均为 4KB。该文件系统可表示的单个文件最大长度是（）KB。若要访问 iclsClient.dll 文件的逻辑块号分别为 6、520 和 1030，则系统应分别采用（）。\nA. 1030 B. 65796 C. 1049606 D. 4198424\nA. 直接地址索引、一级间接地址索引和二级间接地址索引\nB. 直接地址索引、二级间接地址索引和二级间接地址索引\nC. 一级间接地址索引、 一级间接地址索引和二级间接地址索引\nD. 一级间接地址索引、二级间接地址索引和二级间接地址索引\n七 设备管理 位示图法。该方法是在外存上建立一张位示图（Bitmap），记录文件存储器的使用情况。每一位仅对应文件存储器上的一个物理块，取指 0 和 1 分别表示空闲和占用。\n真题示例 - 7.1：\n某文件管理系统在磁盘上建立了位示图（bitmap），记录磁盘的使用情况。若磁盘上物理块的编号依次为 0、1、2、\u0026hellip;。系统中的字长为 64 位，字的编号依次为 0、1、2\u0026hellip;。字中的一位对应文件存储器上的一个物理块。取值 0 和 1 分别表示空闲和占用。如下图所示。假设操作系统将 256 号物理块分配给某文件，那么该物理块的使用情况在位示图中编号为（）的字中描述，系统应该将（）。\nA. 3 B. 4 C. 5 D. 6\nA. 该字的 0 号位置 “1”\nB. 该字的 63 号位置 “1”\nC. 该字的 0 号位置 “0”\nD. 该字的 63 号位置 “0”\n真题答案 真题 答案 3.1 B、D 3.2 C、A 4.1 A、B 5.1 C 6.1 D、C 7.1 B、A ","permalink":"https://tofuwine.github.io/posts/4077b0b3/","summary":"【软件设计师】第三章 操作系统","title":"第三章 操作系统"},{"content":"一 章节知识架构图 二 程序语言基本概念 解释型\n① 没有中间代码生成与目标机器码代码\n② 不产生目标程序\n③ 运行效率低\n编译型\n① 保存机器码\n② 生成目标程序\n③ 运行效率高\n三 编译程序基本原理 3.1 词法分析阶段 词法分析阶段：输入源程序，对构成源程序的字符串进行扫描和分解，识别出一个个的单词，删掉无用的信息，报告分析时的错误。\nc 1 2 3 4 int foo(int a) { int b = a + 3; return b; } 3.2 语法分析阶段 语法分析阶段：语法分析器以单词符号作为输入，分析单词符号是否形成符合语法规则的语法单位，如表达式、赋值、循环等，按语法规则分析检查每条语句是否有正确的逻辑结构。\n词法分析与语法分析本质上都是对源程序的结构进行分析。\n3.3 语义分析阶段 语义分析阶段：主要检查源程序是否存在语义错误，并收集类型信息供后面的代码生成阶段使用，如：赋值语句的右端和左端的类型不匹配。表达式的除数是否为零等。\n语义分析分为静态分析和动态分析两个部分。静态语义分析使用语法制导翻译。\n3.4 中间代码生成 中间代码：不依赖具体计算机，表现形式如下：\n（1）后缀式（逆波兰式）\n（2）树型表示\n（3）三元式：\\$X=(a+b)*(c+d)\\$\n①(+,a,b) ②(+,c,d) ③(*, ①，②) ④(=, ③, x)\n（4）四元式\n3.5 出错处理 静态错误 编译时出现\n语法错误\n单词拼写错误、标点符号错误、表达式中缺少操作数、括号不匹配等有关语言结构上的错误。 静态语义错误\n运算符与运算对象类型不合法。 动态错误 程序运行时出现\n变量取 0 做除数、引用数组下标越界\n真题示例 - 3.1：\n以编译方式翻译 C/C++ 源程序的过程中，（）阶段的主要任务是对各条语句的结构进行合法性分析。\nA. 词法分析 B. 语义分析 C. 语法分析 D. 目标代码生成\n真题示例 - 3.2：\n对于后缀表达式 \\$abc-+d*\\$（其中，\\$-\\$、\\$+\\$、* 表示二元算术运算减、加、乘），与该后缀式等价的语法树为（）。\n四 有限自动机 确定的有限自动机（DFA）：该状态机在任何一个状态，基于输入的字符都能做成一个确定的状态转换。\n不确定的有限自动机 （NFA）：该状态机在任何一个状态，基于输入的字符都不能做成一个确定的状态转换。\n这里分两种情况：\n① 对于一个输入，它有两个状态可以转换；\n② 存在 \\$\\varepsilon\\$ 的情况，即没有任何字符输入的情况下，NFA 可以从一个状态迁移到另一个状态。\n真题示例 - 4.1：\n下图所示为一个非确定有限自动机（NFA），S0 为初态（S3 为终态）。该 NFA 识别的字符串为 （）。\nA. 不能包含连续的字符 \u0026ldquo;0\u0026rdquo;\nB. 不能包含连续的字符 \u0026ldquo;1\u0026rdquo;\nC. 必须以 \u0026ldquo;101\u0026rdquo; 开头\nD. 必须以 \u0026ldquo;101\u0026rdquo; 结尾\n真题示例 - 4.2：\n某确定的有限自动机（DFA）的状态转换图如下图所示（A 是初态，D、E 是终态），则该 DFA 能识别（）。\nA. 00110 B. 10101 C. 11100 D. 11001\n真题答案 题号 答案 3.1 C 3.2 B 4.1 D 4.2 C ","permalink":"https://tofuwine.github.io/posts/42def752/","summary":"【软件设计师】第二章 程序设计语言基础知识","title":"第二章 程序设计语言基础知识"},{"content":"章节知识架构图 一 CPU 现代计算机硬件图\n运算器 ① 算术逻辑单元（ALU）：数据的算术运算和逻辑运算\n② 累加寄存器（AC）：通用寄存器，为 ③ ALU 提供一个工作区，用来暂存数据\n④ 数据缓冲寄存器（DR）：写内存时，暂存指令或数据\n⑤ 状态条件寄存器（PSW）：存状态标志与控制标志\n控制器 ① 程序计数器（PC）：存储下一条要执行指令的地址\n② 指令库寄存器（IR）：存储即将执行的指令\n③ 指令译码器（ID）：对指令中的操作码字段进行分析解释\n④ 地址寄存器（AR）：用来保存当前 CPU 所访问的内存单元的地址\n⑤ 时序部件：提供时序控制信号\n真题示例 - 2.1：\nCPU 执行算术运算或者逻辑运算时，常将源操作数和结果暂存在（）中。\nA. 程序计数器（PC） B. 累加器（AC）\nC. 指令寄存器（IR） D. 状态寄存器（PSW）\n三 主存 存储器的基本单位是存储单元，一般以 8 位二进制为一个存储单元。每个存储单元都有一个地址，一般用十六进制数表示。\n真题示例 - 3.1\n内存按字节编址，地址从 A0000H 到 CFFFFH 的内存，共有（）字节，若用存储容量为 64K × 8bit 的存储器芯片构成该内存空间，至少需要（）片。\nA. 80K B. 96K C. 160K D. 192K\nA. 2 B. 3 C. 5 D. 8\n四 存储器 4.1 Cache（高速缓冲存储器） 作用：解决 CPU 和主存之间的速度差异，避免 CPU “空等” 现象。\nCache 的映像方法 ① 直接映像\n直接映像方式的优点是地址变换很简单，缺点是不灵活，块冲突率高。\n② 全相联映像\n全相联映像位置不受限制，十分灵活。其主要缺点是无法从主存块号中直接获得 Cache 的块号，变换比较复杂，速度比较慢。\n③ 组相联映像 （注：非考点内容）\n4.2 磁盘存储器 常用的外存有磁带存储器、硬盘存储器、磁盘阵列和光盘存储器。\n磁盘存取时间：\n\\$寻道时间 + 等待时间 + 读/写时间\\$\n其中读/写时间可忽略不计，\n\\$平均寻道时间 + 平均等待时间\\$\n真题示例 - 4.1：\n在磁盘调度管理中，应先进行移臂调度，再进行旋转调度。假设磁盘移动臂位于 21 号柱面上，进程的请求序列如下表所示。如果采用最短移臂调度算法，那么系统的响应序列应为（）。\nA. ②⑧③④⑤①⑦⑥⑨ B. ②③⑧④⑥⑨①⑤⑦\nC. ①②③④⑤⑥⑦⑧⑨ D. ②⑧③⑤⑦①④⑥⑨\n五 校验码 5.1 奇偶校验码 保持 1 的个数为奇数/偶数。只能发现奇数个位出错的情况。\n00100011 偶校验：100100011 奇校验：000100011\n以偶校验为例： 假设 100100011 有一位出错 → 100100010 假设 100100011 有两位出错 → 100100000\n5.2 海明码 海明码是建立在奇偶校验码基础上的。海明码的校验码的位置必须是在 \\$2^n\\$ 位置（n 从 0 开始，分别代表从右边数起分别是第 1、2、4、8、16 ……），信息码也就是在非 \\$2^n\\$ 位置。\n设数据位是 n 位，校验位是 k 位，则 n 和 k 必须满足以下关系：\n$$ \\bf \\textcolor{red}{2^k - 1 \\geq n + k} $$ 真题示例 - 5.1：\n海明码是一种纠错码，其方法是为需要校验的数据位增加若干校验位，使得校验位的值决定于某些被校位的数据，当被校数据出错时，可根据校验位的值得变化找到出错位，从而纠正错误。对于 32 位的数据，至少需要加（）个校验位才能构成海明码。\nA. 3 B. 4 C. 5 D. 6\n六 指令系统 名称 指令要求 寻址方式 实现方式 编译 复杂指令系统 CISC 指令数量众多，使用频率相差悬殊。可变长指令格式。 多种寻址方式 与主存直接交互。微程序控制 编译复杂 精简指令系统 RISC 指令数量少，长度固定 寻址方式少 硬布线逻辑控制。流水线技术。与寄存器交互 优化的编译器 七 流水线 7.1 流水线周期 流水线周期：执行时间最长的一段\n7.2 流水线执行时间公式 $$\\bf \\textcolor{red}{(t1+t2+ \\cdots +tk)+(n-1) \\times \\Delta t}$$ 例题：若流水线把一条指令分为取指、分析和执行三个部分，三部分的时间分别是取指 2ns，分析 2ns，执行 1ns。那么流水线周期是多少？100 条指令全部执行完毕需要的时间是多少？\n7.3 流水线的吞吐率和最大吞吐率 吞吐率是指单位时间内流水线处理机流出的结果数。对指令而言，就是单位时间内执行的指令数。\n$$TP = \\frac{指令条数}{流水线执行时间}$$ $${TP}_{max} = \\lim_{n \\to \\infty} \\frac{n}{(k+n-1)\\Delta t} = \\textcolor{red}{\\frac{1}{\\Delta t}}$$ 真题示例 - 7.1：\n执行指令时，将每一节指令部分分解为：取指、分析和执行三步，已知取指令时间 \\$t_{取指} =5 \\Delta t\\$，分析时间 \\$t_{分析} = 2 \\Delta t\\$，执行时间 \\$t_{分析}=3 \\Delta t\\$，如果按照 [执行]k，分析 k+1、取指 k+2 重叠的流水线方式执行指令，从头到尾执行完 500 条指令需（）\\$\\Delta t\\$。\nA. 2500 B. 2505 C. 2510 D. 2515\n八 系统可靠度分析 8.1 串联系统 假设一个系统由 n 个子系统组成，当且仅当所有的子系统都能正常工作时，系统才能正常工作，这种系统称为串联系统。\n如果系统的各个子系统的可靠度分别用 \\$R_1, R_2, \\cdots, R_n\\$ 表示，则系统的可靠度为：\n$$\\textcolor{red}{R = R_1 \\times R_2 \\times \\cdots \\times R_n}$$ 8.2 并联系统 可靠度：\n$$\\textcolor{red}{R = 1 - (1 - R_1) \\times (1 - R_2) \\times \\cdots \\times (1 - R_n)}$$ 真题示例 - 8.1：\n某系统由 3 个部件组成，每个部件的千小时可靠度都为 R，该系统的千小时可靠度为 \\$(1-(1-R)^2)R\\$，则该系统的构成方式是（）。\nA. 3 个部件串联\nB. 3 个部件并联\nC. 前两个部件并联后与第三个部件串联\nD. 第一个部件与后两个部件并联构成的子系统串联\n附录：真题答案 真题序号 答案 2.1 B 3.1 D、B 4.1 D 5.1 D 7.1 B 8.1 C ","permalink":"https://tofuwine.github.io/posts/f9e86e51/","summary":"【软件设计师】第一章 计算机基础","title":"第一章 计算机基础"}]