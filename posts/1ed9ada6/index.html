<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>第九章 数据结构 | Tofuwine's Blog</title>
<meta name=keywords content="软考,软件设计师"><meta name=description content="【软件设计师】第九章 数据结构"><meta name=author content="tofuwine"><link rel=canonical href=https://tofuwine.github.io/posts/1ed9ada6/><meta name=google-site-verification content="ckyTuus1DUaw4_LZBZpYeGKqKWmtHFLEeqp1rsXNwZA"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><meta name=baidu-site-verification content="codeva-9WUKJrZrua"><script defer src=https://static.cloudflareinsights.com/beacon.min.js data-cf-beacon='{"token": "d28b07fc964a45f4aeb37a3550910329"}'></script><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://tofuwine.github.io/images/favicon.svg><link rel=icon type=image/png sizes=16x16 href=https://tofuwine.github.io/images/favicon.svg><link rel=icon type=image/png sizes=32x32 href=https://tofuwine.github.io/images/favicon.svg><link rel=apple-touch-icon href=https://tofuwine.github.io/images/favicon.svg><link rel=mask-icon href=https://tofuwine.github.io/images/favicon.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://tofuwine.github.io/posts/1ed9ada6/><noscript><style>#theme-toggle,#top-link{display:none}</style></noscript><link crossorigin=anonymous href=/assets/css/pe.min.css rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/pe.min.js></script><link rel=stylesheet href=https://cdn.staticfile.net/font-awesome/6.5.1/css/all.min.css><link rel=stylesheet href=https://cdn.staticfile.net/font-awesome/6.5.1/css/v4-shims.min.css><script defer src=https://cdn.staticfile.net/jquery/3.5.1/jquery.min.js></script><link rel=stylesheet href=https://cdn.staticfile.net/fancybox/3.5.7/jquery.fancybox.min.css><script defer src=https://cdn.staticfile.net/fancybox/3.5.7/jquery.fancybox.min.js></script><script id=MathJax-script async src=https://cdn.staticfile.net/mathjax/3.2.2/es5/tex-chtml.js></script><script>MathJax={tex:{displayMath:[["$$","$$"]],inlineMath:[["\\$","\\$"]]}}</script><meta property="og:title" content="第九章 数据结构"><meta property="og:description" content="【软件设计师】第九章 数据结构"><meta property="og:type" content="article"><meta property="og:url" content="https://tofuwine.github.io/posts/1ed9ada6/"><meta property="article:section" content="topics"><meta property="article:published_time" content="2023-02-16T14:15:00+08:00"><meta property="article:modified_time" content="2023-02-16T14:15:00+08:00"><meta property="og:site_name" content="Tofuwine's Blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="第九章 数据结构"><meta name=twitter:description content="【软件设计师】第九章 数据结构"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"📂 专题","item":"https://tofuwine.github.io/topics/"},{"@type":"ListItem","position":2,"name":"📒 笔记本","item":"https://tofuwine.github.io/topics/notebook/"},{"@type":"ListItem","position":3,"name":"第九章 数据结构","item":"https://tofuwine.github.io/posts/1ed9ada6/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"第九章 数据结构","name":"第九章 数据结构","description":"【软件设计师】第九章 数据结构","keywords":["软考","软件设计师"],"articleBody":"一 章节知识架构图 二 线性结构 2.1 线性表 存储类型 特点 顺序存储 可以随机存取表中元素。插入和删除操作需要移动元素。移动元素的期望值：插入元素 n/2 个；删除元素 (n-1)/2 个 链式存储 链式存储结构有单链表、循环链表（循环单链表、循环双链表）等，其中单链表只能从头结点开始往后顺序遍历整个链表，而循环单链表可以从表中的任一结点开始遍历整个链表 真题示例 - 2.1\n设有一个包含 n 个元素的有序线性表。在等概率情况下删除其中一个元素，若采用顺序存储结构，则平均需要移动（）个元素；若采用单链表存储，则平均需要移动（）个元素。\nA. 1 B. (n-1)/2 C. Logn D. n\nA. 0 B. 1 C. (n-1)/2 D. n/2\n2.2 栈与队列 2.2.1 栈 栈的应用：表达式求值、括号匹配、递归\n1）表达式求值：\n2）括号匹配：()、[]、{}\n当扫描到左括号时，则将其压入栈中； 当扫描到右括号时，从栈顶取出一个左括号。 如果能匹配，比如(跟)匹配，[跟]匹配，{跟}匹配，则继续扫描剩下字符串。 如果扫描的过程中，遇到不能配对的右括号，或者栈中没有数据，则说明为非法格式。 当所有的括号都扫描完成之后，如果栈为空，则说明字符串为合法格式；否则说明有未匹配的左括号，为非法格式。 3）递归：\n\\$4!=4 \\times 3! = 3 \\times 2! = 2 \\times 1! = 1 \\times 0! = 1 \\times 1\\$\n2.2.1.1 顺序存储结构 预先申请栈空间，栈满则元素不能入栈。\n2.2.1.2 链式存储结构 用链表表示栈，用链表实现的栈称为链栈。由于栈中元素的插入和删除仅在栈顶一端进行，因此不必另外设置头指针，链表的头指针就是栈顶指针。\n真题示例 - 2.2\n栈的特点是后进先出，若用单链表作为栈的存储结构，并用头指针作为栈顶指针，则（）。\nA. 入栈和出栈操作都不需要遍历链表\nB. 入栈和出栈操作都需要遍历链表\nC. 入栈操作需要遍历链表而出栈操作不需要\nD. 入栈操作不需要遍历链表而出栈操作需要\n2.2.2 队列 队列的应用：打印队列。\n2.2.2.1 顺序存储 用顺序存储线性表来表示队列，为了指明当前执行出队运算的队首位置，需要一个指针变量 head（称为头指针）。为了指明当前执行进队运算的队尾位置，也需要一个指针变量 tail（称为尾指针）。\n缺点：会造成空间的浪费。\n2.2.2.2 链式存储 用链接存储线性表来实现队列，用链表实现的队列称为链接队列。\n2.2.2.3 循环队列 循环队列解决顺序存储造成空间浪费的缺点。但是会存在无法判断空队列与队列满的情况（因为此时 front 和 rear 指针都指向相同位置）。解决办法：牺牲一个元素空间，空队列时 front = rear，队列满时 front = rear + 1.\n真题示例 - 2.3\n某循环队列 Q 的定义中用 front 和 rear 两个整型域变量表示队列状态，其中 front 指示队头元素的位置，rear 指示队尾元素之后的位置（如下图所示，front 的值为 5、rear 的值为 1）。若队列容量 M （下面图中 M = 6），则计算队列长度的通式为（）。\nA. \\$\\bf (Q.front - Q.rear)\\$\nB. \\$\\bf (Q.front - Q.rear + M) \\% M\\$\nC. \\$\\bf (Q.rear - Q.front)\\$\nD. \\$\\bf (Q.rear - Q.front + M) \\% M\\$\n真题示例 - 2.4\n对于一个长度为 n(n\u003e1) 且元素互异的序列，令其所有元素依次通过一个初始为空的栈后，再通过一个初始为空的队列。假设队列和栈的容量都足够大，且只要栈非空就可以进行出栈操作，只要队列非空就可以进行出队操作，那么一下叙述中，正确的是（）。\nA. 出队序列和出栈序列一定互为逆序\nB. 出队序列和出栈序列一定相同\nC. 入栈序列和入队序列一定相同\nD. 入栈序列与入队序列一定互为逆序\n2.2.2.4 双端队列 某双端队列如下图所示，要求元素进出队列必须在同一端口，即从 A 端进入的元素必须从 A 端出、从 B 端进入的元素必须从 B 端出。\n真题示例 - 2.5\n双端队列是指在队列的两个端口都可以加入和删除元素，如下图所示，现在要求元素进队列和出队列必须在同一端口。即从 a 端进队的元素必须从 a 端出，从 b 端进队的元素必须从 b 端出。则对于四个元素的序列 a、b、c、d，若要求前两个元素 a、b 从 a 端口按次序全部进入队列。后两个元素 c、d 从 b 端口按次序全部进入队列，则不可能得到的出队序列是（）。\nA. d、a、b、c\nB. d、c、b、a\nC. b、a、d、c\nD. b、d、c、a\n2.3 串 串是仅由字符构成的有限序列，是一种线性表。一般记为 \\$s='a1a2 \\cdots an'(n\u003e0)\\$，其中 s 是串的名称，用单引号括起来的是字符序列是串值。串的基本概念：\n空串：长度为零的串称为空串，空串不包含任何字符。 空格串：由一个或多个空格组成的串 子串：由串种任意长度的连续字符构成的序列称为子串。含有子串的串称为主串。空串是任意串的子串。 真题示例 - 2.6\n设 S 是一个长度为 n 的非空字符串，其中的字符各不相同，则其互异的非平凡子串（非空且不同于 S 本身）个数为（）。\nA. \\$2n-1\\$ B. \\$n^2\\$ C. \\$n(n+1)/2\\$ D. \\$(n+2)(n-1)/2\\$\n三 非线性结构 3.1 二维数组 $$ A_{m \\times n}= \\left[ \\begin{matrix} a_{11} \u0026 a_{12} \u0026 a_{13} \u0026 \\cdots \u0026 a_{1n} \\\\ a_{21} \u0026 a_{22} \u0026 a_{23} \u0026 \\cdots \u0026 a_{2n} \\\\ \\vdots \u0026 \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\vdots \\\\ a_{m1} \u0026 a_{m2} \u0026 a_{m3} \u0026 \\cdots \u0026 a_{mn} \\end{matrix} \\right] $$ 按行存储：\n$$A_{m,n}=\\big[[a_{11}a_{12} \\cdots a_{1n}],[a_{21}a_{22} \\cdots a_{2n}], \\cdots,[a_{m1}a_{m2} \\cdots a_{mn}]\\big]$$ 按列存储：\n$$A_{m,n}=\\big[[a_{11}a_{21} \\cdots a_{m1}],[a_{12}a_{22} \\cdots a_{m2}], \\cdots,[a_{1n}a_{2n} \\cdots a_{mn}]\\big]$$ 真题示例 - 3.1\n某 n 阶矩阵 A 如下图所示，按行将元素存储在一堆数组 M 中，设 \\$a_{1,1}\\$ 存储在 M[1]，那么 \\$a_{i,j}\\$(1 \u003c= i, j \u003c= n且 \\$a_{i,j}\\$ 位于三条对角线中），存储在 M（）。\nA. \\$i+2j\\$ B. \\$2i+j\\$ C. \\$i+2j-2\\$ D. \\$2i+j-2\\$\n3.2 树 考试只考二叉树\n父亲、孩子和兄弟 结点的度 叶子结点 内部结点 层次 树的高度 树的三种形式：\n3.2.1 二叉树 在二叉树的第 i 层最多有 \\$2^{i-1}\\$ 个结点（\\$i \\geq 1\\$） 深度为 k 的二叉树最多有 \\$2^k-1\\$ 个结点（\\$k \\geq 1\\$） 对于任何一棵二叉树，如果其叶子结点数为 \\$N_0\\$，度为 2 的结点数为 \\$N_2\\$，则 \\$N_0=N_2+1\\$ 具有 n 个结点的完全二叉树的深度为 \\$\\lfloor \\log_2n \\rfloor +1\\$\n如果 \\$i=1\\$，则结点 \\$i\\$ 无父结点，是二叉树的根\n如果 \\$i\u003e1\\$，则父结点是 \\$\\lfloor i/2 \\rfloor\\$\n如果 \\$2i\u003en\\$，则结点 \\$i\\$ 为叶子结点，无左子结点，否则其左子结点是 \\$2i\\$\n如果 \\$2i+1\u003en\\$，则结点 \\$i\\$ 无右子结点，否则，其右子结点是 \\$2i+1\\$ 3.2.2 二叉树的遍历 遍历方式 结果 层次遍历 1、2、3、4、5、6、7、8 前序遍历 （根、左、右） 1、2、4、5、7、8、3、6 中序遍历 （左、根、右） 4、2、7、8、5、1、3、6 后序遍历 （左、右、根） 4、8、7、5、2、6、3、1 真题示例 - 3.2\n某二叉树的中序，先序遍历序列分别为 {20，30，10，50，40}，{10，20，30，40，50} 则该二叉树的后序遍历序列为（）。\nA. 50，40，30，20，10\nB. 30，20，10，50，40\nC. 30，20，50，40，10\nD. 20，30，10，40，50\n真题示例 - 3.3\n二叉树的高度是指其层数，空二叉树的高度为 0，仅有根结点的二叉树高度为 1。若某二叉树中共有 1024 个结点，则该二叉树的高度是整数区间的（）中的任一值。\nA. (10, 1024) B. [10, 1024]\nC. (11, 1024) B. [11, 1024]\n3.2.3 二叉树的存储 3.2.3.1 顺序存储 真题示例 - 3.4\n对下面的二叉树进行顺序存储（用数组 MEM 表示），已知结点 A、B、C 在 MEM 中对应元素的下标分别为 1、2、3，那么结点 D、E、F 对应的数组元素下标为（）。\nA. 4、5、6 B. 4、7、10 C. 6、7、8 D. 6、7、14\n3.2.3.2 链式存储 3.2.4 二叉查找树 二叉排序树又称为二叉查找树，其定义为二叉排序树或者是一棵空二叉树，或者是具有如下性质的二叉树：\n（1）若它的左子树非空，则左子树上所有结点的值均小于根结点。\n（2）若它的右子树非空，则右子树上所有结点的值均大于根结点。\n（3）左、右子树本身右各是一个二叉排序树。\n如果中序遍历二叉排序树，就能得到一个排好序的结点序列。\n3.2.5 哈夫曼树 给定 N 个权值作为 N 个叶子结点，构造一棵二叉树，若该树的带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树（Huffman Tree）。哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近。\n真题示例 - 3.5\n已知一个文件中出现的各字符及其对应的频率如下表所示。采用 Huffman 编码，则该文件中字符 a 和 c 的码长分别为（）。若采用 Huffman 编码，则字符序列 110001001101 的编码应为（）。\n字符 a b c d e f 频率 (%) 45 13 12 16 9 5 A. 1 和 3 B. 1 和 4 C. 3 和 3 D. 3 和 4\nA. face B. bace C. acde D. fade\n3.3 图 图 G 由两个集合 V 和 E 组成，记为 \\$G = (V,E)\\$，其中 V 是顶点的有穷非空集合，E 是 V 中顶点偶对（称为边）的有穷集合。通常，也将图 G 的顶点集和边集分别记为 V(G) 和 E(G)。E(G) 可以是空集。若 E(G) 为空，则图 G 只有顶点而没有边。\n3.3.1 完全图 若一个无向图具有 n 个顶点，而每个顶点与其他 n-1 个顶点之间都有边，则称为无向完全图。无向完全图共有 \\$\\bf \\frac{n(n-1)}{2}\\$ 条边。\n有 n 个顶点的有向完全图中弧的数目为 \\$n(n-1)\\$，即任意两个不同顶点之间都有方向相反的两个弧存在。\n3.3.2 连通图 在无向图 G 中，若从顶点 \\$V_i\\$ 到顶点 \\$V_j\\$ 有路径，则称顶点 \\$V_i\\$ 和顶点 \\$V_j\\$ 是连通的。如果无向图 G 中任意两个顶点都是连通的，则称其为连通图。\n3.3.3 强连通图 有向图中，若任意两个顶点 \\$V_i\\$ 和 \\$V_j\\$，满足从 \\$V_i\\$ 到 \\$V_j\\$ 以及从 \\$V_j\\$ 到 \\$V_i\\$ 都连通，也就是都含有至少一条通路，则称为强连通图。有向图中的极大连通图子图称为有向图的强连通分量。\n3.3.4 图的存储结构 3.3.4.1 邻接矩阵 有向图的邻接矩阵不一定对称。\n无向图的邻接矩阵是对称的。\n3.3.4.2 邻接表 在图的邻接表中，为图的每个顶点建立一个链表，且第 i 个链表中的结点代表与顶点 i 相关联的一条边或由顶点 i 出发的一条弧。有 n 个顶点的图，需要用 n 个链表表示，这 n 个链表的头指针通常由顺序线性表存储。\n3.3.5 图的遍历 图的遍历是指从某个顶点出发，沿着某条搜索路径对图中的所有顶点进行访问且只访问一次的过程。\n方法 示例 特征 深度优先 DFS V1,V2 V4,V8 V5,V3 V6,V7 相当于树的前序遍历。邻接矩阵表示的时间复杂度 \\$O(n^2)\\$，邻接表表示的实际复杂度是 \\$O(n+e)\\$ 广度优先 BFS V1,V2 V3,V4 V5,V6 V7,V8 相当于树的层次遍历。时间复杂度同上 真题示例 - 3.6\n图 G 的邻接矩阵如下图所示（顶点依次表示为 v0, v1, v2, v3, v4, v5），G 是（）。对 G 进行广度优先遍历（从 v0 开始），可能的遍历序列为（）。\n$$ \\left[ \\begin{matrix} \\infty \u0026 18 \u0026 17 \u0026 \\infty \u0026 \\infty \u0026 \\infty \\\\ \\infty \u0026 \\infty \u0026 \\infty \u0026 20 \u0026 16 \u0026 \\infty \\\\ \\infty \u0026 19 \u0026 \\infty \u0026 23 \u0026 \\infty \u0026 \\infty \\\\ \\infty \u0026 \\infty \u0026 \\infty \u0026 \\infty \u0026 \\infty \u0026 15 \\\\ \\infty \u0026 \\infty \u0026 \\infty \u0026 \\infty \u0026 \\infty \u0026 12 \\\\ \\infty \u0026 \\infty \u0026 \\infty \u0026 \\infty \u0026 \\infty \u0026 \\infty \\\\ \\end{matrix} \\right] $$ A. 无向图 B. 有向图 C. 完全图 D. 强连通图\nA. v0、v1、v2、v3、v4、v5\nB. v0、v2、v4、v5、v1、v3\nC. v0、v1、v3、v5、v2、v4\nD. v0、v2、v4、v3、v5、v1\n真题示例 - 3.7\n对于如下所示的有向图，其邻接矩阵是一个（）的矩阵，采用邻接链表存储时顶点的表结点个数为 2，顶点 5 的表结点个数为 0，顶点 2 和 3 的表结点个数分别为（）。\nA. 5*5 B. 5*7 C. 7*5 D. 7*7\nA. 2.1 B. 2.2 C. 3.4 D. 4.3\n四 数据运算 4.1 时间复杂度 4.1.1 \\$O(1)\\$ c 1 2 3 Temp=i; i=j; j=temp; 以上三条单个语句的频度均为 1，是一个常数阶，记作 \\$T(n)=O(1)\\$。此算法的执行时间不随着问题规模 n 的增加而增长，即使算法中有上千条语句，其执行时间也不过是一个较大的常数。此算法的时间复杂度是 \\$O(1)\\$。\n4.1.2 \\$O(n)\\$ c 1 2 3 4 5 int sum = 0; for (int i = 0; i \u003c= n; ++i) { sum += i; } 一共算了 n 次加法，那么就说这个时间复杂度是 \\$O(n)\\$。比如，某个计算共计算了 \\$2n+1\\$ 次，那么这个时间复杂度也是 \\$O(n)\\$\n4.1.3 \\$O(n^2)\\$ c 1 2 3 4 5 6 7 8 int sum=0; for (int i = 0; i \u003c= n; ++i) { for (int j = 0; j \u003c= n; ++j) { sum += (i + j) } } 4.1.4 \\$\\log_2(n)\\$ 二分查找每次排除掉一半不适合值，所以对于 n 个元素的情况：\n一次二分剩下：\\$n/2\\$ 两次二分剩下：\\$n/2/2 = n/4\\$ 三次二分剩下：\\$n/4/2 = n/8\\$ m 次二分剩下：\\$n/(2^m)\\$ 在最坏情况下是在排除到只剩下最后一个值之后得到结果，所以为 \\$\\frac{n}{(2^m)}=1 \\Rightarrow n=2^m\\$，所以时间复杂度为 \\$\\log_2(n)\\$\n4.2 查找算法 4.2.1 顺序查找 将待查的元素从头到尾与表中元素进行比较，如果存在，则返回成功；否则，查找失败。此方法效率不高，平均查找长度 \\$\\textcolor{red}{(n+1)/2}\\$（设置监视哨）\n4.2.2 二分查找 【例题】请给出在含有 12 个元素的有序表 {1，4，10，16，17，18，23，29，33，40，50，51} 中二分查找关键字 17 的过程。\n4.2.3 哈希查找 哈希表 hashtable 通过一个已记录的关键字为自变量的函数（哈希函数）得到该记录的存储地址，所以在哈希表中进行查找操作时，需用同一个哈希函数计算得到待查记录的存储地址，然后到相应的存储单元去获取有关信息再判定查找是否成功。\n冲突的解决方式：随机探测再散列、线性探测。\n【例题】设关键码序列为”47，34，13，12，52，38，33，27，3”，哈希表表长为 11，哈希函数为 Hash(key)=key mod 11，则\nHash(47) = 47 MOD 11 = 3, Hash(34) = 34 MOD 11 = 1,\nHash(13) = 13 MOD 11 = 2, Hash(12) = 12 MOD 11 = 1,\nHash(52) = 52 MOD 11 = 8, Hash(38) = 38 MOD 11 = 5,\nHash(33) = 33 MOD 11 = 0, Hash(27) = 27 MOD 11 = 5,\nHash(3) = 3 MOD 11 = 3\n使用线性探测法解决冲突构造的哈希表如下：\n哈希地址 0 1 2 3 4 5 6 7 8 9 10 关键字 33 34 13 47 12 38 27 3 52 使用链地址法构造的哈希表如图所示：\n上图所示的哈希表中进行成功查找的平均查找长度 ASL 为 $6 \\times 1 + 3 \\times 2)/9 \\approx 1.34$\n真题示例 - 4.1\n设散列函数为 $H（key）= key \\mod 11$ 对于关键字序列（23，40，91，17，19，10，31，65，26），用线性探测法解决冲突构造的哈希表为（）。\n4.3 排序算法 排序方法 时间复杂度\n最好 时间复杂度\n最坏 时间复杂度\n平均 稳定性 直接插入 \\$O(n) \\$ \\$O(n^2) \\$ \\$O(n^2) \\$ 稳定 简单选择 \\$O(n^2) \\$ \\$O(n^2) \\$ \\$O(n^2) \\$ 不稳定 冒泡排序 \\$O(n) \\$ \\$O(n^2) \\$ \\$O(n^2) \\$ 稳定 希尔排序 \\$O(n) \\$ \\$O(n^{1.3}) \\$ \\$O(n^{1.3}) \\$ 不稳定 快速排序 \\$O(n^2) \\$ \\$O(n\\log_2{n}) \\$ \\$O(n\\log_2{n}) \\$ 不稳定 堆排序 \\$O(n\\log_2{n}) \\$ \\$O(n\\log_2{n}) \\$ \\$O(n\\log_2{n}) \\$ 不稳定 归并排序 \\$O(n\\log_2{n}) \\$ \\$O(n\\log_2{n}) \\$ \\$O(n\\log_2{n}) \\$ 稳定 4.3.1 直接插入排序 抱歉，此节笔记缺失 4.3.2 冒泡排序 【例题】排序数组：int[] arr = {6,3,8,2,9,1}\n第一趟排序：\n第一次排序：6 和 3 比较，6 大于 3，交换位置：3 6 8 2 9 1 第二次排序，6 和 8 比较，6 小于 8，不交换位置：3 6 8 2 9 1 第三次排序：8 和 2 比较，8 大于 2，交换位置：3 6 2 8 9 1 第四次排序：8 和 9 比较，8 小于 9，不交换位置：3 6 2 8 9 1 第五次排序：9 和 1 比较，9 大于 1，交换位置：3 6 3 8 1 9 第一趟总共进行了 5 次比较，排序结果：3 6 2 8 1 9\n第二趟排序：\n第一次排序：3 和 6 比较，3 小于 6，不交换位置：3 6 2 8 1 9 第二次排序：6 和 2 比较，6 大于 2，交换位置：3 2 6 8 1 9 第三次排序：6 和 8 比较，6 大于 8，不交换位置：3 2 6 8 1 9 第四次排序：8 和 1 比较，8 大于 1，交换位置：3 2 6 1 8 9 第二趟总共进行了 4 次比较，排序结果：3 2 6 1 8 9\n第三趟排序：\n第一次排序：3 和 2 比较，3 大于 2，交换位置：2 3 6 1 8 9 第二次排序：3 和 6 比较，3 小于 6，不交换位置：2 3 6 1 8 9 第三次排序：6 和 1 比较，6 大于 1，交换位置：2 3 1 6 8 9 第三趟总共进行了 3 次排序，排序结果：2 3 1 6 8 9\n第四趟排序：\n第一次排序：2 和 3 比较，2 小于 3，不交换位置：2 3 1 6 8 9 第二次排序：3 和 1 比较，3 大于 1，交换位置：2 1 3 6 8 9 第四趟总共进行了 2 次排序，排序结果：2 1 3 6 8 9\n第五趟排序：\n第一次排序：2 和 1 比较，2 大于 1，交换位置：1 2 3 6 8 9 第五趟总共进行了 1 次排序，排序结果：1 2 3 6 8 9\n最终结果：1 2 3 6 8 9\n4.3.3 简单选择排序 初始关键字：【8，5，2，6，9，3，1，4，0，7】\n第一趟排序后：0，【5，2，6，9，3，1，4，8，7】\n第二趟排序后：0，1，【2，6，9，3，5，4，8，7】\n第三趟排序后：0，1，2，【6，9，3，5，4，8，7】\n第四趟排序后：0，1，2，3，【9，6，5，4，8，7】\n第五趟排序后：0，1，2，3，4，【6，5，9，8，7】\n第六躺排序后：0，1，2，3，4，5，【6，9，8，7】\n第七趟排序后：0，1，2，3，4，5，6，【9，8，7】\n第八趟排序后：0，1，2，3，4，5，6，7，【8，9】\n第九趟排序后：0，1，2，3，4，5，6，7，8，【9】\n结果：【0，1，2，3，4，5，6，7，8，9】\n4.3.4 希尔排序 先将整个待排元素序列分割成若干个子序列（由相隔某个“增量”的元素组成的）分别进行直接插入排序，然后依次缩减增量再进行排序，待整个序列中的元素基本有序（增量足够小）时，再对全体元素进行一次直接插入排序。因为直接插入排序再元素基本有序的情况下（接近最好情况），效率是最高的。\n先取一个小于 n 的整数 d1，作为第一个增量，把文件的全部记录分成 d1 个组，即将所有距离为 d1 倍数序号的记录放在同一个组中，在组内进行直接插入排序；然后取第二个增量 d2 \u003c d1，重复上述步骤，依次类推，直到所取的增量 di = 1，即将所有记录放在同一组进行直接插入排序。\n4.3.5 快速排序 初始状态：46 30 82 90 56 17 95 15\n4.3.6 堆排序 对于 n 个元素的关键字序列 \\$\\{K_1,K_2, \\cdots, K_n\\}\\$，当且仅当满足下列关系时称其为堆，其中 \\$2i\\$ 和 \\$2i+1\\$ 应不大于 n。 $$ \\begin{cases} K_i \\leq K_{2i} \\\\ K_i \\leq K_{2i+1} \\end{cases} 或 \\begin{cases} K_i \\geq K_{2i} \\\\ K_i \\geq K_{2i+1} \\end{cases} $$ 为序列（55，60，40，10，80，65，15，5，75）建立初始大根堆的过程如图 3-56 所示，调整为新堆的过程如图 3-57 所示。\n4.3.7 归并排序 （1）分解。将 n 个元素分层各含 n/2 个元素的子序列。\n（2）求解。用归并排序对两个子序列递归地排序。\n（3）合并。合并两个已经排好序的子序列以得到排序结果。\n真题答案 题号 答案 2.1 B、A 2.2 A 2.3 D 2.4 B 2.5 A 2.6 D 3.1 D 3.2 C 3.3 D 3.4 D 3.5 A、A 3.6 B、A 3.7 A、B 4.1 B ","wordCount":"1457","inLanguage":"zh","datePublished":"2023-02-16T14:15:00+08:00","dateModified":"2023-02-16T14:15:00+08:00","author":{"@type":"Person","name":"tofuwine"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://tofuwine.github.io/posts/1ed9ada6/"},"publisher":{"@type":"Organization","name":"Tofuwine's Blog","logo":{"@type":"ImageObject","url":"https://tofuwine.github.io/images/favicon.svg"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://tofuwine.github.io/><img src=https://tofuwine.github.io/images/profile.png alt aria-label=logo height=35>Tofuwine's Blog</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://tofuwine.github.io/topics><span>📂 专题</span></a></li><li><a href=https://tofuwine.github.io/moments><span>🌟 瞬间</span></a></li><li><a href=https://tofuwine.github.io/archives><span>🗂️ 归档</span></a></li><li><a href=https://tofuwine.github.io/friend><span>🤝 友链</span></a></li><li><a href=https://tofuwine.github.io/search accesskey=/><span>🔍 搜索</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://tofuwine.github.io/>🏠 主页</a>&nbsp;»&nbsp;<a href=https://tofuwine.github.io/topics/>📂 专题</a>&nbsp;»&nbsp;<a href=https://tofuwine.github.io/topics/notebook/>📒 笔记本</a></div><h1 class="post-title entry-hint-parent">第九章 数据结构</h1><div class=post-meta><span class=pe-post-meta-item><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg><span>2023-02-16</span></span>&nbsp;·&nbsp;<span class=pe-post-meta-item><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text" style="user-select:text"><path d="M14 2H6A2 2 0 004 4v16a2 2 0 002 2h12a2 2 0 002-2V8z" style="user-select:text"/><polyline points="14 2 14 8 20 8" style="user-select:text"/><line x1="16" y1="13" x2="8" y2="13" style="user-select:text"/><line x1="16" y1="17" x2="8" y2="17" style="user-select:text"/><polyline points="10 9 9 9 8 9" style="user-select:text"/></svg><span>1457 字</span></span>&nbsp;·&nbsp;<span class=pe-post-meta-item><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><span>7 分钟</span></span>
<span class=pe-post-meta-item>&nbsp;·&nbsp;<svg t="1714036239378" fill="currentcolor" class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" p-id="6659" width="256" height="256"><path d="M690 78.2c-18.6-18.8-49-19-67.8-.4s-19 49-.4 67.8l255.4 258.6c67.8 68.6 67.8 178.8.0 247.4L653.4 878.2c-18.6 18.8-18.4 49.2.4 67.8s49.2 18.4 67.8-.4l224-226.4c104.8-106 104.8-276.4.0-382.4L690 78.2zM485.4 101.4c-24-24-56.6-37.4-90.6-37.4H96C43 64 0 107 0 160v299c0 34 13.4 66.6 37.4 90.6l336 336c50 50 131 50 181 0l267-267c50-50 50-131 0-181l-336-336zM96 160h299c8.4.0 16.6 3.4 22.6 9.4l336 336c12.4 12.4 12.4 32.8.0 45.2l-267 267c-12.4 12.4-32.8 12.4-45.2.0l-336-336c-6-6-9.4-14.2-9.4-22.6V160zm192 128a64 64 0 10-128 0 64 64 0 10128 0z" p-id="6660"/></svg></span><ul class=pe-post-meta-item><a href=https://tofuwine.github.io/tags/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/>#软件设计师</a></ul></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary><span class=details>目录</span></summary><div class=inner><ul><li><a href=#%e4%b8%80-%e7%ab%a0%e8%8a%82%e7%9f%a5%e8%af%86%e6%9e%b6%e6%9e%84%e5%9b%be aria-label="一 章节知识架构图">一 章节知识架构图</a><li><a href=#%e4%ba%8c-%e7%ba%bf%e6%80%a7%e7%bb%93%e6%9e%84 aria-label="二 线性结构">二 线性结构</a><ul><li><a href=#21-%e7%ba%bf%e6%80%a7%e8%a1%a8 aria-label="2.1 线性表">2.1 线性表</a><li><a href=#22-%e6%a0%88%e4%b8%8e%e9%98%9f%e5%88%97 aria-label="2.2 栈与队列">2.2 栈与队列</a><ul><li><a href=#221-%e6%a0%88 aria-label="2.2.1 栈">2.2.1 栈</a><ul><li><a href=#2211-%e9%a1%ba%e5%ba%8f%e5%ad%98%e5%82%a8%e7%bb%93%e6%9e%84 aria-label="2.2.1.1 顺序存储结构">2.2.1.1 顺序存储结构</a><li><a href=#2212-%e9%93%be%e5%bc%8f%e5%ad%98%e5%82%a8%e7%bb%93%e6%9e%84 aria-label="2.2.1.2 链式存储结构">2.2.1.2 链式存储结构</a></ul><li><a href=#222-%e9%98%9f%e5%88%97 aria-label="2.2.2 队列">2.2.2 队列</a><ul><li><a href=#2221-%e9%a1%ba%e5%ba%8f%e5%ad%98%e5%82%a8 aria-label="2.2.2.1 顺序存储">2.2.2.1 顺序存储</a><li><a href=#2222-%e9%93%be%e5%bc%8f%e5%ad%98%e5%82%a8 aria-label="2.2.2.2 链式存储">2.2.2.2 链式存储</a><li><a href=#2223-%e5%be%aa%e7%8e%af%e9%98%9f%e5%88%97 aria-label="2.2.2.3 循环队列">2.2.2.3 循环队列</a><li><a href=#2224-%e5%8f%8c%e7%ab%af%e9%98%9f%e5%88%97 aria-label="2.2.2.4 双端队列">2.2.2.4 双端队列</a></ul></ul><li><a href=#23-%e4%b8%b2 aria-label="2.3 串">2.3 串</a></ul><li><a href=#%e4%b8%89-%e9%9d%9e%e7%ba%bf%e6%80%a7%e7%bb%93%e6%9e%84 aria-label="三 非线性结构">三 非线性结构</a><ul><li><a href=#31-%e4%ba%8c%e7%bb%b4%e6%95%b0%e7%bb%84 aria-label="3.1 二维数组">3.1 二维数组</a><li><a href=#32-%e6%a0%91 aria-label="3.2 树">3.2 树</a><ul><li><a href=#321-%e4%ba%8c%e5%8f%89%e6%a0%91 aria-label="3.2.1 二叉树">3.2.1 二叉树</a><li><a href=#322-%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e9%81%8d%e5%8e%86 aria-label="3.2.2 二叉树的遍历">3.2.2 二叉树的遍历</a><li><a href=#323-%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e5%ad%98%e5%82%a8 aria-label="3.2.3 二叉树的存储">3.2.3 二叉树的存储</a><ul><li><a href=#3231-%e9%a1%ba%e5%ba%8f%e5%ad%98%e5%82%a8 aria-label="3.2.3.1 顺序存储">3.2.3.1 顺序存储</a><li><a href=#3232-%e9%93%be%e5%bc%8f%e5%ad%98%e5%82%a8 aria-label="3.2.3.2 链式存储">3.2.3.2 链式存储</a></ul><li><a href=#324-%e4%ba%8c%e5%8f%89%e6%9f%a5%e6%89%be%e6%a0%91 aria-label="3.2.4 二叉查找树">3.2.4 二叉查找树</a><li><a href=#325-%e5%93%88%e5%a4%ab%e6%9b%bc%e6%a0%91 aria-label="3.2.5 哈夫曼树">3.2.5 哈夫曼树</a></ul><li><a href=#33-%e5%9b%be aria-label="3.3 图">3.3 图</a><ul><li><a href=#331-%e5%ae%8c%e5%85%a8%e5%9b%be aria-label="3.3.1 完全图">3.3.1 完全图</a><li><a href=#332-%e8%bf%9e%e9%80%9a%e5%9b%be aria-label="3.3.2 连通图">3.3.2 连通图</a><li><a href=#333-%e5%bc%ba%e8%bf%9e%e9%80%9a%e5%9b%be aria-label="3.3.3 强连通图">3.3.3 强连通图</a><li><a href=#334-%e5%9b%be%e7%9a%84%e5%ad%98%e5%82%a8%e7%bb%93%e6%9e%84 aria-label="3.3.4 图的存储结构">3.3.4 图的存储结构</a><ul><li><a href=#3341-%e9%82%bb%e6%8e%a5%e7%9f%a9%e9%98%b5 aria-label="3.3.4.1 邻接矩阵">3.3.4.1 邻接矩阵</a><li><a href=#3342-%e9%82%bb%e6%8e%a5%e8%a1%a8 aria-label="3.3.4.2 邻接表">3.3.4.2 邻接表</a></ul><li><a href=#335-%e5%9b%be%e7%9a%84%e9%81%8d%e5%8e%86 aria-label="3.3.5 图的遍历">3.3.5 图的遍历</a></ul></ul><li><a href=#%e5%9b%9b-%e6%95%b0%e6%8d%ae%e8%bf%90%e7%ae%97 aria-label="四 数据运算">四 数据运算</a><ul><li><a href=#41-%e6%97%b6%e9%97%b4%e5%a4%8d%e6%9d%82%e5%ba%a6 aria-label="4.1 时间复杂度">4.1 时间复杂度</a><ul><li><a href=#411-o1 aria-label="4.1.1 \$O(1)\$">4.1.1 \$O(1)\$</a><li><a href=#412-on aria-label="4.1.2 \$O(n)\$">4.1.2 \$O(n)\$</a><li><a href=#413-on2 aria-label="4.1.3 \$O(n^2)\$">4.1.3 \$O(n^2)\$</a><li><a href=#414-log_2n aria-label="4.1.4 \$\log_2(n)\$">4.1.4 \$\log_2(n)\$</a></ul><li><a href=#42-%e6%9f%a5%e6%89%be%e7%ae%97%e6%b3%95 aria-label="4.2 查找算法">4.2 查找算法</a><ul><li><a href=#421-%e9%a1%ba%e5%ba%8f%e6%9f%a5%e6%89%be aria-label="4.2.1 顺序查找">4.2.1 顺序查找</a><li><a href=#422-%e4%ba%8c%e5%88%86%e6%9f%a5%e6%89%be aria-label="4.2.2 二分查找">4.2.2 二分查找</a><li><a href=#423-%e5%93%88%e5%b8%8c%e6%9f%a5%e6%89%be aria-label="4.2.3 哈希查找">4.2.3 哈希查找</a></ul><li><a href=#43-%e6%8e%92%e5%ba%8f%e7%ae%97%e6%b3%95 aria-label="4.3 排序算法">4.3 排序算法</a><ul><li><a href=#431-%e7%9b%b4%e6%8e%a5%e6%8f%92%e5%85%a5%e6%8e%92%e5%ba%8f aria-label="4.3.1 直接插入排序">4.3.1 直接插入排序</a><li><a href=#432-%e5%86%92%e6%b3%a1%e6%8e%92%e5%ba%8f aria-label="4.3.2 冒泡排序">4.3.2 冒泡排序</a><li><a href=#433-%e7%ae%80%e5%8d%95%e9%80%89%e6%8b%a9%e6%8e%92%e5%ba%8f aria-label="4.3.3 简单选择排序">4.3.3 简单选择排序</a><li><a href=#434-%e5%b8%8c%e5%b0%94%e6%8e%92%e5%ba%8f aria-label="4.3.4 希尔排序">4.3.4 希尔排序</a><li><a href=#435-%e5%bf%ab%e9%80%9f%e6%8e%92%e5%ba%8f aria-label="4.3.5 快速排序">4.3.5 快速排序</a><li><a href=#436-%e5%a0%86%e6%8e%92%e5%ba%8f aria-label="4.3.6 堆排序">4.3.6 堆排序</a><li><a href=#437-%e5%bd%92%e5%b9%b6%e6%8e%92%e5%ba%8f aria-label="4.3.7 归并排序">4.3.7 归并排序</a></ul></ul><li><a href=#%e7%9c%9f%e9%a2%98%e7%ad%94%e6%a1%88 aria-label=真题答案>真题答案</a></li></div></details></div></aside><script src=/js/pe-toc.min.333917f495161b4fe36496cfe98a86a7fd010d84fa024c7c85b4c42ed9cb2d2b.js integrity="sha256-MzkX9JUWG0/jZJbP6YqGp/0BDYT6Akx8hbTELtnLLSs="></script><div class=post-content><div class="pe-tip warning"><i class="icon fas fa-lightbulb fa-fw" aria-hidden=true></i>
本文最后更新于&nbsp;466&nbsp;天前，文中信息可能已经过时。如有问题请在评论区留言。</div><h2 id=一-章节知识架构图>一 章节知识架构图<a hidden class=anchor aria-hidden=true href=#一-章节知识架构图>#</a></h2><p><div class=pe-fancybox><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/tofuwine/tofuwine.github.io@repo/assets/8a2f64b6de1a3276ab78e7f592848aa6.webp><img src=https://cdn.jsdelivr.net/gh/tofuwine/tofuwine.github.io@repo/assets/8a2f64b6de1a3276ab78e7f592848aa6.webp#center alt=8a2f64b6de1a3276ab78e7f592848aa6 onerror='this.onerror=null,this.src="/placeholder.svg",this.className="pe-image-placeholder"'></a></div></p><h2 id=二-线性结构>二 线性结构<a hidden class=anchor aria-hidden=true href=#二-线性结构>#</a></h2><h3 id=21-线性表>2.1 线性表<a hidden class=anchor aria-hidden=true href=#21-线性表>#</a></h3><table><thead><tr><th>存储类型</th><th>特点</th></tr></thead><tbody><tr><td>顺序存储</td><td>可以随机存取表中元素。插入和删除操作需要移动元素。移动元素的期望值：插入元素 n/2 个；删除元素 (n-1)/2 个</td></tr><tr><td>链式存储</td><td>链式存储结构有单链表、循环链表（循环单链表、循环双链表）等，其中单链表只能从头结点开始往后顺序遍历整个链表，而循环单链表可以从表中的任一结点开始遍历整个链表</td></tr></tbody></table><p><div class=pe-fancybox><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/tofuwine/tofuwine.github.io@repo/assets/44b646adfa50327a69444b46da39ef74.webp><img src=https://cdn.jsdelivr.net/gh/tofuwine/tofuwine.github.io@repo/assets/44b646adfa50327a69444b46da39ef74.webp#center alt=44b646adfa50327a69444b46da39ef74 onerror='this.onerror=null,this.src="/placeholder.svg",this.className="pe-image-placeholder"'></a></div></p><p><strong>真题示例 - 2.1</strong></p><p>设有一个包含 n 个元素的有序线性表。在等概率情况下删除其中一个元素，若采用顺序存储结构，则平均需要移动（）个元素；若采用单链表存储，则平均需要移动（）个元素。</p><p>A. 1   B. (n-1)/2   C. Logn   D. n<br>A. 0   B. 1   C. (n-1)/2   D. n/2</p><h3 id=22-栈与队列>2.2 栈与队列<a hidden class=anchor aria-hidden=true href=#22-栈与队列>#</a></h3><p><div class=pe-fancybox><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/tofuwine/tofuwine.github.io@repo/assets/5393e0f12288cefa51b9b0005ef7d043.webp><img src=https://cdn.jsdelivr.net/gh/tofuwine/tofuwine.github.io@repo/assets/5393e0f12288cefa51b9b0005ef7d043.webp#center alt=5393e0f12288cefa51b9b0005ef7d043 onerror='this.onerror=null,this.src="/placeholder.svg",this.className="pe-image-placeholder"'></a></div></p><h4 id=221-栈>2.2.1 栈<a hidden class=anchor aria-hidden=true href=#221-栈>#</a></h4><p><font color=red>栈的应用：表达式求值、括号匹配、递归</font></p><p><strong>1）表达式求值</strong>：</p><p><div class=pe-fancybox><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/tofuwine/tofuwine.github.io@repo/assets/0a1350cbe6339c68c0b62f5c6c88b90f.webp><img src=https://cdn.jsdelivr.net/gh/tofuwine/tofuwine.github.io@repo/assets/0a1350cbe6339c68c0b62f5c6c88b90f.webp#center alt=0a1350cbe6339c68c0b62f5c6c88b90f onerror='this.onerror=null,this.src="/placeholder.svg",this.className="pe-image-placeholder"'></a></div></p><p><strong>2）括号匹配</strong>：()、[]、{}</p><ol><li>当扫描到左括号时，则将其压入栈中；</li><li>当扫描到右括号时，从栈顶取出一个左括号。</li><li>如果能匹配，比如<code>(</code>跟<code>)</code>匹配，<code>[</code>跟<code>]</code>匹配，<code>{</code>跟<code>}</code>匹配，则继续扫描剩下字符串。</li><li>如果扫描的过程中，遇到不能配对的右括号，或者栈中没有数据，则说明为非法格式。</li><li>当所有的括号都扫描完成之后，如果栈为空，则说明字符串为合法格式；否则说明有未匹配的左括号，为非法格式。</li></ol><p><strong>3）递归</strong>：</p><p>\$4!=4 \times 3! = 3 \times 2! = 2 \times 1! = 1 \times 0! = 1 \times 1\$</p><h5 id=2211-顺序存储结构>2.2.1.1 顺序存储结构<a hidden class=anchor aria-hidden=true href=#2211-顺序存储结构>#</a></h5><p>预先申请栈空间，栈满则元素不能入栈。</p><p><div class=pe-fancybox><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/tofuwine/tofuwine.github.io@repo/assets/be823690a1ddfc7895deb138f3e566b9.webp><img src=https://cdn.jsdelivr.net/gh/tofuwine/tofuwine.github.io@repo/assets/be823690a1ddfc7895deb138f3e566b9.webp#center alt=be823690a1ddfc7895deb138f3e566b9 onerror='this.onerror=null,this.src="/placeholder.svg",this.className="pe-image-placeholder"'></a></div></p><h5 id=2212-链式存储结构>2.2.1.2 链式存储结构<a hidden class=anchor aria-hidden=true href=#2212-链式存储结构>#</a></h5><p>用链表表示栈，用链表实现的栈称为链栈。由于栈中元素的插入和删除仅在栈顶一端进行，因此不必另外设置头指针，链表的头指针就是栈顶指针。</p><p><div class=pe-fancybox><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/tofuwine/tofuwine.github.io@repo/assets/1ace6e02ade9c9f32c1bd7dc88b0be66.webp><img src=https://cdn.jsdelivr.net/gh/tofuwine/tofuwine.github.io@repo/assets/1ace6e02ade9c9f32c1bd7dc88b0be66.webp#center alt=1ace6e02ade9c9f32c1bd7dc88b0be66 onerror='this.onerror=null,this.src="/placeholder.svg",this.className="pe-image-placeholder"'></a></div></p><p><strong>真题示例 - 2.2</strong></p><p>栈的特点是后进先出，若用单链表作为栈的存储结构，并用头指针作为栈顶指针，则（）。</p><p>A. 入栈和出栈操作都不需要遍历链表<br>B. 入栈和出栈操作都需要遍历链表<br>C. 入栈操作需要遍历链表而出栈操作不需要<br>D. 入栈操作不需要遍历链表而出栈操作需要</p><h4 id=222-队列>2.2.2 队列<a hidden class=anchor aria-hidden=true href=#222-队列>#</a></h4><p><font color=red>队列的应用：打印队列</font>。</p><h5 id=2221-顺序存储>2.2.2.1 顺序存储<a hidden class=anchor aria-hidden=true href=#2221-顺序存储>#</a></h5><p>用顺序存储线性表来表示队列，为了指明当前执行出队运算的队首位置，需要一个指针变量 head（称为头指针）。为了指明当前执行进队运算的队尾位置，也需要一个指针变量 tail（称为尾指针）。</p><p><div class=pe-fancybox><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/tofuwine/tofuwine.github.io@repo/assets/f935b0564e21769cf9abc6b4f898ce4e.webp><img src=https://cdn.jsdelivr.net/gh/tofuwine/tofuwine.github.io@repo/assets/f935b0564e21769cf9abc6b4f898ce4e.webp#center alt=f935b0564e21769cf9abc6b4f898ce4e onerror='this.onerror=null,this.src="/placeholder.svg",this.className="pe-image-placeholder"'></a></div></p><p><font color=red><strong>缺点：会造成空间的浪费</strong></font>。</p><h5 id=2222-链式存储>2.2.2.2 链式存储<a hidden class=anchor aria-hidden=true href=#2222-链式存储>#</a></h5><p>用链接存储线性表来实现队列，用链表实现的队列称为链接队列。</p><p><div class=pe-fancybox><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/tofuwine/tofuwine.github.io@repo/assets/7ebb1d6e991046766da1d14cecd69d72.webp><img src=https://cdn.jsdelivr.net/gh/tofuwine/tofuwine.github.io@repo/assets/7ebb1d6e991046766da1d14cecd69d72.webp#center alt=7ebb1d6e991046766da1d14cecd69d72 onerror='this.onerror=null,this.src="/placeholder.svg",this.className="pe-image-placeholder"'></a></div></p><h5 id=2223-循环队列>2.2.2.3 循环队列<a hidden class=anchor aria-hidden=true href=#2223-循环队列>#</a></h5><p>循环队列解决顺序存储造成空间浪费的缺点。但是会存在无法判断空队列与队列满的情况（因为此时 front 和 rear 指针都指向相同位置）。解决办法：牺牲一个元素空间，空队列时 front = rear，队列满时 front = rear + 1.</p><p><div class=pe-fancybox><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/tofuwine/tofuwine.github.io@repo/assets/8d234a09fc8cb66ac204a4541df046c1.webp><img src=https://cdn.jsdelivr.net/gh/tofuwine/tofuwine.github.io@repo/assets/8d234a09fc8cb66ac204a4541df046c1.webp#center alt=8d234a09fc8cb66ac204a4541df046c1 onerror='this.onerror=null,this.src="/placeholder.svg",this.className="pe-image-placeholder"'></a></div></p><p><strong>真题示例 - 2.3</strong></p><p>某循环队列 Q 的定义中用 front 和 rear 两个整型域变量表示队列状态，其中 front 指示队头元素的位置，rear 指示队尾元素之后的位置（如下图所示，front 的值为 5、rear 的值为 1）。若队列容量 M （下面图中 M = 6），则计算队列长度的通式为（）。</p><p><div class=pe-fancybox><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/tofuwine/tofuwine.github.io@repo/assets/8b6107dfe6ce070afa9ec2b892915447.webp><img src=https://cdn.jsdelivr.net/gh/tofuwine/tofuwine.github.io@repo/assets/8b6107dfe6ce070afa9ec2b892915447.webp#center alt=8b6107dfe6ce070afa9ec2b892915447 onerror='this.onerror=null,this.src="/placeholder.svg",this.className="pe-image-placeholder"'></a></div></p><p>A. \$\bf (Q.front - Q.rear)\$<br>B. \$\bf (Q.front - Q.rear + M) \% M\$<br>C. \$\bf (Q.rear - Q.front)\$<br>D. \$\bf (Q.rear - Q.front + M) \% M\$</p><p><strong>真题示例 - 2.4</strong></p><p>对于一个长度为 n(n>1) 且元素互异的序列，令其所有元素依次通过一个初始为空的栈后，再通过一个初始为空的队列。假设队列和栈的容量都足够大，且只要栈非空就可以进行出栈操作，只要队列非空就可以进行出队操作，那么一下叙述中，正确的是（）。</p><p>A. 出队序列和出栈序列一定互为逆序<br>B. 出队序列和出栈序列一定相同<br>C. 入栈序列和入队序列一定相同<br>D. 入栈序列与入队序列一定互为逆序</p><h5 id=2224-双端队列>2.2.2.4 双端队列<a hidden class=anchor aria-hidden=true href=#2224-双端队列>#</a></h5><p>某双端队列如下图所示，要求元素进出队列必须在同一端口，即从 A 端进入的元素必须从 A 端出、从 B 端进入的元素必须从 B 端出。</p><p><div class=pe-fancybox><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/tofuwine/tofuwine.github.io@repo/assets/1beb9379bcac338f8df7c91424510768.webp><img src=https://cdn.jsdelivr.net/gh/tofuwine/tofuwine.github.io@repo/assets/1beb9379bcac338f8df7c91424510768.webp#center alt=双端队列 onerror='this.onerror=null,this.src="/placeholder.svg",this.className="pe-image-placeholder"'></a></div></p><p><strong>真题示例 - 2.5</strong></p><p>双端队列是指在队列的两个端口都可以加入和删除元素，如下图所示，现在要求元素进队列和出队列必须在同一端口。即从 a 端进队的元素必须从 a 端出，从 b 端进队的元素必须从 b 端出。则对于四个元素的序列 a、b、c、d，若要求前两个元素 a、b 从 a 端口按次序全部进入队列。后两个元素 c、d 从 b 端口按次序全部进入队列，则不可能得到的出队序列是（）。</p><p><div class=pe-fancybox><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/tofuwine/tofuwine.github.io@repo/assets/1beb9379bcac338f8df7c91424510768.webp><img src=https://cdn.jsdelivr.net/gh/tofuwine/tofuwine.github.io@repo/assets/1beb9379bcac338f8df7c91424510768.webp#center alt=双端队列 onerror='this.onerror=null,this.src="/placeholder.svg",this.className="pe-image-placeholder"'></a></div></p><p>A. d、a、b、c<br>B. d、c、b、a<br>C. b、a、d、c<br>D. b、d、c、a</p><h3 id=23-串>2.3 串<a hidden class=anchor aria-hidden=true href=#23-串>#</a></h3><p>串是仅由字符构成的有限序列，是一种线性表。一般记为 \$s='a1a2 \cdots an'(n>0)\$，其中 s 是串的名称，用单引号括起来的是字符序列是串值。串的基本概念：</p><ol><li>空串：长度为零的串称为空串，空串不包含任何字符。</li><li>空格串：由一个或多个空格组成的串</li><li>子串：由串种任意长度的连续字符构成的序列称为子串。含有子串的串称为主串。空串是任意串的子串。</li></ol><p><strong>真题示例 - 2.6</strong></p><p>设 S 是一个长度为 n 的非空字符串，其中的字符各不相同，则其互异的非平凡子串（非空且不同于 S 本身）个数为（）。</p><p>A. \$2n-1\$   B. \$n^2\$   C. \$n(n+1)/2\$   D. \$(n+2)(n-1)/2\$</p><h2 id=三-非线性结构>三 非线性结构<a hidden class=anchor aria-hidden=true href=#三-非线性结构>#</a></h2><h3 id=31-二维数组>3.1 二维数组<a hidden class=anchor aria-hidden=true href=#31-二维数组>#</a></h3>$$
A_{m \times n}=
\left[
\begin{matrix}
a_{11} & a_{12} & a_{13} & \cdots & a_{1n} \\
a_{21} & a_{22} & a_{23} & \cdots & a_{2n} \\
\vdots & \vdots & \vdots & \ddots & \vdots \\
a_{m1} & a_{m2} & a_{m3} & \cdots & a_{mn}
\end{matrix}
\right]
$$<p>按行存储：</p>$$A_{m,n}=\big[[a_{11}a_{12} \cdots a_{1n}],[a_{21}a_{22} \cdots a_{2n}], \cdots,[a_{m1}a_{m2} \cdots a_{mn}]\big]$$<p>按列存储：</p>$$A_{m,n}=\big[[a_{11}a_{21} \cdots a_{m1}],[a_{12}a_{22} \cdots a_{m2}], \cdots,[a_{1n}a_{2n} \cdots a_{mn}]\big]$$<p><strong>真题示例 - 3.1</strong></p><p>某 n 阶矩阵 A 如下图所示，按行将元素存储在一堆数组 M 中，设 \$a_{1,1}\$ 存储在 M[1]，那么 \$a_{i,j}\$(1 &lt;= i, j &lt;= n且 \$a_{i,j}\$ 位于三条对角线中），存储在 M（）。</p><p><div class=pe-fancybox><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/tofuwine/tofuwine.github.io@repo/assets/9757237f1eb73b38b4c4fbd04df0b46f.webp><img src=https://cdn.jsdelivr.net/gh/tofuwine/tofuwine.github.io@repo/assets/9757237f1eb73b38b4c4fbd04df0b46f.webp#center alt=9757237f1eb73b38b4c4fbd04df0b46f onerror='this.onerror=null,this.src="/placeholder.svg",this.className="pe-image-placeholder"'></a></div></p><p>A. \$i+2j\$   B. \$2i+j\$   C. \$i+2j-2\$   D. \$2i+j-2\$</p><h3 id=32-树>3.2 树<a hidden class=anchor aria-hidden=true href=#32-树>#</a></h3><p><mark>考试只考二叉树</mark></p><ol><li>父亲、孩子和兄弟</li><li>结点的度</li><li>叶子结点</li><li>内部结点</li><li>层次</li><li>树的高度</li></ol><p><div class=pe-fancybox><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/tofuwine/tofuwine.github.io@repo/assets/494d3f1218fa8df6993260330325d8ea.webp><img src=https://cdn.jsdelivr.net/gh/tofuwine/tofuwine.github.io@repo/assets/494d3f1218fa8df6993260330325d8ea.webp#center alt=494d3f1218fa8df6993260330325d8ea onerror='this.onerror=null,this.src="/placeholder.svg",this.className="pe-image-placeholder"'></a></div></p><p>树的三种形式：</p><p><div class=pe-fancybox><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/tofuwine/tofuwine.github.io@repo/assets/129361e0ee437fa6b1fbe1afe3e0be1f.webp><img src=https://cdn.jsdelivr.net/gh/tofuwine/tofuwine.github.io@repo/assets/129361e0ee437fa6b1fbe1afe3e0be1f.webp#center alt=129361e0ee437fa6b1fbe1afe3e0be1f onerror='this.onerror=null,this.src="/placeholder.svg",this.className="pe-image-placeholder"'></a></div></p><h4 id=321-二叉树>3.2.1 二叉树<a hidden class=anchor aria-hidden=true href=#321-二叉树>#</a></h4><ol><li>在二叉树的第 i 层最多有 \$2^{i-1}\$ 个结点（\$i \geq 1\$）</li><li>深度为 k 的二叉树最多有 \$2^k-1\$ 个结点（\$k \geq 1\$）</li><li>对于任何一棵二叉树，如果其叶子结点数为 \$N_0\$，度为 2 的结点数为 \$N_2\$，则 \$N_0=N_2+1\$</li><li>具有 n 个结点的完全二叉树的深度为 \$\lfloor \log_2n \rfloor +1\$<br>如果 \$i=1\$，则结点 \$i\$ 无父结点，是二叉树的根<br>如果 \$i>1\$，则父结点是 \$\lfloor i/2 \rfloor\$<br>如果 \$2i>n\$，则结点 \$i\$ 为叶子结点，无左子结点，否则其左子结点是 \$2i\$<br>如果 \$2i+1>n\$，则结点 \$i\$ 无右子结点，否则，其右子结点是 \$2i+1\$</li></ol><h4 id=322-二叉树的遍历>3.2.2 二叉树的遍历<a hidden class=anchor aria-hidden=true href=#322-二叉树的遍历>#</a></h4><p><div class=pe-fancybox><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/tofuwine/tofuwine.github.io@repo/assets/ba42abb446a686b2b27c8f0933749b7d.webp><img src=https://cdn.jsdelivr.net/gh/tofuwine/tofuwine.github.io@repo/assets/ba42abb446a686b2b27c8f0933749b7d.webp#center alt=ba42abb446a686b2b27c8f0933749b7d onerror='this.onerror=null,this.src="/placeholder.svg",this.className="pe-image-placeholder"'></a></div></p><table><thead><tr><th>遍历方式</th><th>结果</th></tr></thead><tbody><tr><td>层次遍历</td><td>1、2、3、4、5、6、7、8</td></tr><tr><td>前序遍历<br>（根、左、右）</td><td>1、2、4、5、7、8、3、6</td></tr><tr><td>中序遍历<br>（左、根、右）</td><td>4、2、7、8、5、1、3、6</td></tr><tr><td>后序遍历<br>（左、右、根）</td><td>4、8、7、5、2、6、3、1</td></tr></tbody></table><p><strong>真题示例 - 3.2</strong></p><p>某二叉树的中序，先序遍历序列分别为 {20，30，10，50，40}，{10，20，30，40，50} 则该二叉树的后序遍历序列为（）。</p><p>A. 50，40，30，20，10<br>B. 30，20，10，50，40<br>C. 30，20，50，40，10<br>D. 20，30，10，40，50</p><p><strong>真题示例 - 3.3</strong></p><p>二叉树的高度是指其层数，空二叉树的高度为 0，仅有根结点的二叉树高度为 1。若某二叉树中共有 1024 个结点，则该二叉树的高度是整数区间的（）中的任一值。</p><p>A. (10, 1024)   B. [10, 1024]<br>C. (11, 1024)   B. [11, 1024]</p><h4 id=323-二叉树的存储>3.2.3 二叉树的存储<a hidden class=anchor aria-hidden=true href=#323-二叉树的存储>#</a></h4><h5 id=3231-顺序存储>3.2.3.1 顺序存储<a hidden class=anchor aria-hidden=true href=#3231-顺序存储>#</a></h5><p><div class=pe-fancybox><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/tofuwine/tofuwine.github.io@repo/assets/4e8598bb9e50e28e9f386ce9e679bdc2.webp><img src=https://cdn.jsdelivr.net/gh/tofuwine/tofuwine.github.io@repo/assets/4e8598bb9e50e28e9f386ce9e679bdc2.webp#center alt=4e8598bb9e50e28e9f386ce9e679bdc2 onerror='this.onerror=null,this.src="/placeholder.svg",this.className="pe-image-placeholder"'></a></div></p><p><strong>真题示例 - 3.4</strong></p><p>对下面的二叉树进行顺序存储（用数组 MEM 表示），已知结点 A、B、C 在 MEM 中对应元素的下标分别为 1、2、3，那么结点 D、E、F 对应的数组元素下标为（）。</p><p><div class=pe-fancybox><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/tofuwine/tofuwine.github.io@repo/assets/a87ffe738cf73ea4097c8ddc11465cb6.webp><img src=https://cdn.jsdelivr.net/gh/tofuwine/tofuwine.github.io@repo/assets/a87ffe738cf73ea4097c8ddc11465cb6.webp#center alt=a87ffe738cf73ea4097c8ddc11465cb6 onerror='this.onerror=null,this.src="/placeholder.svg",this.className="pe-image-placeholder"'></a></div></p><p>A. 4、5、6   B. 4、7、10   C. 6、7、8   D. 6、7、14</p><h5 id=3232-链式存储>3.2.3.2 链式存储<a hidden class=anchor aria-hidden=true href=#3232-链式存储>#</a></h5><p><div class=pe-fancybox><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/tofuwine/tofuwine.github.io@repo/assets/ce4bf18b0b8fca63737ba291e1586b32.webp><img src=https://cdn.jsdelivr.net/gh/tofuwine/tofuwine.github.io@repo/assets/ce4bf18b0b8fca63737ba291e1586b32.webp#center alt=ce4bf18b0b8fca63737ba291e1586b32 onerror='this.onerror=null,this.src="/placeholder.svg",this.className="pe-image-placeholder"'></a></div></p><h4 id=324-二叉查找树>3.2.4 二叉查找树<a hidden class=anchor aria-hidden=true href=#324-二叉查找树>#</a></h4><p>二叉排序树又称为二叉查找树，其定义为二叉排序树或者是一棵空二叉树，或者是具有如下性质的二叉树：<br>（1）若它的左子树非空，则左子树上所有结点的值均小于根结点。<br>（2）若它的右子树非空，则右子树上所有结点的值均大于根结点。<br>（3）左、右子树本身右各是一个二叉排序树。</p><p><div class=pe-fancybox><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/tofuwine/tofuwine.github.io@repo/assets/c084915defa18c060206e0d1433119cf.webp><img src=https://cdn.jsdelivr.net/gh/tofuwine/tofuwine.github.io@repo/assets/c084915defa18c060206e0d1433119cf.webp#center alt=c084915defa18c060206e0d1433119cf onerror='this.onerror=null,this.src="/placeholder.svg",this.className="pe-image-placeholder"'></a></div></p><p>如果中序遍历二叉排序树，就能得到一个排好序的结点序列。</p><h4 id=325-哈夫曼树>3.2.5 哈夫曼树<a hidden class=anchor aria-hidden=true href=#325-哈夫曼树>#</a></h4><p>给定 N 个权值作为 N 个叶子结点，构造一棵二叉树，若该树的带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树（Huffman Tree）。哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近。</p><p><div class=pe-fancybox><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/tofuwine/tofuwine.github.io@repo/assets/6d41861e9599a757f3faf62796acbb66.webp><img src=https://cdn.jsdelivr.net/gh/tofuwine/tofuwine.github.io@repo/assets/6d41861e9599a757f3faf62796acbb66.webp#center alt=6d41861e9599a757f3faf62796acbb66 onerror='this.onerror=null,this.src="/placeholder.svg",this.className="pe-image-placeholder"'></a></div></p><p><strong>真题示例 - 3.5</strong></p><p>已知一个文件中出现的各字符及其对应的频率如下表所示。采用 Huffman 编码，则该文件中字符 a 和 c 的码长分别为（）。若采用 Huffman 编码，则字符序列 110001001101 的编码应为（）。</p><table><thead><tr><th>字符</th><th>a</th><th>b</th><th>c</th><th>d</th><th>e</th><th>f</th></tr></thead><tbody><tr><td>频率 (%)</td><td>45</td><td>13</td><td>12</td><td>16</td><td>9</td><td>5</td></tr></tbody></table><p>A. 1 和 3   B. 1 和 4   C. 3 和 3   D. 3 和 4<br>A. face   B. bace   C. acde   D. fade</p><h3 id=33-图>3.3 图<a hidden class=anchor aria-hidden=true href=#33-图>#</a></h3><p>图 G 由两个集合 V 和 E 组成，记为 \$G = (V,E)\$，其中 V 是顶点的有穷非空集合，E 是 V 中顶点偶对（称为边）的有穷集合。通常，也将图 G 的顶点集和边集分别记为 V(G) 和 E(G)。E(G) 可以是空集。若 E(G) 为空，则图 G 只有顶点而没有边。</p><p><div class=pe-fancybox><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/tofuwine/tofuwine.github.io@repo/assets/c060fcdf13e840aca068554c453b0f10.webp><img src=https://cdn.jsdelivr.net/gh/tofuwine/tofuwine.github.io@repo/assets/c060fcdf13e840aca068554c453b0f10.webp#center alt=c060fcdf13e840aca068554c453b0f10 onerror='this.onerror=null,this.src="/placeholder.svg",this.className="pe-image-placeholder"'></a></div></p><h4 id=331-完全图>3.3.1 完全图<a hidden class=anchor aria-hidden=true href=#331-完全图>#</a></h4><p>若一个无向图具有 n 个顶点，而每个顶点与其他 n-1 个顶点之间都有边，则称为<font color=red>无向完全图</font>。无向完全图共有 \$\bf \frac{n(n-1)}{2}\$ 条边。</p><p><div class=pe-fancybox><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/tofuwine/tofuwine.github.io@repo/assets/a9c69c435898342766e02bb7751231e4.webp><img src=https://cdn.jsdelivr.net/gh/tofuwine/tofuwine.github.io@repo/assets/a9c69c435898342766e02bb7751231e4.webp#center alt=a9c69c435898342766e02bb7751231e4 onerror='this.onerror=null,this.src="/placeholder.svg",this.className="pe-image-placeholder"'></a></div></p><p>有 n 个顶点的<font color=red>有向完全图</font>中弧的数目为 \$n(n-1)\$，即任意两个不同顶点之间都有方向相反的两个弧存在。</p><p><div class=pe-fancybox><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/tofuwine/tofuwine.github.io@repo/assets/5ac92b0bb1cc3a8df417910a7a80f4e7.webp><img src=https://cdn.jsdelivr.net/gh/tofuwine/tofuwine.github.io@repo/assets/5ac92b0bb1cc3a8df417910a7a80f4e7.webp#center alt=5ac92b0bb1cc3a8df417910a7a80f4e7 onerror='this.onerror=null,this.src="/placeholder.svg",this.className="pe-image-placeholder"'></a></div></p><h4 id=332-连通图>3.3.2 连通图<a hidden class=anchor aria-hidden=true href=#332-连通图>#</a></h4><p>在无向图 G 中，若从顶点 \$V_i\$ 到顶点 \$V_j\$ 有路径，则称顶点 \$V_i\$ 和顶点 \$V_j\$ 是连通的。如果无向图 G 中任意两个顶点都是连通的，则称其为连通图。</p><p><div class=pe-fancybox><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/tofuwine/tofuwine.github.io@repo/assets/bde0483f6583d867acd7b93d69d3fc27.webp><img src=https://cdn.jsdelivr.net/gh/tofuwine/tofuwine.github.io@repo/assets/bde0483f6583d867acd7b93d69d3fc27.webp#center alt=bde0483f6583d867acd7b93d69d3fc27 onerror='this.onerror=null,this.src="/placeholder.svg",this.className="pe-image-placeholder"'></a></div></p><h4 id=333-强连通图>3.3.3 强连通图<a hidden class=anchor aria-hidden=true href=#333-强连通图>#</a></h4><p>有向图中，若任意两个顶点 \$V_i\$ 和 \$V_j\$，满足从 \$V_i\$ 到 \$V_j\$ 以及从 \$V_j\$ 到 \$V_i\$ 都连通，也就是都含有至少一条通路，则称为强连通图。有向图中的极大连通图子图称为有向图的强连通分量。</p><p><div class=pe-fancybox><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/tofuwine/tofuwine.github.io@repo/assets/9edd1e07a14cc6ebe97b99eb3611d611.webp><img src=https://cdn.jsdelivr.net/gh/tofuwine/tofuwine.github.io@repo/assets/9edd1e07a14cc6ebe97b99eb3611d611.webp#center alt=9edd1e07a14cc6ebe97b99eb3611d611 onerror='this.onerror=null,this.src="/placeholder.svg",this.className="pe-image-placeholder"'></a></div></p><h4 id=334-图的存储结构>3.3.4 图的存储结构<a hidden class=anchor aria-hidden=true href=#334-图的存储结构>#</a></h4><h5 id=3341-邻接矩阵>3.3.4.1 邻接矩阵<a hidden class=anchor aria-hidden=true href=#3341-邻接矩阵>#</a></h5><p>有向图的邻接矩阵<font color=red>不一定对称</font>。</p><p><div class=pe-fancybox><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/tofuwine/tofuwine.github.io@repo/assets/eec61811fe6ea8adaed4ce4658105cb9.webp><img src=https://cdn.jsdelivr.net/gh/tofuwine/tofuwine.github.io@repo/assets/eec61811fe6ea8adaed4ce4658105cb9.webp#center alt=eec61811fe6ea8adaed4ce4658105cb9 onerror='this.onerror=null,this.src="/placeholder.svg",this.className="pe-image-placeholder"'></a></div></p><p>无向图的邻接矩阵是<font color=red>对称</font>的。</p><p><div class=pe-fancybox><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/tofuwine/tofuwine.github.io@repo/assets/d9ec5b54bad1b7cbfaf5ecb2dda97273.webp><img src=https://cdn.jsdelivr.net/gh/tofuwine/tofuwine.github.io@repo/assets/d9ec5b54bad1b7cbfaf5ecb2dda97273.webp#center alt=d9ec5b54bad1b7cbfaf5ecb2dda97273 onerror='this.onerror=null,this.src="/placeholder.svg",this.className="pe-image-placeholder"'></a></div></p><h5 id=3342-邻接表>3.3.4.2 邻接表<a hidden class=anchor aria-hidden=true href=#3342-邻接表>#</a></h5><p>在图的邻接表中，为图的每个顶点建立一个链表，且第 i 个链表中的结点代表与顶点 i 相关联的一条边或由顶点 i 出发的一条弧。有 n 个顶点的图，需要用 n 个链表表示，这 n 个链表的头指针通常由顺序线性表存储。</p><p><div class=pe-fancybox><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/tofuwine/tofuwine.github.io@repo/assets/9905beaad3b456f524642163feb18d09.webp><img src=https://cdn.jsdelivr.net/gh/tofuwine/tofuwine.github.io@repo/assets/9905beaad3b456f524642163feb18d09.webp#center alt=9905beaad3b456f524642163feb18d09 onerror='this.onerror=null,this.src="/placeholder.svg",this.className="pe-image-placeholder"'></a></div></p><h4 id=335-图的遍历>3.3.5 图的遍历<a hidden class=anchor aria-hidden=true href=#335-图的遍历>#</a></h4><p>图的遍历是指从某个顶点出发，沿着某条搜索路径对图中的所有顶点进行访问且只访问一次的过程。</p><p><div class=pe-fancybox><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/tofuwine/tofuwine.github.io@repo/assets/f5dc1a8a383ffa02a6c75d387ec9f806.webp><img src=https://cdn.jsdelivr.net/gh/tofuwine/tofuwine.github.io@repo/assets/f5dc1a8a383ffa02a6c75d387ec9f806.webp#center alt=f5dc1a8a383ffa02a6c75d387ec9f806 onerror='this.onerror=null,this.src="/placeholder.svg",this.className="pe-image-placeholder"'></a></div></p><table><thead><tr><th>方法</th><th>示例</th><th>特征</th></tr></thead><tbody><tr><td>深度优先 DFS</td><td>V1,V2<br>V4,V8<br>V5,V3<br>V6,V7</td><td>相当于树的前序遍历。邻接矩阵表示的时间复杂度 \$O(n^2)\$，邻接表表示的实际复杂度是 \$O(n+e)\$</td></tr><tr><td>广度优先 BFS</td><td>V1,V2<br>V3,V4<br>V5,V6<br>V7,V8</td><td>相当于树的层次遍历。时间复杂度同上</td></tr></tbody></table><p><strong>真题示例 - 3.6</strong></p><p>图 G 的邻接矩阵如下图所示（顶点依次表示为 v0, v1, v2, v3, v4, v5），G 是（）。对 G 进行广度优先遍历（从 v0 开始），可能的遍历序列为（）。</p>$$
\left[
\begin{matrix}
\infty & 18 & 17 & \infty & \infty & \infty \\
\infty & \infty & \infty & 20 & 16 & \infty \\
\infty & 19 & \infty & 23 & \infty & \infty \\
\infty & \infty & \infty & \infty & \infty & 15 \\
\infty & \infty & \infty & \infty & \infty & 12 \\
\infty & \infty & \infty & \infty & \infty & \infty \\
\end{matrix}
\right]
$$<p>A. 无向图   B. 有向图   C. 完全图   D. 强连通图</p><p>A. v0、v1、v2、v3、v4、v5<br>B. v0、v2、v4、v5、v1、v3<br>C. v0、v1、v3、v5、v2、v4<br>D. v0、v2、v4、v3、v5、v1</p><p><strong>真题示例 - 3.7</strong></p><p>对于如下所示的有向图，其邻接矩阵是一个（）的矩阵，采用邻接链表存储时顶点的表结点个数为 2，顶点 5 的表结点个数为 0，顶点 2 和 3 的表结点个数分别为（）。</p><p><div class=pe-fancybox><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/tofuwine/tofuwine.github.io@repo/assets/55fc20ab71e888e51990c27387d60e8e.webp><img src=https://cdn.jsdelivr.net/gh/tofuwine/tofuwine.github.io@repo/assets/55fc20ab71e888e51990c27387d60e8e.webp#center alt=55fc20ab71e888e51990c27387d60e8e onerror='this.onerror=null,this.src="/placeholder.svg",this.className="pe-image-placeholder"'></a></div></p><p>A. 5*5   B. 5*7   C. 7*5   D. 7*7<br>A. 2.1   B. 2.2   C. 3.4   D. 4.3</p><h2 id=四-数据运算>四 数据运算<a hidden class=anchor aria-hidden=true href=#四-数据运算>#</a></h2><h3 id=41-时间复杂度>4.1 时间复杂度<a hidden class=anchor aria-hidden=true href=#41-时间复杂度>#</a></h3><h4 id=411-o1>4.1.1 \$O(1)\$<a hidden class=anchor aria-hidden=true href=#411-o1>#</a></h4><div class="pe-code-block-wrap pe-code-details open"><div class="pe-code-block-header pe-code-details-summary"><div class=pe-code-block-header-left><i class="arrow fas fa-chevron-right fa-fw pe-icon" aria-hidden=true></i>
<span>c</span></div><div class=pe-code-block-header-center><span></span></div><div class=pe-code-block-header-right><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i>
<button class=pe-code-copy-button><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" class="pe-icon"><path fill-rule="evenodd" clip-rule="evenodd" d="M12 3.5c-1.1046.0-2 .89543-2 2h4c0-1.10457-.8954-2-2-2zm-3.46487.0C9.22675 2.3044 10.5194 1.5 12 1.5s2.7733.8044 3.4649 2H17.25c1.6569.0 3 1.34315 3 3v12c0 1.6569-1.0931 3-3 3H6.75c-1.65685.0-3-1.3431-3-3V6.5c0-1.65685 1.34315-3 3-3H8.53513zM8 5.5H6.75c-.55228.0-1 .44772-1 1v12c0 .552299999999999.44772 1 1 1h10.5C18.0523 19.5 18.25 19.0523 18.25 18.5V6.5c0-.55228-.447700000000001-1-1-1H16c0 1.10457-.8954 2-2 2H10c-1.10457.0-2-.89543-2-2z" fill="currentcolor"/></svg></button></div></div><div class=pe-code-details-content><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>Temp</span><span class=o>=</span><span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>i</span><span class=o>=</span><span class=n>j</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>j</span><span class=o>=</span><span class=n>temp</span><span class=p>;</span></span></span></code></pre></td></tr></table></div></div></div></div><p>以上三条单个语句的频度均为 1，是一个常数阶，记作 \$T(n)=O(1)\$。此算法的执行时间不随着问题规模 n 的增加而增长，即使算法中有上千条语句，其执行时间也不过是一个较大的常数。此算法的时间复杂度是 \$O(1)\$。</p><h4 id=412-on>4.1.2 \$O(n)\$<a hidden class=anchor aria-hidden=true href=#412-on>#</a></h4><div class="pe-code-block-wrap pe-code-details open"><div class="pe-code-block-header pe-code-details-summary"><div class=pe-code-block-header-left><i class="arrow fas fa-chevron-right fa-fw pe-icon" aria-hidden=true></i>
<span>c</span></div><div class=pe-code-block-header-center><span></span></div><div class=pe-code-block-header-right><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i>
<button class=pe-code-copy-button><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" class="pe-icon"><path fill-rule="evenodd" clip-rule="evenodd" d="M12 3.5c-1.1046.0-2 .89543-2 2h4c0-1.10457-.8954-2-2-2zm-3.46487.0C9.22675 2.3044 10.5194 1.5 12 1.5s2.7733.8044 3.4649 2H17.25c1.6569.0 3 1.34315 3 3v12c0 1.6569-1.0931 3-3 3H6.75c-1.65685.0-3-1.3431-3-3V6.5c0-1.65685 1.34315-3 3-3H8.53513zM8 5.5H6.75c-.55228.0-1 .44772-1 1v12c0 .552299999999999.44772 1 1 1h10.5C18.0523 19.5 18.25 19.0523 18.25 18.5V6.5c0-.55228-.447700000000001-1-1-1H16c0 1.10457-.8954 2-2 2H10c-1.10457.0-2-.89543-2-2z" fill="currentcolor"/></svg></button></div></div><div class=pe-code-details-content><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=n>sum</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>n</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>sum</span> <span class=o>+=</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div></div></div><p>一共算了 n 次加法，那么就说这个时间复杂度是 \$O(n)\$。比如，某个计算共计算了 \$2n+1\$ 次，那么这个时间复杂度也是 \$O(n)\$</p><h4 id=413-on2>4.1.3 \$O(n^2)\$<a hidden class=anchor aria-hidden=true href=#413-on2>#</a></h4><div class="pe-code-block-wrap pe-code-details open"><div class="pe-code-block-header pe-code-details-summary"><div class=pe-code-block-header-left><i class="arrow fas fa-chevron-right fa-fw pe-icon" aria-hidden=true></i>
<span>c</span></div><div class=pe-code-block-header-center><span></span></div><div class=pe-code-block-header-right><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i>
<button class=pe-code-copy-button><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" class="pe-icon"><path fill-rule="evenodd" clip-rule="evenodd" d="M12 3.5c-1.1046.0-2 .89543-2 2h4c0-1.10457-.8954-2-2-2zm-3.46487.0C9.22675 2.3044 10.5194 1.5 12 1.5s2.7733.8044 3.4649 2H17.25c1.6569.0 3 1.34315 3 3v12c0 1.6569-1.0931 3-3 3H6.75c-1.65685.0-3-1.3431-3-3V6.5c0-1.65685 1.34315-3 3-3H8.53513zM8 5.5H6.75c-.55228.0-1 .44772-1 1v12c0 .552299999999999.44772 1 1 1h10.5C18.0523 19.5 18.25 19.0523 18.25 18.5V6.5c0-.55228-.447700000000001-1-1-1H16c0 1.10457-.8954 2-2 2H10c-1.10457.0-2-.89543-2-2z" fill="currentcolor"/></svg></button></div></div><div class=pe-code-details-content><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=n>sum</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>n</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> 
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>j</span> <span class=o>&lt;=</span> <span class=n>n</span><span class=p>;</span> <span class=o>++</span><span class=n>j</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>sum</span> <span class=o>+=</span> <span class=p>(</span><span class=n>i</span> <span class=o>+</span> <span class=n>j</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div></div></div><h4 id=414-log_2n>4.1.4 \$\log_2(n)\$<a hidden class=anchor aria-hidden=true href=#414-log_2n>#</a></h4><p>二分查找每次排除掉一半不适合值，所以对于 n 个元素的情况：</p><ul><li>一次二分剩下：\$n/2\$</li><li>两次二分剩下：\$n/2/2 = n/4\$</li><li>三次二分剩下：\$n/4/2 = n/8\$</li><li>m 次二分剩下：\$n/(2^m)\$</li></ul><p>在最坏情况下是在排除到只剩下最后一个值之后得到结果，所以为 \$\frac{n}{(2^m)}=1 \Rightarrow n=2^m\$，所以时间复杂度为 \$\log_2(n)\$</p><h3 id=42-查找算法>4.2 查找算法<a hidden class=anchor aria-hidden=true href=#42-查找算法>#</a></h3><h4 id=421-顺序查找>4.2.1 顺序查找<a hidden class=anchor aria-hidden=true href=#421-顺序查找>#</a></h4><p>将待查的元素从头到尾与表中元素进行比较，如果存在，则返回成功；否则，查找失败。此方法效率不高，平均查找长度 \$\textcolor{red}{(n+1)/2}\$（设置监视哨）</p><h4 id=422-二分查找>4.2.2 二分查找<a hidden class=anchor aria-hidden=true href=#422-二分查找>#</a></h4><p>【例题】请给出在含有 12 个元素的有序表 {1，4，10，16，17，18，23，29，33，40，50，51} 中二分查找关键字 17 的过程。</p><p><div class=pe-fancybox><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/tofuwine/tofuwine.github.io@repo/assets/953f45bd5e14257ab9346e7fb4472394.webp><img src=https://cdn.jsdelivr.net/gh/tofuwine/tofuwine.github.io@repo/assets/953f45bd5e14257ab9346e7fb4472394.webp#center alt=953f45bd5e14257ab9346e7fb4472394 onerror='this.onerror=null,this.src="/placeholder.svg",this.className="pe-image-placeholder"'></a></div></p><h4 id=423-哈希查找>4.2.3 哈希查找<a hidden class=anchor aria-hidden=true href=#423-哈希查找>#</a></h4><p>哈希表 hashtable 通过一个已记录的关键字为自变量的函数（哈希函数）得到该记录的存储地址，所以在哈希表中进行查找操作时，需用同一个哈希函数计算得到待查记录的存储地址，然后到相应的存储单元去获取有关信息再判定查找是否成功。</p><p>冲突的解决方式：随机探测再散列、线性探测。</p><p>【例题】设关键码序列为”47，34，13，12，52，38，33，27，3”，哈希表表长为 11，哈希函数为 Hash(key)=key mod 11，则</p><p>Hash(47) = 47 MOD 11 = 3, Hash(34) = 34 MOD 11 = 1,<br>Hash(13) = 13 MOD 11 = 2, Hash(12) = 12 MOD 11 = 1,<br>Hash(52) = 52 MOD 11 = 8, Hash(38) = 38 MOD 11 = 5,<br>Hash(33) = 33 MOD 11 = 0, Hash(27) = 27 MOD 11 = 5,<br>Hash(3) = 3 MOD 11 = 3</p><p>使用线性探测法解决冲突构造的哈希表如下：</p><table><thead><tr><th>哈希地址</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th></tr></thead><tbody><tr><td>关键字</td><td>33</td><td>34</td><td>13</td><td>47</td><td>12</td><td>38</td><td>27</td><td>3</td><td>52</td><td></td><td></td></tr></tbody></table><p>使用链地址法构造的哈希表如图所示：</p><p><div class=pe-fancybox><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/tofuwine/tofuwine.github.io@repo/assets/b64b74a41378c0acae36dc75eeca1cd8.webp><img src=https://cdn.jsdelivr.net/gh/tofuwine/tofuwine.github.io@repo/assets/b64b74a41378c0acae36dc75eeca1cd8.webp#center alt=b64b74a41378c0acae36dc75eeca1cd8 onerror='this.onerror=null,this.src="/placeholder.svg",this.className="pe-image-placeholder"'></a></div></p><p>上图所示的哈希表中进行成功查找的平均查找长度 ASL 为 $6 \times 1 + 3 \times 2)/9 \approx 1.34$</p><p><strong>真题示例 - 4.1</strong></p><p>设散列函数为 $H（key）= key \mod 11$ 对于关键字序列（23，40，91，17，19，10，31，65，26），用线性探测法解决冲突构造的哈希表为（）。</p><p><div class=pe-fancybox><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/tofuwine/tofuwine.github.io@repo/assets/e463e12bd0dadb904716c06e079d4407.webp><img src=https://cdn.jsdelivr.net/gh/tofuwine/tofuwine.github.io@repo/assets/e463e12bd0dadb904716c06e079d4407.webp#center alt=e463e12bd0dadb904716c06e079d4407 onerror='this.onerror=null,this.src="/placeholder.svg",this.className="pe-image-placeholder"'></a></div></p><h3 id=43-排序算法>4.3 排序算法<a hidden class=anchor aria-hidden=true href=#43-排序算法>#</a></h3><table><thead><tr><th>排序方法</th><th>时间复杂度<br>最好</th><th>时间复杂度<br>最坏</th><th>时间复杂度<br>平均</th><th>稳定性</th></tr></thead><tbody><tr><td>直接插入</td><td>\$O(n) \$</td><td>\$O(n^2) \$</td><td>\$O(n^2) \$</td><td>稳定</td></tr><tr><td>简单选择</td><td>\$O(n^2) \$</td><td>\$O(n^2) \$</td><td>\$O(n^2) \$</td><td>不稳定</td></tr><tr><td>冒泡排序</td><td>\$O(n) \$</td><td>\$O(n^2) \$</td><td>\$O(n^2) \$</td><td>稳定</td></tr><tr><td>希尔排序</td><td>\$O(n) \$</td><td>\$O(n^{1.3}) \$</td><td>\$O(n^{1.3}) \$</td><td>不稳定</td></tr><tr><td>快速排序</td><td>\$O(n^2) \$</td><td>\$O(n\log_2{n}) \$</td><td>\$O(n\log_2{n}) \$</td><td>不稳定</td></tr><tr><td>堆排序</td><td>\$O(n\log_2{n}) \$</td><td>\$O(n\log_2{n}) \$</td><td>\$O(n\log_2{n}) \$</td><td>不稳定</td></tr><tr><td>归并排序</td><td>\$O(n\log_2{n}) \$</td><td>\$O(n\log_2{n}) \$</td><td>\$O(n\log_2{n}) \$</td><td>稳定</td></tr></tbody></table><h4 id=431-直接插入排序>4.3.1 直接插入排序<a hidden class=anchor aria-hidden=true href=#431-直接插入排序>#</a></h4><div class="pe-tip warning">抱歉，此节笔记缺失</div><h4 id=432-冒泡排序>4.3.2 冒泡排序<a hidden class=anchor aria-hidden=true href=#432-冒泡排序>#</a></h4><p>【例题】排序数组：<code>int[] arr = {6,3,8,2,9,1}</code></p><p>第一趟排序：</p><ul><li>第一次排序：6 和 3 比较，6 大于 3，交换位置：3 6 8 2 9 1</li><li>第二次排序，6 和 8 比较，6 小于 8，不交换位置：3 6 8 2 9 1</li><li>第三次排序：8 和 2 比较，8 大于 2，交换位置：3 6 2 8 9 1</li><li>第四次排序：8 和 9 比较，8 小于 9，不交换位置：3 6 2 8 9 1</li><li>第五次排序：9 和 1 比较，9 大于 1，交换位置：3 6 3 8 1 9</li></ul><p>第一趟总共进行了 5 次比较，排序结果：3 6 2 8 1 9</p><p>第二趟排序：</p><ul><li>第一次排序：3 和 6 比较，3 小于 6，不交换位置：3 6 2 8 1 9</li><li>第二次排序：6 和 2 比较，6 大于 2，交换位置：3 2 6 8 1 9</li><li>第三次排序：6 和 8 比较，6 大于 8，不交换位置：3 2 6 8 1 9</li><li>第四次排序：8 和 1 比较，8 大于 1，交换位置：3 2 6 1 8 9</li></ul><p>第二趟总共进行了 4 次比较，排序结果：3 2 6 1 8 9</p><p>第三趟排序：</p><ul><li>第一次排序：3 和 2 比较，3 大于 2，交换位置：2 3 6 1 8 9</li><li>第二次排序：3 和 6 比较，3 小于 6，不交换位置：2 3 6 1 8 9</li><li>第三次排序：6 和 1 比较，6 大于 1，交换位置：2 3 1 6 8 9</li></ul><p>第三趟总共进行了 3 次排序，排序结果：2 3 1 6 8 9</p><p>第四趟排序：</p><ul><li>第一次排序：2 和 3 比较，2 小于 3，不交换位置：2 3 1 6 8 9</li><li>第二次排序：3 和 1 比较，3 大于 1，交换位置：2 1 3 6 8 9</li></ul><p>第四趟总共进行了 2 次排序，排序结果：2 1 3 6 8 9</p><p>第五趟排序：</p><ul><li>第一次排序：2 和 1 比较，2 大于 1，交换位置：1 2 3 6 8 9</li></ul><p>第五趟总共进行了 1 次排序，排序结果：1 2 3 6 8 9</p><p>最终结果：1 2 3 6 8 9</p><h4 id=433-简单选择排序>4.3.3 简单选择排序<a hidden class=anchor aria-hidden=true href=#433-简单选择排序>#</a></h4><p>初始关键字：【8，5，2，6，9，3，1，4，0，7】</p><p>第一趟排序后：0，【5，2，6，9，3，1，4，8，7】<br>第二趟排序后：0，1，【2，6，9，3，5，4，8，7】<br>第三趟排序后：0，1，2，【6，9，3，5，4，8，7】<br>第四趟排序后：0，1，2，3，【9，6，5，4，8，7】<br>第五趟排序后：0，1，2，3，4，【6，5，9，8，7】<br>第六躺排序后：0，1，2，3，4，5，【6，9，8，7】<br>第七趟排序后：0，1，2，3，4，5，6，【9，8，7】<br>第八趟排序后：0，1，2，3，4，5，6，7，【8，9】<br>第九趟排序后：0，1，2，3，4，5，6，7，8，【9】</p><p>结果：【0，1，2，3，4，5，6，7，8，9】</p><h4 id=434-希尔排序>4.3.4 希尔排序<a hidden class=anchor aria-hidden=true href=#434-希尔排序>#</a></h4><p>先将整个待排元素序列分割成若干个子序列（由相隔某个“增量”的元素组成的）分别进行直接插入排序，然后依次缩减增量再进行排序，待整个序列中的元素基本有序（增量足够小）时，再对全体元素进行一次直接插入排序。因为直接插入排序再元素基本有序的情况下（接近最好情况），效率是最高的。</p><p>先取一个小于 n 的整数 d1，作为第一个增量，把文件的全部记录分成 d1 个组，即将所有距离为 d1 倍数序号的记录放在同一个组中，在组内进行直接插入排序；然后取第二个增量 d2 &lt; d1，重复上述步骤，依次类推，直到所取的增量 di = 1，即将所有记录放在同一组进行直接插入排序。</p><h4 id=435-快速排序>4.3.5 快速排序<a hidden class=anchor aria-hidden=true href=#435-快速排序>#</a></h4><p>初始状态：46 30 82 90 56 17 95 15</p><p><div class=pe-fancybox><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/tofuwine/tofuwine.github.io@repo/assets/02df7499eaa4a147f1c14ee09f255115.webp><img src=https://cdn.jsdelivr.net/gh/tofuwine/tofuwine.github.io@repo/assets/02df7499eaa4a147f1c14ee09f255115.webp#center alt=02df7499eaa4a147f1c14ee09f255115 onerror='this.onerror=null,this.src="/placeholder.svg",this.className="pe-image-placeholder"'></a></div></p><h4 id=436-堆排序>4.3.6 堆排序<a hidden class=anchor aria-hidden=true href=#436-堆排序>#</a></h4><p>对于 n 个元素的关键字序列 \$\{K_1,K_2, \cdots, K_n\}\$，当且仅当满足下列关系时称其为堆，其中 \$2i\$ 和 \$2i+1\$ 应不大于 n。</p>$$
\begin{cases}
K_i \leq K_{2i} \\
K_i \leq K_{2i+1}
\end{cases}
或
\begin{cases}
K_i \geq K_{2i} \\
K_i \geq K_{2i+1}
\end{cases}
$$<p><div class=pe-fancybox><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/tofuwine/tofuwine.github.io@repo/assets/3da655e7dd00fe78faa967f6448671d3.webp><img src=https://cdn.jsdelivr.net/gh/tofuwine/tofuwine.github.io@repo/assets/3da655e7dd00fe78faa967f6448671d3.webp#center alt=3da655e7dd00fe78faa967f6448671d3 onerror='this.onerror=null,this.src="/placeholder.svg",this.className="pe-image-placeholder"'></a></div></p><p>为序列（55，60，40，10，80，65，15，5，75）建立初始大根堆的过程如图 3-56 所示，调整为新堆的过程如图 3-57 所示。</p><p><div class=pe-fancybox><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/tofuwine/tofuwine.github.io@repo/assets/a58e21236ae40a02ced84dd66173a465.webp><img src=https://cdn.jsdelivr.net/gh/tofuwine/tofuwine.github.io@repo/assets/a58e21236ae40a02ced84dd66173a465.webp#center alt=a58e21236ae40a02ced84dd66173a465 onerror='this.onerror=null,this.src="/placeholder.svg",this.className="pe-image-placeholder"'></a></div></p><h4 id=437-归并排序>4.3.7 归并排序<a hidden class=anchor aria-hidden=true href=#437-归并排序>#</a></h4><p>（1）分解。将 n 个元素分层各含 n/2 个元素的子序列。<br>（2）求解。用归并排序对两个子序列递归地排序。<br>（3）合并。合并两个已经排好序的子序列以得到排序结果。</p><p><div class=pe-fancybox><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/tofuwine/tofuwine.github.io@repo/assets/bb4a0962762c08ee389eed1617ff4528.webp><img src=https://cdn.jsdelivr.net/gh/tofuwine/tofuwine.github.io@repo/assets/bb4a0962762c08ee389eed1617ff4528.webp#center alt=bb4a0962762c08ee389eed1617ff4528 onerror='this.onerror=null,this.src="/placeholder.svg",this.className="pe-image-placeholder"'></a></div></p><h2 id=真题答案>真题答案<a hidden class=anchor aria-hidden=true href=#真题答案>#</a></h2><table><thead><tr><th>题号</th><th>答案</th></tr></thead><tbody><tr><td>2.1</td><td>B、A</td></tr><tr><td>2.2</td><td>A</td></tr><tr><td>2.3</td><td>D</td></tr><tr><td>2.4</td><td>B</td></tr><tr><td>2.5</td><td>A</td></tr><tr><td>2.6</td><td>D</td></tr><tr><td>3.1</td><td>D</td></tr><tr><td>3.2</td><td>C</td></tr><tr><td>3.3</td><td>D</td></tr><tr><td>3.4</td><td>D</td></tr><tr><td>3.5</td><td>A、A</td></tr><tr><td>3.6</td><td>B、A</td></tr><tr><td>3.7</td><td>A、B</td></tr><tr><td>4.1</td><td>B</td></tr></tbody></table></div><div class=pe-reward-wrap><div class=pe-reward><div class=pe-reward-btn><a href=javascript:void(0); onclick='document.querySelector(".pe-reward-overlay").classList.remove("hidden")'><svg t="1715776042195" class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" p-id="17691" width="20" height="20"><path d="M835.52 337.824a159.04 159.04.0 01124.544 59.52 155.904 155.904.0 0130.4 134.08l-80.896 341.632a157.952 157.952.0 01-56.224 87.68 160.544 160.544.0 01-98.688 33.952H166.72c-75.712.0-137.44-60.96-137.44-136.256v-363.84c0-75.296 61.76-136.288 137.44-136.288h80.704c50.176.0 71.232-12.48 85.792-36.544 10.368-17.12 17.472-41.376 23.04-76 1.728-10.656 2.88-19.392 5.408-38.72 11.712-90.944 21.888-124.736 62.528-155.168 25.504-19.072 56.768-25.984 90.72-20.992 64.672 9.504 115.936 43.52 145.824 97.6 23.36 42.272 32.64 95.584 27.904 154.24-1.056 12.832-2.752 25.888-5.12 38.912-.64 3.68-1.856 9.024-3.712 16.192h155.68zm-261.472 80 14.72-51.104c9.472-32.704 15.04-53.376 16.064-59.2 1.92-10.56 3.264-21.024 4.096-31.296 3.584-43.84-3.04-81.6-18.208-109.056-17.472-31.68-46.88-51.2-87.392-57.12-13.696-2.016-23.456.128-31.168 5.888-15.808 11.84-22.4 33.792-31.136 101.312-2.56 20.16-3.84 29.44-5.76 41.248-7.04 43.872-16.704 76.8-33.536 104.64-28.736 47.52-75.424 75.2-154.24 75.2H166.72c-31.744.0-57.44 25.376-57.44 56.224v363.872c0 30.88 25.696 56.256 57.44 56.256h587.904c17.824.0 35.424-6.08 49.344-16.96 13.856-10.848 23.68-26.24 27.712-43.104l80.896-341.6a75.904 75.904.0 00-14.944-65.6 79.04 79.04.0 00-62.144-29.6H574.08zm-212.8 205.984 97.28 72.64 242.24-209.28s16.224-13.888 30.4-3.008c4.256 3.264 9.12 12.512-1.856 27.008L476.416 789.024s-19.392 24.864-42.4-.288l-109.12-138.208s-12.96-18.688 3.264-29.92c5.44-3.744 17.888-9.6 33.12 3.2z" fill="currentcolor" p-id="17692"/></svg></div><div class="pe-reward-overlay hidden"><div class=pe-reward-qr-wrap><div class=pe-reward-img><a class=fancybox rel=group><img src=https://tofuwine.github.io/images/wechat_pay.jpg alt=wechat_pay></a><p>微信</p></div><div class=pe-reward-img><a class=fancybox rel=group><img src=https://tofuwine.github.io/images/alipay.jpg alt=alipay></a><p>支付宝</p></div></div></div><p>如果本文对你有所帮助，可以点击上方按钮请作者喝杯咖啡！</p></div></div><script>document.querySelector(".pe-reward-overlay").addEventListener("click",e=>{e.target.classList.add("hidden")})</script><div class=pe-copyright><hr><blockquote><p>本文为原创内容，版权归作者所有。如需转载，请在文章中声明本文标题及链接。</p><p>文章标题：第九章 数据结构 —— tofuwine</p><p>文章链接：<a href=https://tofuwine.github.io/posts/1ed9ada6/ target=_blank>https://tofuwine.github.io/posts/1ed9ada6/</a></p><p>许可协议：<a href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></p></blockquote></div><footer class=post-footer><ul class=post-tags><li><a href=https://tofuwine.github.io/tags/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/>软件设计师</a></li></ul><nav class=paginav><a class=prev href=https://tofuwine.github.io/posts/dc8a547c/><span class=title>上一篇</span><br><span>第八章 软件测试与维护</span>
</a><a class=next href=https://tofuwine.github.io/posts/523cd929/><span class=title>下一篇</span><br><span>第十章 算法设计与分析</span></a></nav></footer><div class=pe-comments-decoration><p class=pe-comments-title>欢迎来到评论区</p><p class=pe-comments-subtitle>感谢您的耐心阅读！来选个表情，或者留个评论吧！</p></div><div id=pe-comments></div><script src=/js/pe-go-comment.min.86a214102576ba5f9b7bdc29eed8d58dd56e34aef80b3c65c73ea9cc88443696.js integrity="sha256-hqIUECV2ul+be9wp7tjVjdVuNK74Czxlxz6pzIhENpY="></script><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const s={src:"https://giscus.app/client.js","data-repo":"tofuwine/tofuwine.github.io","data-repo-id":"R_kgDOLz45lw","data-category":"Announcements","data-category-id":"DIC_kwDOLz45l84CfBDJ","data-mapping":"specific","data-term":"posts/1ed9ada6","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"top","data-theme":getStoredTheme(),"data-lang":"zh-CN","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(s).forEach(([t,n])=>e.setAttribute(t,n)),document.querySelector("#pe-comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme);const n=document.querySelector("#theme-toggle-float");n&&n.addEventListener("click",setGiscusTheme)})</script></article></main><footer class=footer><span>&copy; 2024 <a href=https://tofuwine.github.io/>Tofuwine's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/tofuwine/PaperMod-PE rel=noopener target=_blank>PaperMod-PE</a></span></footer><div class=pe-right-sidebar><a href=#pe-comments class=pe-float-btn id=comments-link style=visibility:visible;opacity:1><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 29.338 29.338" fill="currentcolor"><path d="M27.184 1.605H2.156C.967 1.605.0 2.572.0 3.76v17.572c0 1.188.967 2.155 2.156 2.155h13.543l5.057 3.777c.414.31.842.468 1.268.468.789.0 1.639-.602 1.637-1.923v-2.322h3.523c1.188.0 2.154-.967 2.154-2.155V3.76C29.338 2.572 28.371 1.605 27.184 1.605zM27.34 21.332c0 .085-.068.155-.154.155h-5.523v3.955l-5.297-3.956H2.156c-.086.0-.154-.07-.154-.155V3.759c0-.085.068-.155.154-.155v.001h25.029c.086.0.154.07.154.155L27.34 21.332zM5.505 10.792h4.334v4.333H5.505V10.792zm7 0h4.334v4.333h-4.334V10.792zm7 0h4.334v4.333h-4.334V10.792z"/></svg>
</a><a href=javascript:void(0); id=theme-toggle-float class=pe-float-btn><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</a><a href=#top class=pe-float-btn id=top-link><span id=pe-read-progress></span></a></div></body></html>